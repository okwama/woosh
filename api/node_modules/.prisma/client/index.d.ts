
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model SalesRep
 * 
 */
export type SalesRep = $Result.DefaultSelection<Prisma.$SalesRepPayload>
/**
 * Model Manager
 * 
 */
export type Manager = $Result.DefaultSelection<Prisma.$ManagerPayload>
/**
 * Model Token
 * 
 */
export type Token = $Result.DefaultSelection<Prisma.$TokenPayload>
/**
 * Model Regions
 * 
 */
export type Regions = $Result.DefaultSelection<Prisma.$RegionsPayload>
/**
 * Model Country
 * 
 */
export type Country = $Result.DefaultSelection<Prisma.$CountryPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Category
 * 
 */
export type Category = $Result.DefaultSelection<Prisma.$CategoryPayload>
/**
 * Model PriceOption
 * 
 */
export type PriceOption = $Result.DefaultSelection<Prisma.$PriceOptionPayload>
/**
 * Model StoreQuantity
 * 
 */
export type StoreQuantity = $Result.DefaultSelection<Prisma.$StoreQuantityPayload>
/**
 * Model Stores
 * 
 */
export type Stores = $Result.DefaultSelection<Prisma.$StoresPayload>
/**
 * Model Purchase
 * 
 */
export type Purchase = $Result.DefaultSelection<Prisma.$PurchasePayload>
/**
 * Model PurchaseHistory
 * 
 */
export type PurchaseHistory = $Result.DefaultSelection<Prisma.$PurchaseHistoryPayload>
/**
 * Model Clients
 * 
 */
export type Clients = $Result.DefaultSelection<Prisma.$ClientsPayload>
/**
 * Model Riders
 * 
 */
export type Riders = $Result.DefaultSelection<Prisma.$RidersPayload>
/**
 * Model RidersCompany
 * 
 */
export type RidersCompany = $Result.DefaultSelection<Prisma.$RidersCompanyPayload>
/**
 * Model ManagerCheckin
 * 
 */
export type ManagerCheckin = $Result.DefaultSelection<Prisma.$ManagerCheckinPayload>
/**
 * Model MyOrder
 * 
 */
export type MyOrder = $Result.DefaultSelection<Prisma.$MyOrderPayload>
/**
 * Model OrderItem
 * 
 */
export type OrderItem = $Result.DefaultSelection<Prisma.$OrderItemPayload>
/**
 * Model JourneyPlan
 * 
 */
export type JourneyPlan = $Result.DefaultSelection<Prisma.$JourneyPlanPayload>
/**
 * Model NoticeBoard
 * 
 */
export type NoticeBoard = $Result.DefaultSelection<Prisma.$NoticeBoardPayload>
/**
 * Model Report
 * 
 */
export type Report = $Result.DefaultSelection<Prisma.$ReportPayload>
/**
 * Model FeedbackReport
 * 
 */
export type FeedbackReport = $Result.DefaultSelection<Prisma.$FeedbackReportPayload>
/**
 * Model ProductReport
 * 
 */
export type ProductReport = $Result.DefaultSelection<Prisma.$ProductReportPayload>
/**
 * Model VisibilityReport
 * 
 */
export type VisibilityReport = $Result.DefaultSelection<Prisma.$VisibilityReportPayload>
/**
 * Model Leave
 * 
 */
export type Leave = $Result.DefaultSelection<Prisma.$LeavePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ReportType: {
  PRODUCT_AVAILABILITY: 'PRODUCT_AVAILABILITY',
  VISIBILITY_ACTIVITY: 'VISIBILITY_ACTIVITY',
  FEEDBACK: 'FEEDBACK'
};

export type ReportType = (typeof ReportType)[keyof typeof ReportType]

}

export type ReportType = $Enums.ReportType

export const ReportType: typeof $Enums.ReportType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more SalesReps
 * const salesReps = await prisma.salesRep.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more SalesReps
   * const salesReps = await prisma.salesRep.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.salesRep`: Exposes CRUD operations for the **SalesRep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalesReps
    * const salesReps = await prisma.salesRep.findMany()
    * ```
    */
  get salesRep(): Prisma.SalesRepDelegate<ExtArgs>;

  /**
   * `prisma.manager`: Exposes CRUD operations for the **Manager** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Managers
    * const managers = await prisma.manager.findMany()
    * ```
    */
  get manager(): Prisma.ManagerDelegate<ExtArgs>;

  /**
   * `prisma.token`: Exposes CRUD operations for the **Token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tokens
    * const tokens = await prisma.token.findMany()
    * ```
    */
  get token(): Prisma.TokenDelegate<ExtArgs>;

  /**
   * `prisma.regions`: Exposes CRUD operations for the **Regions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Regions
    * const regions = await prisma.regions.findMany()
    * ```
    */
  get regions(): Prisma.RegionsDelegate<ExtArgs>;

  /**
   * `prisma.country`: Exposes CRUD operations for the **Country** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.country.findMany()
    * ```
    */
  get country(): Prisma.CountryDelegate<ExtArgs>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs>;

  /**
   * `prisma.category`: Exposes CRUD operations for the **Category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.category.findMany()
    * ```
    */
  get category(): Prisma.CategoryDelegate<ExtArgs>;

  /**
   * `prisma.priceOption`: Exposes CRUD operations for the **PriceOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PriceOptions
    * const priceOptions = await prisma.priceOption.findMany()
    * ```
    */
  get priceOption(): Prisma.PriceOptionDelegate<ExtArgs>;

  /**
   * `prisma.storeQuantity`: Exposes CRUD operations for the **StoreQuantity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StoreQuantities
    * const storeQuantities = await prisma.storeQuantity.findMany()
    * ```
    */
  get storeQuantity(): Prisma.StoreQuantityDelegate<ExtArgs>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **Stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.StoresDelegate<ExtArgs>;

  /**
   * `prisma.purchase`: Exposes CRUD operations for the **Purchase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Purchases
    * const purchases = await prisma.purchase.findMany()
    * ```
    */
  get purchase(): Prisma.PurchaseDelegate<ExtArgs>;

  /**
   * `prisma.purchaseHistory`: Exposes CRUD operations for the **PurchaseHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseHistories
    * const purchaseHistories = await prisma.purchaseHistory.findMany()
    * ```
    */
  get purchaseHistory(): Prisma.PurchaseHistoryDelegate<ExtArgs>;

  /**
   * `prisma.clients`: Exposes CRUD operations for the **Clients** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clients
    * const clients = await prisma.clients.findMany()
    * ```
    */
  get clients(): Prisma.ClientsDelegate<ExtArgs>;

  /**
   * `prisma.riders`: Exposes CRUD operations for the **Riders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Riders
    * const riders = await prisma.riders.findMany()
    * ```
    */
  get riders(): Prisma.RidersDelegate<ExtArgs>;

  /**
   * `prisma.ridersCompany`: Exposes CRUD operations for the **RidersCompany** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RidersCompanies
    * const ridersCompanies = await prisma.ridersCompany.findMany()
    * ```
    */
  get ridersCompany(): Prisma.RidersCompanyDelegate<ExtArgs>;

  /**
   * `prisma.managerCheckin`: Exposes CRUD operations for the **ManagerCheckin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ManagerCheckins
    * const managerCheckins = await prisma.managerCheckin.findMany()
    * ```
    */
  get managerCheckin(): Prisma.ManagerCheckinDelegate<ExtArgs>;

  /**
   * `prisma.myOrder`: Exposes CRUD operations for the **MyOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MyOrders
    * const myOrders = await prisma.myOrder.findMany()
    * ```
    */
  get myOrder(): Prisma.MyOrderDelegate<ExtArgs>;

  /**
   * `prisma.orderItem`: Exposes CRUD operations for the **OrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OrderItems
    * const orderItems = await prisma.orderItem.findMany()
    * ```
    */
  get orderItem(): Prisma.OrderItemDelegate<ExtArgs>;

  /**
   * `prisma.journeyPlan`: Exposes CRUD operations for the **JourneyPlan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JourneyPlans
    * const journeyPlans = await prisma.journeyPlan.findMany()
    * ```
    */
  get journeyPlan(): Prisma.JourneyPlanDelegate<ExtArgs>;

  /**
   * `prisma.noticeBoard`: Exposes CRUD operations for the **NoticeBoard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NoticeBoards
    * const noticeBoards = await prisma.noticeBoard.findMany()
    * ```
    */
  get noticeBoard(): Prisma.NoticeBoardDelegate<ExtArgs>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **Report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.ReportDelegate<ExtArgs>;

  /**
   * `prisma.feedbackReport`: Exposes CRUD operations for the **FeedbackReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FeedbackReports
    * const feedbackReports = await prisma.feedbackReport.findMany()
    * ```
    */
  get feedbackReport(): Prisma.FeedbackReportDelegate<ExtArgs>;

  /**
   * `prisma.productReport`: Exposes CRUD operations for the **ProductReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductReports
    * const productReports = await prisma.productReport.findMany()
    * ```
    */
  get productReport(): Prisma.ProductReportDelegate<ExtArgs>;

  /**
   * `prisma.visibilityReport`: Exposes CRUD operations for the **VisibilityReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VisibilityReports
    * const visibilityReports = await prisma.visibilityReport.findMany()
    * ```
    */
  get visibilityReport(): Prisma.VisibilityReportDelegate<ExtArgs>;

  /**
   * `prisma.leave`: Exposes CRUD operations for the **Leave** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaves
    * const leaves = await prisma.leave.findMany()
    * ```
    */
  get leave(): Prisma.LeaveDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    SalesRep: 'SalesRep',
    Manager: 'Manager',
    Token: 'Token',
    Regions: 'Regions',
    Country: 'Country',
    Product: 'Product',
    Category: 'Category',
    PriceOption: 'PriceOption',
    StoreQuantity: 'StoreQuantity',
    Stores: 'Stores',
    Purchase: 'Purchase',
    PurchaseHistory: 'PurchaseHistory',
    Clients: 'Clients',
    Riders: 'Riders',
    RidersCompany: 'RidersCompany',
    ManagerCheckin: 'ManagerCheckin',
    MyOrder: 'MyOrder',
    OrderItem: 'OrderItem',
    JourneyPlan: 'JourneyPlan',
    NoticeBoard: 'NoticeBoard',
    Report: 'Report',
    FeedbackReport: 'FeedbackReport',
    ProductReport: 'ProductReport',
    VisibilityReport: 'VisibilityReport',
    Leave: 'Leave'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "salesRep" | "manager" | "token" | "regions" | "country" | "product" | "category" | "priceOption" | "storeQuantity" | "stores" | "purchase" | "purchaseHistory" | "clients" | "riders" | "ridersCompany" | "managerCheckin" | "myOrder" | "orderItem" | "journeyPlan" | "noticeBoard" | "report" | "feedbackReport" | "productReport" | "visibilityReport" | "leave"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      SalesRep: {
        payload: Prisma.$SalesRepPayload<ExtArgs>
        fields: Prisma.SalesRepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalesRepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalesRepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          findFirst: {
            args: Prisma.SalesRepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalesRepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          findMany: {
            args: Prisma.SalesRepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>[]
          }
          create: {
            args: Prisma.SalesRepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          createMany: {
            args: Prisma.SalesRepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SalesRepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          update: {
            args: Prisma.SalesRepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          deleteMany: {
            args: Prisma.SalesRepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalesRepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SalesRepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalesRepPayload>
          }
          aggregate: {
            args: Prisma.SalesRepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalesRep>
          }
          groupBy: {
            args: Prisma.SalesRepGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalesRepGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalesRepCountArgs<ExtArgs>
            result: $Utils.Optional<SalesRepCountAggregateOutputType> | number
          }
        }
      }
      Manager: {
        payload: Prisma.$ManagerPayload<ExtArgs>
        fields: Prisma.ManagerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findFirst: {
            args: Prisma.ManagerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          findMany: {
            args: Prisma.ManagerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>[]
          }
          create: {
            args: Prisma.ManagerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          createMany: {
            args: Prisma.ManagerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManagerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          update: {
            args: Prisma.ManagerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          deleteMany: {
            args: Prisma.ManagerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManagerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerPayload>
          }
          aggregate: {
            args: Prisma.ManagerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManager>
          }
          groupBy: {
            args: Prisma.ManagerGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCountAggregateOutputType> | number
          }
        }
      }
      Token: {
        payload: Prisma.$TokenPayload<ExtArgs>
        fields: Prisma.TokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findFirst: {
            args: Prisma.TokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          findMany: {
            args: Prisma.TokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>[]
          }
          create: {
            args: Prisma.TokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          createMany: {
            args: Prisma.TokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          update: {
            args: Prisma.TokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          deleteMany: {
            args: Prisma.TokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenPayload>
          }
          aggregate: {
            args: Prisma.TokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateToken>
          }
          groupBy: {
            args: Prisma.TokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenCountArgs<ExtArgs>
            result: $Utils.Optional<TokenCountAggregateOutputType> | number
          }
        }
      }
      Regions: {
        payload: Prisma.$RegionsPayload<ExtArgs>
        fields: Prisma.RegionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          findFirst: {
            args: Prisma.RegionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          findMany: {
            args: Prisma.RegionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>[]
          }
          create: {
            args: Prisma.RegionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          createMany: {
            args: Prisma.RegionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RegionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          update: {
            args: Prisma.RegionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          deleteMany: {
            args: Prisma.RegionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegionsPayload>
          }
          aggregate: {
            args: Prisma.RegionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegions>
          }
          groupBy: {
            args: Prisma.RegionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegionsCountArgs<ExtArgs>
            result: $Utils.Optional<RegionsCountAggregateOutputType> | number
          }
        }
      }
      Country: {
        payload: Prisma.$CountryPayload<ExtArgs>
        fields: Prisma.CountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findFirst: {
            args: Prisma.CountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          findMany: {
            args: Prisma.CountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>[]
          }
          create: {
            args: Prisma.CountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          createMany: {
            args: Prisma.CountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          update: {
            args: Prisma.CountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          deleteMany: {
            args: Prisma.CountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryPayload>
          }
          aggregate: {
            args: Prisma.CountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountry>
          }
          groupBy: {
            args: Prisma.CountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Category: {
        payload: Prisma.$CategoryPayload<ExtArgs>
        fields: Prisma.CategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findFirst: {
            args: Prisma.CategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          findMany: {
            args: Prisma.CategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>[]
          }
          create: {
            args: Prisma.CategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          createMany: {
            args: Prisma.CategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          update: {
            args: Prisma.CategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          deleteMany: {
            args: Prisma.CategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CategoryPayload>
          }
          aggregate: {
            args: Prisma.CategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategory>
          }
          groupBy: {
            args: Prisma.CategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CategoryCountArgs<ExtArgs>
            result: $Utils.Optional<CategoryCountAggregateOutputType> | number
          }
        }
      }
      PriceOption: {
        payload: Prisma.$PriceOptionPayload<ExtArgs>
        fields: Prisma.PriceOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PriceOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PriceOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          findFirst: {
            args: Prisma.PriceOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PriceOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          findMany: {
            args: Prisma.PriceOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>[]
          }
          create: {
            args: Prisma.PriceOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          createMany: {
            args: Prisma.PriceOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PriceOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          update: {
            args: Prisma.PriceOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          deleteMany: {
            args: Prisma.PriceOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PriceOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PriceOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PriceOptionPayload>
          }
          aggregate: {
            args: Prisma.PriceOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePriceOption>
          }
          groupBy: {
            args: Prisma.PriceOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PriceOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PriceOptionCountArgs<ExtArgs>
            result: $Utils.Optional<PriceOptionCountAggregateOutputType> | number
          }
        }
      }
      StoreQuantity: {
        payload: Prisma.$StoreQuantityPayload<ExtArgs>
        fields: Prisma.StoreQuantityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoreQuantityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoreQuantityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          findFirst: {
            args: Prisma.StoreQuantityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoreQuantityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          findMany: {
            args: Prisma.StoreQuantityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>[]
          }
          create: {
            args: Prisma.StoreQuantityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          createMany: {
            args: Prisma.StoreQuantityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoreQuantityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          update: {
            args: Prisma.StoreQuantityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          deleteMany: {
            args: Prisma.StoreQuantityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoreQuantityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoreQuantityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoreQuantityPayload>
          }
          aggregate: {
            args: Prisma.StoreQuantityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStoreQuantity>
          }
          groupBy: {
            args: Prisma.StoreQuantityGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoreQuantityGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoreQuantityCountArgs<ExtArgs>
            result: $Utils.Optional<StoreQuantityCountAggregateOutputType> | number
          }
        }
      }
      Stores: {
        payload: Prisma.$StoresPayload<ExtArgs>
        fields: Prisma.StoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findFirst: {
            args: Prisma.StoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          findMany: {
            args: Prisma.StoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>[]
          }
          create: {
            args: Prisma.StoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          createMany: {
            args: Prisma.StoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.StoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          update: {
            args: Prisma.StoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          deleteMany: {
            args: Prisma.StoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StoresPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.StoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.StoresCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      Purchase: {
        payload: Prisma.$PurchasePayload<ExtArgs>
        fields: Prisma.PurchaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findFirst: {
            args: Prisma.PurchaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          findMany: {
            args: Prisma.PurchaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>[]
          }
          create: {
            args: Prisma.PurchaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          createMany: {
            args: Prisma.PurchaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          update: {
            args: Prisma.PurchaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          deleteMany: {
            args: Prisma.PurchaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchasePayload>
          }
          aggregate: {
            args: Prisma.PurchaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchase>
          }
          groupBy: {
            args: Prisma.PurchaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseCountAggregateOutputType> | number
          }
        }
      }
      PurchaseHistory: {
        payload: Prisma.$PurchaseHistoryPayload<ExtArgs>
        fields: Prisma.PurchaseHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findFirst: {
            args: Prisma.PurchaseHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          findMany: {
            args: Prisma.PurchaseHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>[]
          }
          create: {
            args: Prisma.PurchaseHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          createMany: {
            args: Prisma.PurchaseHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PurchaseHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          update: {
            args: Prisma.PurchaseHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PurchaseHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseHistoryPayload>
          }
          aggregate: {
            args: Prisma.PurchaseHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseHistory>
          }
          groupBy: {
            args: Prisma.PurchaseHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseHistoryCountAggregateOutputType> | number
          }
        }
      }
      Clients: {
        payload: Prisma.$ClientsPayload<ExtArgs>
        fields: Prisma.ClientsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          findFirst: {
            args: Prisma.ClientsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          findMany: {
            args: Prisma.ClientsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>[]
          }
          create: {
            args: Prisma.ClientsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          createMany: {
            args: Prisma.ClientsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ClientsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          update: {
            args: Prisma.ClientsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          deleteMany: {
            args: Prisma.ClientsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClientsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientsPayload>
          }
          aggregate: {
            args: Prisma.ClientsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClients>
          }
          groupBy: {
            args: Prisma.ClientsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientsCountArgs<ExtArgs>
            result: $Utils.Optional<ClientsCountAggregateOutputType> | number
          }
        }
      }
      Riders: {
        payload: Prisma.$RidersPayload<ExtArgs>
        fields: Prisma.RidersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RidersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RidersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          findFirst: {
            args: Prisma.RidersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RidersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          findMany: {
            args: Prisma.RidersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>[]
          }
          create: {
            args: Prisma.RidersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          createMany: {
            args: Prisma.RidersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RidersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          update: {
            args: Prisma.RidersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          deleteMany: {
            args: Prisma.RidersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RidersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RidersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersPayload>
          }
          aggregate: {
            args: Prisma.RidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiders>
          }
          groupBy: {
            args: Prisma.RidersGroupByArgs<ExtArgs>
            result: $Utils.Optional<RidersGroupByOutputType>[]
          }
          count: {
            args: Prisma.RidersCountArgs<ExtArgs>
            result: $Utils.Optional<RidersCountAggregateOutputType> | number
          }
        }
      }
      RidersCompany: {
        payload: Prisma.$RidersCompanyPayload<ExtArgs>
        fields: Prisma.RidersCompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RidersCompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RidersCompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          findFirst: {
            args: Prisma.RidersCompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RidersCompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          findMany: {
            args: Prisma.RidersCompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>[]
          }
          create: {
            args: Prisma.RidersCompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          createMany: {
            args: Prisma.RidersCompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RidersCompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          update: {
            args: Prisma.RidersCompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          deleteMany: {
            args: Prisma.RidersCompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RidersCompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RidersCompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RidersCompanyPayload>
          }
          aggregate: {
            args: Prisma.RidersCompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRidersCompany>
          }
          groupBy: {
            args: Prisma.RidersCompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<RidersCompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.RidersCompanyCountArgs<ExtArgs>
            result: $Utils.Optional<RidersCompanyCountAggregateOutputType> | number
          }
        }
      }
      ManagerCheckin: {
        payload: Prisma.$ManagerCheckinPayload<ExtArgs>
        fields: Prisma.ManagerCheckinFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ManagerCheckinFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ManagerCheckinFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          findFirst: {
            args: Prisma.ManagerCheckinFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ManagerCheckinFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          findMany: {
            args: Prisma.ManagerCheckinFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>[]
          }
          create: {
            args: Prisma.ManagerCheckinCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          createMany: {
            args: Prisma.ManagerCheckinCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ManagerCheckinDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          update: {
            args: Prisma.ManagerCheckinUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          deleteMany: {
            args: Prisma.ManagerCheckinDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ManagerCheckinUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ManagerCheckinUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ManagerCheckinPayload>
          }
          aggregate: {
            args: Prisma.ManagerCheckinAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManagerCheckin>
          }
          groupBy: {
            args: Prisma.ManagerCheckinGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManagerCheckinGroupByOutputType>[]
          }
          count: {
            args: Prisma.ManagerCheckinCountArgs<ExtArgs>
            result: $Utils.Optional<ManagerCheckinCountAggregateOutputType> | number
          }
        }
      }
      MyOrder: {
        payload: Prisma.$MyOrderPayload<ExtArgs>
        fields: Prisma.MyOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MyOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MyOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          findFirst: {
            args: Prisma.MyOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MyOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          findMany: {
            args: Prisma.MyOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>[]
          }
          create: {
            args: Prisma.MyOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          createMany: {
            args: Prisma.MyOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.MyOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          update: {
            args: Prisma.MyOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          deleteMany: {
            args: Prisma.MyOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MyOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MyOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MyOrderPayload>
          }
          aggregate: {
            args: Prisma.MyOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMyOrder>
          }
          groupBy: {
            args: Prisma.MyOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<MyOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.MyOrderCountArgs<ExtArgs>
            result: $Utils.Optional<MyOrderCountAggregateOutputType> | number
          }
        }
      }
      OrderItem: {
        payload: Prisma.$OrderItemPayload<ExtArgs>
        fields: Prisma.OrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findFirst: {
            args: Prisma.OrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          findMany: {
            args: Prisma.OrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>[]
          }
          create: {
            args: Prisma.OrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          createMany: {
            args: Prisma.OrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.OrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          update: {
            args: Prisma.OrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          deleteMany: {
            args: Prisma.OrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.OrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OrderItemPayload>
          }
          aggregate: {
            args: Prisma.OrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOrderItem>
          }
          groupBy: {
            args: Prisma.OrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<OrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.OrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<OrderItemCountAggregateOutputType> | number
          }
        }
      }
      JourneyPlan: {
        payload: Prisma.$JourneyPlanPayload<ExtArgs>
        fields: Prisma.JourneyPlanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JourneyPlanFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JourneyPlanFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          findFirst: {
            args: Prisma.JourneyPlanFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JourneyPlanFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          findMany: {
            args: Prisma.JourneyPlanFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>[]
          }
          create: {
            args: Prisma.JourneyPlanCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          createMany: {
            args: Prisma.JourneyPlanCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.JourneyPlanDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          update: {
            args: Prisma.JourneyPlanUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          deleteMany: {
            args: Prisma.JourneyPlanDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JourneyPlanUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.JourneyPlanUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JourneyPlanPayload>
          }
          aggregate: {
            args: Prisma.JourneyPlanAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJourneyPlan>
          }
          groupBy: {
            args: Prisma.JourneyPlanGroupByArgs<ExtArgs>
            result: $Utils.Optional<JourneyPlanGroupByOutputType>[]
          }
          count: {
            args: Prisma.JourneyPlanCountArgs<ExtArgs>
            result: $Utils.Optional<JourneyPlanCountAggregateOutputType> | number
          }
        }
      }
      NoticeBoard: {
        payload: Prisma.$NoticeBoardPayload<ExtArgs>
        fields: Prisma.NoticeBoardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NoticeBoardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NoticeBoardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          findFirst: {
            args: Prisma.NoticeBoardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NoticeBoardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          findMany: {
            args: Prisma.NoticeBoardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>[]
          }
          create: {
            args: Prisma.NoticeBoardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          createMany: {
            args: Prisma.NoticeBoardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.NoticeBoardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          update: {
            args: Prisma.NoticeBoardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          deleteMany: {
            args: Prisma.NoticeBoardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NoticeBoardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NoticeBoardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NoticeBoardPayload>
          }
          aggregate: {
            args: Prisma.NoticeBoardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNoticeBoard>
          }
          groupBy: {
            args: Prisma.NoticeBoardGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoticeBoardGroupByOutputType>[]
          }
          count: {
            args: Prisma.NoticeBoardCountArgs<ExtArgs>
            result: $Utils.Optional<NoticeBoardCountAggregateOutputType> | number
          }
        }
      }
      Report: {
        payload: Prisma.$ReportPayload<ExtArgs>
        fields: Prisma.ReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findFirst: {
            args: Prisma.ReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          findMany: {
            args: Prisma.ReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>[]
          }
          create: {
            args: Prisma.ReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          createMany: {
            args: Prisma.ReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          update: {
            args: Prisma.ReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          deleteMany: {
            args: Prisma.ReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportPayload>
          }
          aggregate: {
            args: Prisma.ReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReport>
          }
          groupBy: {
            args: Prisma.ReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReportCountAggregateOutputType> | number
          }
        }
      }
      FeedbackReport: {
        payload: Prisma.$FeedbackReportPayload<ExtArgs>
        fields: Prisma.FeedbackReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FeedbackReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FeedbackReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          findFirst: {
            args: Prisma.FeedbackReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FeedbackReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          findMany: {
            args: Prisma.FeedbackReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>[]
          }
          create: {
            args: Prisma.FeedbackReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          createMany: {
            args: Prisma.FeedbackReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FeedbackReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          update: {
            args: Prisma.FeedbackReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          deleteMany: {
            args: Prisma.FeedbackReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FeedbackReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FeedbackReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FeedbackReportPayload>
          }
          aggregate: {
            args: Prisma.FeedbackReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFeedbackReport>
          }
          groupBy: {
            args: Prisma.FeedbackReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<FeedbackReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.FeedbackReportCountArgs<ExtArgs>
            result: $Utils.Optional<FeedbackReportCountAggregateOutputType> | number
          }
        }
      }
      ProductReport: {
        payload: Prisma.$ProductReportPayload<ExtArgs>
        fields: Prisma.ProductReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          findFirst: {
            args: Prisma.ProductReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          findMany: {
            args: Prisma.ProductReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>[]
          }
          create: {
            args: Prisma.ProductReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          createMany: {
            args: Prisma.ProductReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ProductReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          update: {
            args: Prisma.ProductReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          deleteMany: {
            args: Prisma.ProductReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProductReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductReportPayload>
          }
          aggregate: {
            args: Prisma.ProductReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductReport>
          }
          groupBy: {
            args: Prisma.ProductReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductReportCountArgs<ExtArgs>
            result: $Utils.Optional<ProductReportCountAggregateOutputType> | number
          }
        }
      }
      VisibilityReport: {
        payload: Prisma.$VisibilityReportPayload<ExtArgs>
        fields: Prisma.VisibilityReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VisibilityReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VisibilityReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          findFirst: {
            args: Prisma.VisibilityReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VisibilityReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          findMany: {
            args: Prisma.VisibilityReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>[]
          }
          create: {
            args: Prisma.VisibilityReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          createMany: {
            args: Prisma.VisibilityReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VisibilityReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          update: {
            args: Prisma.VisibilityReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          deleteMany: {
            args: Prisma.VisibilityReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VisibilityReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VisibilityReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VisibilityReportPayload>
          }
          aggregate: {
            args: Prisma.VisibilityReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVisibilityReport>
          }
          groupBy: {
            args: Prisma.VisibilityReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<VisibilityReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.VisibilityReportCountArgs<ExtArgs>
            result: $Utils.Optional<VisibilityReportCountAggregateOutputType> | number
          }
        }
      }
      Leave: {
        payload: Prisma.$LeavePayload<ExtArgs>
        fields: Prisma.LeaveFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findFirst: {
            args: Prisma.LeaveFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          findMany: {
            args: Prisma.LeaveFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>[]
          }
          create: {
            args: Prisma.LeaveCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          createMany: {
            args: Prisma.LeaveCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaveDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          update: {
            args: Prisma.LeaveUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          deleteMany: {
            args: Prisma.LeaveDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeavePayload>
          }
          aggregate: {
            args: Prisma.LeaveAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeave>
          }
          groupBy: {
            args: Prisma.LeaveGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type SalesRepCountOutputType
   */

  export type SalesRepCountOutputType = {
    journeyPlans: number
    reports: number
    tokens: number
    leaves: number
    MyOrder: number
  }

  export type SalesRepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journeyPlans?: boolean | SalesRepCountOutputTypeCountJourneyPlansArgs
    reports?: boolean | SalesRepCountOutputTypeCountReportsArgs
    tokens?: boolean | SalesRepCountOutputTypeCountTokensArgs
    leaves?: boolean | SalesRepCountOutputTypeCountLeavesArgs
    MyOrder?: boolean | SalesRepCountOutputTypeCountMyOrderArgs
  }

  // Custom InputTypes
  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRepCountOutputType
     */
    select?: SalesRepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeCountJourneyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyPlanWhereInput
  }

  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeCountTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
  }

  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeCountLeavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
  }

  /**
   * SalesRepCountOutputType without action
   */
  export type SalesRepCountOutputTypeCountMyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MyOrderWhereInput
  }


  /**
   * Count Type ManagerCountOutputType
   */

  export type ManagerCountOutputType = {
    checkins: number
  }

  export type ManagerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checkins?: boolean | ManagerCountOutputTypeCountCheckinsArgs
  }

  // Custom InputTypes
  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCountOutputType
     */
    select?: ManagerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ManagerCountOutputType without action
   */
  export type ManagerCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerCheckinWhereInput
  }


  /**
   * Count Type CountryCountOutputType
   */

  export type CountryCountOutputType = {
    regions: number
    clients: number
    salesRep: number
  }

  export type CountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regions?: boolean | CountryCountOutputTypeCountRegionsArgs
    clients?: boolean | CountryCountOutputTypeCountClientsArgs
    salesRep?: boolean | CountryCountOutputTypeCountSalesRepArgs
  }

  // Custom InputTypes
  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCountOutputType
     */
    select?: CountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountRegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionsWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientsWhereInput
  }

  /**
   * CountryCountOutputType without action
   */
  export type CountryCountOutputTypeCountSalesRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesRepWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    orderItems: number
    storeQuantities: number
    purchase: number
    purchaseHistory: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | ProductCountOutputTypeCountOrderItemsArgs
    storeQuantities?: boolean | ProductCountOutputTypeCountStoreQuantitiesArgs
    purchase?: boolean | ProductCountOutputTypeCountPurchaseArgs
    purchaseHistory?: boolean | ProductCountOutputTypeCountPurchaseHistoryArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountStoreQuantitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreQuantityWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountPurchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
  }


  /**
   * Count Type CategoryCountOutputType
   */

  export type CategoryCountOutputType = {
    priceOptions: number
  }

  export type CategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceOptions?: boolean | CategoryCountOutputTypeCountPriceOptionsArgs
  }

  // Custom InputTypes
  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoryCountOutputType
     */
    select?: CategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoryCountOutputType without action
   */
  export type CategoryCountOutputTypeCountPriceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceOptionWhereInput
  }


  /**
   * Count Type PriceOptionCountOutputType
   */

  export type PriceOptionCountOutputType = {
    orderItems: number
  }

  export type PriceOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | PriceOptionCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * PriceOptionCountOutputType without action
   */
  export type PriceOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOptionCountOutputType
     */
    select?: PriceOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PriceOptionCountOutputType without action
   */
  export type PriceOptionCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    storeQuantities: number
    purchase: number
    purchaseHistory: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeQuantities?: boolean | StoresCountOutputTypeCountStoreQuantitiesArgs
    purchase?: boolean | StoresCountOutputTypeCountPurchaseArgs
    purchaseHistory?: boolean | StoresCountOutputTypeCountPurchaseHistoryArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountStoreQuantitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreQuantityWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountPurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountPurchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
  }


  /**
   * Count Type ClientsCountOutputType
   */

  export type ClientsCountOutputType = {
    journeyPlans: number
    MyOrder: number
    products: number
    reports: number
    checkins: number
  }

  export type ClientsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    journeyPlans?: boolean | ClientsCountOutputTypeCountJourneyPlansArgs
    MyOrder?: boolean | ClientsCountOutputTypeCountMyOrderArgs
    products?: boolean | ClientsCountOutputTypeCountProductsArgs
    reports?: boolean | ClientsCountOutputTypeCountReportsArgs
    checkins?: boolean | ClientsCountOutputTypeCountCheckinsArgs
  }

  // Custom InputTypes
  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientsCountOutputType
     */
    select?: ClientsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountJourneyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyPlanWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountMyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MyOrderWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }

  /**
   * ClientsCountOutputType without action
   */
  export type ClientsCountOutputTypeCountCheckinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerCheckinWhereInput
  }


  /**
   * Count Type MyOrderCountOutputType
   */

  export type MyOrderCountOutputType = {
    orderItems: number
    reports: number
  }

  export type MyOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | MyOrderCountOutputTypeCountOrderItemsArgs
    reports?: boolean | MyOrderCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * MyOrderCountOutputType without action
   */
  export type MyOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrderCountOutputType
     */
    select?: MyOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MyOrderCountOutputType without action
   */
  export type MyOrderCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
  }

  /**
   * MyOrderCountOutputType without action
   */
  export type MyOrderCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type JourneyPlanCountOutputType
   */

  export type JourneyPlanCountOutputType = {
    reports: number
  }

  export type JourneyPlanCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reports?: boolean | JourneyPlanCountOutputTypeCountReportsArgs
  }

  // Custom InputTypes
  /**
   * JourneyPlanCountOutputType without action
   */
  export type JourneyPlanCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlanCountOutputType
     */
    select?: JourneyPlanCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * JourneyPlanCountOutputType without action
   */
  export type JourneyPlanCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
  }


  /**
   * Count Type ReportCountOutputType
   */

  export type ReportCountOutputType = {
    MyOrder: number
  }

  export type ReportCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    MyOrder?: boolean | ReportCountOutputTypeCountMyOrderArgs
  }

  // Custom InputTypes
  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReportCountOutputType
     */
    select?: ReportCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReportCountOutputType without action
   */
  export type ReportCountOutputTypeCountMyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MyOrderWhereInput
  }


  /**
   * Models
   */

  /**
   * Model SalesRep
   */

  export type AggregateSalesRep = {
    _count: SalesRepCountAggregateOutputType | null
    _avg: SalesRepAvgAggregateOutputType | null
    _sum: SalesRepSumAggregateOutputType | null
    _min: SalesRepMinAggregateOutputType | null
    _max: SalesRepMaxAggregateOutputType | null
  }

  export type SalesRepAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
    region_id: number | null
    status: number | null
  }

  export type SalesRepSumAggregateOutputType = {
    id: number | null
    countryId: number | null
    region_id: number | null
    status: number | null
  }

  export type SalesRepMinAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    countryId: number | null
    region_id: number | null
    region: string | null
    role: string | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
    photoUrl: string | null
  }

  export type SalesRepMaxAggregateOutputType = {
    id: number | null
    name: string | null
    email: string | null
    phoneNumber: string | null
    password: string | null
    countryId: number | null
    region_id: number | null
    region: string | null
    role: string | null
    status: number | null
    createdAt: Date | null
    updatedAt: Date | null
    photoUrl: string | null
  }

  export type SalesRepCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phoneNumber: number
    password: number
    countryId: number
    region_id: number
    region: number
    role: number
    status: number
    createdAt: number
    updatedAt: number
    photoUrl: number
    _all: number
  }


  export type SalesRepAvgAggregateInputType = {
    id?: true
    countryId?: true
    region_id?: true
    status?: true
  }

  export type SalesRepSumAggregateInputType = {
    id?: true
    countryId?: true
    region_id?: true
    status?: true
  }

  export type SalesRepMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    countryId?: true
    region_id?: true
    region?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    photoUrl?: true
  }

  export type SalesRepMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    countryId?: true
    region_id?: true
    region?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    photoUrl?: true
  }

  export type SalesRepCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phoneNumber?: true
    password?: true
    countryId?: true
    region_id?: true
    region?: true
    role?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    photoUrl?: true
    _all?: true
  }

  export type SalesRepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesRep to aggregate.
     */
    where?: SalesRepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReps to fetch.
     */
    orderBy?: SalesRepOrderByWithRelationInput | SalesRepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalesRepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalesReps
    **/
    _count?: true | SalesRepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalesRepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalesRepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalesRepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalesRepMaxAggregateInputType
  }

  export type GetSalesRepAggregateType<T extends SalesRepAggregateArgs> = {
        [P in keyof T & keyof AggregateSalesRep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalesRep[P]>
      : GetScalarType<T[P], AggregateSalesRep[P]>
  }




  export type SalesRepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalesRepWhereInput
    orderBy?: SalesRepOrderByWithAggregationInput | SalesRepOrderByWithAggregationInput[]
    by: SalesRepScalarFieldEnum[] | SalesRepScalarFieldEnum
    having?: SalesRepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalesRepCountAggregateInputType | true
    _avg?: SalesRepAvgAggregateInputType
    _sum?: SalesRepSumAggregateInputType
    _min?: SalesRepMinAggregateInputType
    _max?: SalesRepMaxAggregateInputType
  }

  export type SalesRepGroupByOutputType = {
    id: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role: string | null
    status: number | null
    createdAt: Date
    updatedAt: Date
    photoUrl: string | null
    _count: SalesRepCountAggregateOutputType | null
    _avg: SalesRepAvgAggregateOutputType | null
    _sum: SalesRepSumAggregateOutputType | null
    _min: SalesRepMinAggregateOutputType | null
    _max: SalesRepMaxAggregateOutputType | null
  }

  type GetSalesRepGroupByPayload<T extends SalesRepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalesRepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalesRepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalesRepGroupByOutputType[P]>
            : GetScalarType<T[P], SalesRepGroupByOutputType[P]>
        }
      >
    >


  export type SalesRepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    countryId?: boolean
    region_id?: boolean
    region?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photoUrl?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    journeyPlans?: boolean | SalesRep$journeyPlansArgs<ExtArgs>
    reports?: boolean | SalesRep$reportsArgs<ExtArgs>
    tokens?: boolean | SalesRep$tokensArgs<ExtArgs>
    leaves?: boolean | SalesRep$leavesArgs<ExtArgs>
    Manager?: boolean | SalesRep$ManagerArgs<ExtArgs>
    MyOrder?: boolean | SalesRep$MyOrderArgs<ExtArgs>
    _count?: boolean | SalesRepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["salesRep"]>


  export type SalesRepSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phoneNumber?: boolean
    password?: boolean
    countryId?: boolean
    region_id?: boolean
    region?: boolean
    role?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    photoUrl?: boolean
  }

  export type SalesRepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    journeyPlans?: boolean | SalesRep$journeyPlansArgs<ExtArgs>
    reports?: boolean | SalesRep$reportsArgs<ExtArgs>
    tokens?: boolean | SalesRep$tokensArgs<ExtArgs>
    leaves?: boolean | SalesRep$leavesArgs<ExtArgs>
    Manager?: boolean | SalesRep$ManagerArgs<ExtArgs>
    MyOrder?: boolean | SalesRep$MyOrderArgs<ExtArgs>
    _count?: boolean | SalesRepCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SalesRepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalesRep"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      journeyPlans: Prisma.$JourneyPlanPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      tokens: Prisma.$TokenPayload<ExtArgs>[]
      leaves: Prisma.$LeavePayload<ExtArgs>[]
      Manager: Prisma.$ManagerPayload<ExtArgs> | null
      MyOrder: Prisma.$MyOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      email: string
      phoneNumber: string
      password: string
      countryId: number
      region_id: number
      region: string
      role: string | null
      status: number | null
      createdAt: Date
      updatedAt: Date
      photoUrl: string | null
    }, ExtArgs["result"]["salesRep"]>
    composites: {}
  }

  type SalesRepGetPayload<S extends boolean | null | undefined | SalesRepDefaultArgs> = $Result.GetResult<Prisma.$SalesRepPayload, S>

  type SalesRepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SalesRepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SalesRepCountAggregateInputType | true
    }

  export interface SalesRepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalesRep'], meta: { name: 'SalesRep' } }
    /**
     * Find zero or one SalesRep that matches the filter.
     * @param {SalesRepFindUniqueArgs} args - Arguments to find a SalesRep
     * @example
     * // Get one SalesRep
     * const salesRep = await prisma.salesRep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalesRepFindUniqueArgs>(args: SelectSubset<T, SalesRepFindUniqueArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SalesRep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SalesRepFindUniqueOrThrowArgs} args - Arguments to find a SalesRep
     * @example
     * // Get one SalesRep
     * const salesRep = await prisma.salesRep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalesRepFindUniqueOrThrowArgs>(args: SelectSubset<T, SalesRepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SalesRep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepFindFirstArgs} args - Arguments to find a SalesRep
     * @example
     * // Get one SalesRep
     * const salesRep = await prisma.salesRep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalesRepFindFirstArgs>(args?: SelectSubset<T, SalesRepFindFirstArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SalesRep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepFindFirstOrThrowArgs} args - Arguments to find a SalesRep
     * @example
     * // Get one SalesRep
     * const salesRep = await prisma.salesRep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalesRepFindFirstOrThrowArgs>(args?: SelectSubset<T, SalesRepFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SalesReps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalesReps
     * const salesReps = await prisma.salesRep.findMany()
     * 
     * // Get first 10 SalesReps
     * const salesReps = await prisma.salesRep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salesRepWithIdOnly = await prisma.salesRep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalesRepFindManyArgs>(args?: SelectSubset<T, SalesRepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SalesRep.
     * @param {SalesRepCreateArgs} args - Arguments to create a SalesRep.
     * @example
     * // Create one SalesRep
     * const SalesRep = await prisma.salesRep.create({
     *   data: {
     *     // ... data to create a SalesRep
     *   }
     * })
     * 
     */
    create<T extends SalesRepCreateArgs>(args: SelectSubset<T, SalesRepCreateArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SalesReps.
     * @param {SalesRepCreateManyArgs} args - Arguments to create many SalesReps.
     * @example
     * // Create many SalesReps
     * const salesRep = await prisma.salesRep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalesRepCreateManyArgs>(args?: SelectSubset<T, SalesRepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SalesRep.
     * @param {SalesRepDeleteArgs} args - Arguments to delete one SalesRep.
     * @example
     * // Delete one SalesRep
     * const SalesRep = await prisma.salesRep.delete({
     *   where: {
     *     // ... filter to delete one SalesRep
     *   }
     * })
     * 
     */
    delete<T extends SalesRepDeleteArgs>(args: SelectSubset<T, SalesRepDeleteArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SalesRep.
     * @param {SalesRepUpdateArgs} args - Arguments to update one SalesRep.
     * @example
     * // Update one SalesRep
     * const salesRep = await prisma.salesRep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalesRepUpdateArgs>(args: SelectSubset<T, SalesRepUpdateArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SalesReps.
     * @param {SalesRepDeleteManyArgs} args - Arguments to filter SalesReps to delete.
     * @example
     * // Delete a few SalesReps
     * const { count } = await prisma.salesRep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalesRepDeleteManyArgs>(args?: SelectSubset<T, SalesRepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalesReps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalesReps
     * const salesRep = await prisma.salesRep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalesRepUpdateManyArgs>(args: SelectSubset<T, SalesRepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SalesRep.
     * @param {SalesRepUpsertArgs} args - Arguments to update or create a SalesRep.
     * @example
     * // Update or create a SalesRep
     * const salesRep = await prisma.salesRep.upsert({
     *   create: {
     *     // ... data to create a SalesRep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalesRep we want to update
     *   }
     * })
     */
    upsert<T extends SalesRepUpsertArgs>(args: SelectSubset<T, SalesRepUpsertArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SalesReps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepCountArgs} args - Arguments to filter SalesReps to count.
     * @example
     * // Count the number of SalesReps
     * const count = await prisma.salesRep.count({
     *   where: {
     *     // ... the filter for the SalesReps we want to count
     *   }
     * })
    **/
    count<T extends SalesRepCountArgs>(
      args?: Subset<T, SalesRepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalesRepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalesRep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalesRepAggregateArgs>(args: Subset<T, SalesRepAggregateArgs>): Prisma.PrismaPromise<GetSalesRepAggregateType<T>>

    /**
     * Group by SalesRep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalesRepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalesRepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalesRepGroupByArgs['orderBy'] }
        : { orderBy?: SalesRepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalesRepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalesRepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalesRep model
   */
  readonly fields: SalesRepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalesRep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalesRepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journeyPlans<T extends SalesRep$journeyPlansArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$journeyPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends SalesRep$reportsArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    tokens<T extends SalesRep$tokensArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$tokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany"> | Null>
    leaves<T extends SalesRep$leavesArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$leavesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany"> | Null>
    Manager<T extends SalesRep$ManagerArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$ManagerArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    MyOrder<T extends SalesRep$MyOrderArgs<ExtArgs> = {}>(args?: Subset<T, SalesRep$MyOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalesRep model
   */ 
  interface SalesRepFieldRefs {
    readonly id: FieldRef<"SalesRep", 'Int'>
    readonly name: FieldRef<"SalesRep", 'String'>
    readonly email: FieldRef<"SalesRep", 'String'>
    readonly phoneNumber: FieldRef<"SalesRep", 'String'>
    readonly password: FieldRef<"SalesRep", 'String'>
    readonly countryId: FieldRef<"SalesRep", 'Int'>
    readonly region_id: FieldRef<"SalesRep", 'Int'>
    readonly region: FieldRef<"SalesRep", 'String'>
    readonly role: FieldRef<"SalesRep", 'String'>
    readonly status: FieldRef<"SalesRep", 'Int'>
    readonly createdAt: FieldRef<"SalesRep", 'DateTime'>
    readonly updatedAt: FieldRef<"SalesRep", 'DateTime'>
    readonly photoUrl: FieldRef<"SalesRep", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SalesRep findUnique
   */
  export type SalesRepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter, which SalesRep to fetch.
     */
    where: SalesRepWhereUniqueInput
  }

  /**
   * SalesRep findUniqueOrThrow
   */
  export type SalesRepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter, which SalesRep to fetch.
     */
    where: SalesRepWhereUniqueInput
  }

  /**
   * SalesRep findFirst
   */
  export type SalesRepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter, which SalesRep to fetch.
     */
    where?: SalesRepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReps to fetch.
     */
    orderBy?: SalesRepOrderByWithRelationInput | SalesRepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReps.
     */
    cursor?: SalesRepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReps.
     */
    distinct?: SalesRepScalarFieldEnum | SalesRepScalarFieldEnum[]
  }

  /**
   * SalesRep findFirstOrThrow
   */
  export type SalesRepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter, which SalesRep to fetch.
     */
    where?: SalesRepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReps to fetch.
     */
    orderBy?: SalesRepOrderByWithRelationInput | SalesRepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalesReps.
     */
    cursor?: SalesRepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalesReps.
     */
    distinct?: SalesRepScalarFieldEnum | SalesRepScalarFieldEnum[]
  }

  /**
   * SalesRep findMany
   */
  export type SalesRepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter, which SalesReps to fetch.
     */
    where?: SalesRepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalesReps to fetch.
     */
    orderBy?: SalesRepOrderByWithRelationInput | SalesRepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalesReps.
     */
    cursor?: SalesRepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalesReps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalesReps.
     */
    skip?: number
    distinct?: SalesRepScalarFieldEnum | SalesRepScalarFieldEnum[]
  }

  /**
   * SalesRep create
   */
  export type SalesRepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * The data needed to create a SalesRep.
     */
    data: XOR<SalesRepCreateInput, SalesRepUncheckedCreateInput>
  }

  /**
   * SalesRep createMany
   */
  export type SalesRepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalesReps.
     */
    data: SalesRepCreateManyInput | SalesRepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalesRep update
   */
  export type SalesRepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * The data needed to update a SalesRep.
     */
    data: XOR<SalesRepUpdateInput, SalesRepUncheckedUpdateInput>
    /**
     * Choose, which SalesRep to update.
     */
    where: SalesRepWhereUniqueInput
  }

  /**
   * SalesRep updateMany
   */
  export type SalesRepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalesReps.
     */
    data: XOR<SalesRepUpdateManyMutationInput, SalesRepUncheckedUpdateManyInput>
    /**
     * Filter which SalesReps to update
     */
    where?: SalesRepWhereInput
  }

  /**
   * SalesRep upsert
   */
  export type SalesRepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * The filter to search for the SalesRep to update in case it exists.
     */
    where: SalesRepWhereUniqueInput
    /**
     * In case the SalesRep found by the `where` argument doesn't exist, create a new SalesRep with this data.
     */
    create: XOR<SalesRepCreateInput, SalesRepUncheckedCreateInput>
    /**
     * In case the SalesRep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalesRepUpdateInput, SalesRepUncheckedUpdateInput>
  }

  /**
   * SalesRep delete
   */
  export type SalesRepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    /**
     * Filter which SalesRep to delete.
     */
    where: SalesRepWhereUniqueInput
  }

  /**
   * SalesRep deleteMany
   */
  export type SalesRepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalesReps to delete
     */
    where?: SalesRepWhereInput
  }

  /**
   * SalesRep.journeyPlans
   */
  export type SalesRep$journeyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    where?: JourneyPlanWhereInput
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    cursor?: JourneyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyPlanScalarFieldEnum | JourneyPlanScalarFieldEnum[]
  }

  /**
   * SalesRep.reports
   */
  export type SalesRep$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * SalesRep.tokens
   */
  export type SalesRep$tokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    cursor?: TokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * SalesRep.leaves
   */
  export type SalesRep$leavesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    cursor?: LeaveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * SalesRep.Manager
   */
  export type SalesRep$ManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    where?: ManagerWhereInput
  }

  /**
   * SalesRep.MyOrder
   */
  export type SalesRep$MyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    where?: MyOrderWhereInput
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    cursor?: MyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * SalesRep without action
   */
  export type SalesRepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
  }


  /**
   * Model Manager
   */

  export type AggregateManager = {
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  export type ManagerAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ManagerSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type ManagerMinAggregateOutputType = {
    id: number | null
    userId: number | null
    department: string | null
  }

  export type ManagerMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    department: string | null
  }

  export type ManagerCountAggregateOutputType = {
    id: number
    userId: number
    department: number
    _all: number
  }


  export type ManagerAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ManagerSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type ManagerMinAggregateInputType = {
    id?: true
    userId?: true
    department?: true
  }

  export type ManagerMaxAggregateInputType = {
    id?: true
    userId?: true
    department?: true
  }

  export type ManagerCountAggregateInputType = {
    id?: true
    userId?: true
    department?: true
    _all?: true
  }

  export type ManagerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Manager to aggregate.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Managers
    **/
    _count?: true | ManagerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerMaxAggregateInputType
  }

  export type GetManagerAggregateType<T extends ManagerAggregateArgs> = {
        [P in keyof T & keyof AggregateManager]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManager[P]>
      : GetScalarType<T[P], AggregateManager[P]>
  }




  export type ManagerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerWhereInput
    orderBy?: ManagerOrderByWithAggregationInput | ManagerOrderByWithAggregationInput[]
    by: ManagerScalarFieldEnum[] | ManagerScalarFieldEnum
    having?: ManagerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCountAggregateInputType | true
    _avg?: ManagerAvgAggregateInputType
    _sum?: ManagerSumAggregateInputType
    _min?: ManagerMinAggregateInputType
    _max?: ManagerMaxAggregateInputType
  }

  export type ManagerGroupByOutputType = {
    id: number
    userId: number
    department: string | null
    _count: ManagerCountAggregateOutputType | null
    _avg: ManagerAvgAggregateOutputType | null
    _sum: ManagerSumAggregateOutputType | null
    _min: ManagerMinAggregateOutputType | null
    _max: ManagerMaxAggregateOutputType | null
  }

  type GetManagerGroupByPayload<T extends ManagerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerGroupByOutputType[P]>
        }
      >
    >


  export type ManagerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    department?: boolean
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    checkins?: boolean | Manager$checkinsArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manager"]>


  export type ManagerSelectScalar = {
    id?: boolean
    userId?: boolean
    department?: boolean
  }

  export type ManagerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    checkins?: boolean | Manager$checkinsArgs<ExtArgs>
    _count?: boolean | ManagerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ManagerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Manager"
    objects: {
      user: Prisma.$SalesRepPayload<ExtArgs>
      checkins: Prisma.$ManagerCheckinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      department: string | null
    }, ExtArgs["result"]["manager"]>
    composites: {}
  }

  type ManagerGetPayload<S extends boolean | null | undefined | ManagerDefaultArgs> = $Result.GetResult<Prisma.$ManagerPayload, S>

  type ManagerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ManagerFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ManagerCountAggregateInputType | true
    }

  export interface ManagerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Manager'], meta: { name: 'Manager' } }
    /**
     * Find zero or one Manager that matches the filter.
     * @param {ManagerFindUniqueArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerFindUniqueArgs>(args: SelectSubset<T, ManagerFindUniqueArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Manager that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ManagerFindUniqueOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Manager that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerFindFirstArgs>(args?: SelectSubset<T, ManagerFindFirstArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Manager that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindFirstOrThrowArgs} args - Arguments to find a Manager
     * @example
     * // Get one Manager
     * const manager = await prisma.manager.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Managers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Managers
     * const managers = await prisma.manager.findMany()
     * 
     * // Get first 10 Managers
     * const managers = await prisma.manager.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerWithIdOnly = await prisma.manager.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerFindManyArgs>(args?: SelectSubset<T, ManagerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Manager.
     * @param {ManagerCreateArgs} args - Arguments to create a Manager.
     * @example
     * // Create one Manager
     * const Manager = await prisma.manager.create({
     *   data: {
     *     // ... data to create a Manager
     *   }
     * })
     * 
     */
    create<T extends ManagerCreateArgs>(args: SelectSubset<T, ManagerCreateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Managers.
     * @param {ManagerCreateManyArgs} args - Arguments to create many Managers.
     * @example
     * // Create many Managers
     * const manager = await prisma.manager.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCreateManyArgs>(args?: SelectSubset<T, ManagerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manager.
     * @param {ManagerDeleteArgs} args - Arguments to delete one Manager.
     * @example
     * // Delete one Manager
     * const Manager = await prisma.manager.delete({
     *   where: {
     *     // ... filter to delete one Manager
     *   }
     * })
     * 
     */
    delete<T extends ManagerDeleteArgs>(args: SelectSubset<T, ManagerDeleteArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Manager.
     * @param {ManagerUpdateArgs} args - Arguments to update one Manager.
     * @example
     * // Update one Manager
     * const manager = await prisma.manager.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerUpdateArgs>(args: SelectSubset<T, ManagerUpdateArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Managers.
     * @param {ManagerDeleteManyArgs} args - Arguments to filter Managers to delete.
     * @example
     * // Delete a few Managers
     * const { count } = await prisma.manager.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerDeleteManyArgs>(args?: SelectSubset<T, ManagerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Managers
     * const manager = await prisma.manager.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerUpdateManyArgs>(args: SelectSubset<T, ManagerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manager.
     * @param {ManagerUpsertArgs} args - Arguments to update or create a Manager.
     * @example
     * // Update or create a Manager
     * const manager = await prisma.manager.upsert({
     *   create: {
     *     // ... data to create a Manager
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manager we want to update
     *   }
     * })
     */
    upsert<T extends ManagerUpsertArgs>(args: SelectSubset<T, ManagerUpsertArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Managers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCountArgs} args - Arguments to filter Managers to count.
     * @example
     * // Count the number of Managers
     * const count = await prisma.manager.count({
     *   where: {
     *     // ... the filter for the Managers we want to count
     *   }
     * })
    **/
    count<T extends ManagerCountArgs>(
      args?: Subset<T, ManagerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerAggregateArgs>(args: Subset<T, ManagerAggregateArgs>): Prisma.PrismaPromise<GetManagerAggregateType<T>>

    /**
     * Group by Manager.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerGroupByArgs['orderBy'] }
        : { orderBy?: ManagerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Manager model
   */
  readonly fields: ManagerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manager.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SalesRepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesRepDefaultArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    checkins<T extends Manager$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Manager$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Manager model
   */ 
  interface ManagerFieldRefs {
    readonly id: FieldRef<"Manager", 'Int'>
    readonly userId: FieldRef<"Manager", 'Int'>
    readonly department: FieldRef<"Manager", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Manager findUnique
   */
  export type ManagerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findUniqueOrThrow
   */
  export type ManagerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager findFirst
   */
  export type ManagerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findFirstOrThrow
   */
  export type ManagerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Manager to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Managers.
     */
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager findMany
   */
  export type ManagerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter, which Managers to fetch.
     */
    where?: ManagerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Managers to fetch.
     */
    orderBy?: ManagerOrderByWithRelationInput | ManagerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Managers.
     */
    cursor?: ManagerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Managers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Managers.
     */
    skip?: number
    distinct?: ManagerScalarFieldEnum | ManagerScalarFieldEnum[]
  }

  /**
   * Manager create
   */
  export type ManagerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to create a Manager.
     */
    data: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
  }

  /**
   * Manager createMany
   */
  export type ManagerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Managers.
     */
    data: ManagerCreateManyInput | ManagerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Manager update
   */
  export type ManagerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The data needed to update a Manager.
     */
    data: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
    /**
     * Choose, which Manager to update.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager updateMany
   */
  export type ManagerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Managers.
     */
    data: XOR<ManagerUpdateManyMutationInput, ManagerUncheckedUpdateManyInput>
    /**
     * Filter which Managers to update
     */
    where?: ManagerWhereInput
  }

  /**
   * Manager upsert
   */
  export type ManagerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * The filter to search for the Manager to update in case it exists.
     */
    where: ManagerWhereUniqueInput
    /**
     * In case the Manager found by the `where` argument doesn't exist, create a new Manager with this data.
     */
    create: XOR<ManagerCreateInput, ManagerUncheckedCreateInput>
    /**
     * In case the Manager was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerUpdateInput, ManagerUncheckedUpdateInput>
  }

  /**
   * Manager delete
   */
  export type ManagerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
    /**
     * Filter which Manager to delete.
     */
    where: ManagerWhereUniqueInput
  }

  /**
   * Manager deleteMany
   */
  export type ManagerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Managers to delete
     */
    where?: ManagerWhereInput
  }

  /**
   * Manager.checkins
   */
  export type Manager$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    where?: ManagerCheckinWhereInput
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    cursor?: ManagerCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerCheckinScalarFieldEnum | ManagerCheckinScalarFieldEnum[]
  }

  /**
   * Manager without action
   */
  export type ManagerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Manager
     */
    select?: ManagerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerInclude<ExtArgs> | null
  }


  /**
   * Model Token
   */

  export type AggregateToken = {
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  export type TokenAvgAggregateOutputType = {
    id: number | null
    salesRepId: number | null
  }

  export type TokenSumAggregateOutputType = {
    id: number | null
    salesRepId: number | null
  }

  export type TokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    salesRepId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type TokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    salesRepId: number | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type TokenCountAggregateOutputType = {
    id: number
    token: number
    salesRepId: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type TokenAvgAggregateInputType = {
    id?: true
    salesRepId?: true
  }

  export type TokenSumAggregateInputType = {
    id?: true
    salesRepId?: true
  }

  export type TokenMinAggregateInputType = {
    id?: true
    token?: true
    salesRepId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type TokenMaxAggregateInputType = {
    id?: true
    token?: true
    salesRepId?: true
    createdAt?: true
    expiresAt?: true
  }

  export type TokenCountAggregateInputType = {
    id?: true
    token?: true
    salesRepId?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type TokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Token to aggregate.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tokens
    **/
    _count?: true | TokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenMaxAggregateInputType
  }

  export type GetTokenAggregateType<T extends TokenAggregateArgs> = {
        [P in keyof T & keyof AggregateToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateToken[P]>
      : GetScalarType<T[P], AggregateToken[P]>
  }




  export type TokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenWhereInput
    orderBy?: TokenOrderByWithAggregationInput | TokenOrderByWithAggregationInput[]
    by: TokenScalarFieldEnum[] | TokenScalarFieldEnum
    having?: TokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenCountAggregateInputType | true
    _avg?: TokenAvgAggregateInputType
    _sum?: TokenSumAggregateInputType
    _min?: TokenMinAggregateInputType
    _max?: TokenMaxAggregateInputType
  }

  export type TokenGroupByOutputType = {
    id: number
    token: string
    salesRepId: number
    createdAt: Date
    expiresAt: Date
    _count: TokenCountAggregateOutputType | null
    _avg: TokenAvgAggregateOutputType | null
    _sum: TokenSumAggregateOutputType | null
    _min: TokenMinAggregateOutputType | null
    _max: TokenMaxAggregateOutputType | null
  }

  type GetTokenGroupByPayload<T extends TokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenGroupByOutputType[P]>
            : GetScalarType<T[P], TokenGroupByOutputType[P]>
        }
      >
    >


  export type TokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    salesRepId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["token"]>


  export type TokenSelectScalar = {
    id?: boolean
    token?: boolean
    salesRepId?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type TokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
  }

  export type $TokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Token"
    objects: {
      user: Prisma.$SalesRepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      salesRepId: number
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["token"]>
    composites: {}
  }

  type TokenGetPayload<S extends boolean | null | undefined | TokenDefaultArgs> = $Result.GetResult<Prisma.$TokenPayload, S>

  type TokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenCountAggregateInputType | true
    }

  export interface TokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Token'], meta: { name: 'Token' } }
    /**
     * Find zero or one Token that matches the filter.
     * @param {TokenFindUniqueArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenFindUniqueArgs>(args: SelectSubset<T, TokenFindUniqueArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Token that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenFindUniqueOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenFindFirstArgs>(args?: SelectSubset<T, TokenFindFirstArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Token that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindFirstOrThrowArgs} args - Arguments to find a Token
     * @example
     * // Get one Token
     * const token = await prisma.token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tokens
     * const tokens = await prisma.token.findMany()
     * 
     * // Get first 10 Tokens
     * const tokens = await prisma.token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenWithIdOnly = await prisma.token.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenFindManyArgs>(args?: SelectSubset<T, TokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Token.
     * @param {TokenCreateArgs} args - Arguments to create a Token.
     * @example
     * // Create one Token
     * const Token = await prisma.token.create({
     *   data: {
     *     // ... data to create a Token
     *   }
     * })
     * 
     */
    create<T extends TokenCreateArgs>(args: SelectSubset<T, TokenCreateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Tokens.
     * @param {TokenCreateManyArgs} args - Arguments to create many Tokens.
     * @example
     * // Create many Tokens
     * const token = await prisma.token.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenCreateManyArgs>(args?: SelectSubset<T, TokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Token.
     * @param {TokenDeleteArgs} args - Arguments to delete one Token.
     * @example
     * // Delete one Token
     * const Token = await prisma.token.delete({
     *   where: {
     *     // ... filter to delete one Token
     *   }
     * })
     * 
     */
    delete<T extends TokenDeleteArgs>(args: SelectSubset<T, TokenDeleteArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Token.
     * @param {TokenUpdateArgs} args - Arguments to update one Token.
     * @example
     * // Update one Token
     * const token = await prisma.token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenUpdateArgs>(args: SelectSubset<T, TokenUpdateArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Tokens.
     * @param {TokenDeleteManyArgs} args - Arguments to filter Tokens to delete.
     * @example
     * // Delete a few Tokens
     * const { count } = await prisma.token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenDeleteManyArgs>(args?: SelectSubset<T, TokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tokens
     * const token = await prisma.token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenUpdateManyArgs>(args: SelectSubset<T, TokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Token.
     * @param {TokenUpsertArgs} args - Arguments to update or create a Token.
     * @example
     * // Update or create a Token
     * const token = await prisma.token.upsert({
     *   create: {
     *     // ... data to create a Token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Token we want to update
     *   }
     * })
     */
    upsert<T extends TokenUpsertArgs>(args: SelectSubset<T, TokenUpsertArgs<ExtArgs>>): Prisma__TokenClient<$Result.GetResult<Prisma.$TokenPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenCountArgs} args - Arguments to filter Tokens to count.
     * @example
     * // Count the number of Tokens
     * const count = await prisma.token.count({
     *   where: {
     *     // ... the filter for the Tokens we want to count
     *   }
     * })
    **/
    count<T extends TokenCountArgs>(
      args?: Subset<T, TokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenAggregateArgs>(args: Subset<T, TokenAggregateArgs>): Prisma.PrismaPromise<GetTokenAggregateType<T>>

    /**
     * Group by Token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenGroupByArgs['orderBy'] }
        : { orderBy?: TokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Token model
   */
  readonly fields: TokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SalesRepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesRepDefaultArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Token model
   */ 
  interface TokenFieldRefs {
    readonly id: FieldRef<"Token", 'Int'>
    readonly token: FieldRef<"Token", 'String'>
    readonly salesRepId: FieldRef<"Token", 'Int'>
    readonly createdAt: FieldRef<"Token", 'DateTime'>
    readonly expiresAt: FieldRef<"Token", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Token findUnique
   */
  export type TokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findUniqueOrThrow
   */
  export type TokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token findFirst
   */
  export type TokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findFirstOrThrow
   */
  export type TokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Token to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tokens.
     */
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token findMany
   */
  export type TokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter, which Tokens to fetch.
     */
    where?: TokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tokens to fetch.
     */
    orderBy?: TokenOrderByWithRelationInput | TokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tokens.
     */
    cursor?: TokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tokens.
     */
    skip?: number
    distinct?: TokenScalarFieldEnum | TokenScalarFieldEnum[]
  }

  /**
   * Token create
   */
  export type TokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to create a Token.
     */
    data: XOR<TokenCreateInput, TokenUncheckedCreateInput>
  }

  /**
   * Token createMany
   */
  export type TokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tokens.
     */
    data: TokenCreateManyInput | TokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Token update
   */
  export type TokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The data needed to update a Token.
     */
    data: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
    /**
     * Choose, which Token to update.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token updateMany
   */
  export type TokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tokens.
     */
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyInput>
    /**
     * Filter which Tokens to update
     */
    where?: TokenWhereInput
  }

  /**
   * Token upsert
   */
  export type TokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * The filter to search for the Token to update in case it exists.
     */
    where: TokenWhereUniqueInput
    /**
     * In case the Token found by the `where` argument doesn't exist, create a new Token with this data.
     */
    create: XOR<TokenCreateInput, TokenUncheckedCreateInput>
    /**
     * In case the Token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenUpdateInput, TokenUncheckedUpdateInput>
  }

  /**
   * Token delete
   */
  export type TokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
    /**
     * Filter which Token to delete.
     */
    where: TokenWhereUniqueInput
  }

  /**
   * Token deleteMany
   */
  export type TokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tokens to delete
     */
    where?: TokenWhereInput
  }

  /**
   * Token without action
   */
  export type TokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Token
     */
    select?: TokenSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenInclude<ExtArgs> | null
  }


  /**
   * Model Regions
   */

  export type AggregateRegions = {
    _count: RegionsCountAggregateOutputType | null
    _avg: RegionsAvgAggregateOutputType | null
    _sum: RegionsSumAggregateOutputType | null
    _min: RegionsMinAggregateOutputType | null
    _max: RegionsMaxAggregateOutputType | null
  }

  export type RegionsAvgAggregateOutputType = {
    id: number | null
    countryId: number | null
    status: number | null
  }

  export type RegionsSumAggregateOutputType = {
    id: number | null
    countryId: number | null
    status: number | null
  }

  export type RegionsMinAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    status: number | null
  }

  export type RegionsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    countryId: number | null
    status: number | null
  }

  export type RegionsCountAggregateOutputType = {
    id: number
    name: number
    countryId: number
    status: number
    _all: number
  }


  export type RegionsAvgAggregateInputType = {
    id?: true
    countryId?: true
    status?: true
  }

  export type RegionsSumAggregateInputType = {
    id?: true
    countryId?: true
    status?: true
  }

  export type RegionsMinAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    status?: true
  }

  export type RegionsMaxAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    status?: true
  }

  export type RegionsCountAggregateInputType = {
    id?: true
    name?: true
    countryId?: true
    status?: true
    _all?: true
  }

  export type RegionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to aggregate.
     */
    where?: RegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionsOrderByWithRelationInput | RegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Regions
    **/
    _count?: true | RegionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RegionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RegionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegionsMaxAggregateInputType
  }

  export type GetRegionsAggregateType<T extends RegionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRegions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegions[P]>
      : GetScalarType<T[P], AggregateRegions[P]>
  }




  export type RegionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegionsWhereInput
    orderBy?: RegionsOrderByWithAggregationInput | RegionsOrderByWithAggregationInput[]
    by: RegionsScalarFieldEnum[] | RegionsScalarFieldEnum
    having?: RegionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegionsCountAggregateInputType | true
    _avg?: RegionsAvgAggregateInputType
    _sum?: RegionsSumAggregateInputType
    _min?: RegionsMinAggregateInputType
    _max?: RegionsMaxAggregateInputType
  }

  export type RegionsGroupByOutputType = {
    id: number
    name: string
    countryId: number
    status: number | null
    _count: RegionsCountAggregateOutputType | null
    _avg: RegionsAvgAggregateOutputType | null
    _sum: RegionsSumAggregateOutputType | null
    _min: RegionsMinAggregateOutputType | null
    _max: RegionsMaxAggregateOutputType | null
  }

  type GetRegionsGroupByPayload<T extends RegionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegionsGroupByOutputType[P]>
            : GetScalarType<T[P], RegionsGroupByOutputType[P]>
        }
      >
    >


  export type RegionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    countryId?: boolean
    status?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["regions"]>


  export type RegionsSelectScalar = {
    id?: boolean
    name?: boolean
    countryId?: boolean
    status?: boolean
  }

  export type RegionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
  }

  export type $RegionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Regions"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      countryId: number
      status: number | null
    }, ExtArgs["result"]["regions"]>
    composites: {}
  }

  type RegionsGetPayload<S extends boolean | null | undefined | RegionsDefaultArgs> = $Result.GetResult<Prisma.$RegionsPayload, S>

  type RegionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegionsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegionsCountAggregateInputType | true
    }

  export interface RegionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Regions'], meta: { name: 'Regions' } }
    /**
     * Find zero or one Regions that matches the filter.
     * @param {RegionsFindUniqueArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegionsFindUniqueArgs>(args: SelectSubset<T, RegionsFindUniqueArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Regions that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegionsFindUniqueOrThrowArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegionsFindUniqueOrThrowArgs>(args: SelectSubset<T, RegionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsFindFirstArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegionsFindFirstArgs>(args?: SelectSubset<T, RegionsFindFirstArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Regions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsFindFirstOrThrowArgs} args - Arguments to find a Regions
     * @example
     * // Get one Regions
     * const regions = await prisma.regions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegionsFindFirstOrThrowArgs>(args?: SelectSubset<T, RegionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Regions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Regions
     * const regions = await prisma.regions.findMany()
     * 
     * // Get first 10 Regions
     * const regions = await prisma.regions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const regionsWithIdOnly = await prisma.regions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegionsFindManyArgs>(args?: SelectSubset<T, RegionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Regions.
     * @param {RegionsCreateArgs} args - Arguments to create a Regions.
     * @example
     * // Create one Regions
     * const Regions = await prisma.regions.create({
     *   data: {
     *     // ... data to create a Regions
     *   }
     * })
     * 
     */
    create<T extends RegionsCreateArgs>(args: SelectSubset<T, RegionsCreateArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Regions.
     * @param {RegionsCreateManyArgs} args - Arguments to create many Regions.
     * @example
     * // Create many Regions
     * const regions = await prisma.regions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegionsCreateManyArgs>(args?: SelectSubset<T, RegionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Regions.
     * @param {RegionsDeleteArgs} args - Arguments to delete one Regions.
     * @example
     * // Delete one Regions
     * const Regions = await prisma.regions.delete({
     *   where: {
     *     // ... filter to delete one Regions
     *   }
     * })
     * 
     */
    delete<T extends RegionsDeleteArgs>(args: SelectSubset<T, RegionsDeleteArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Regions.
     * @param {RegionsUpdateArgs} args - Arguments to update one Regions.
     * @example
     * // Update one Regions
     * const regions = await prisma.regions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegionsUpdateArgs>(args: SelectSubset<T, RegionsUpdateArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Regions.
     * @param {RegionsDeleteManyArgs} args - Arguments to filter Regions to delete.
     * @example
     * // Delete a few Regions
     * const { count } = await prisma.regions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegionsDeleteManyArgs>(args?: SelectSubset<T, RegionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Regions
     * const regions = await prisma.regions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegionsUpdateManyArgs>(args: SelectSubset<T, RegionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Regions.
     * @param {RegionsUpsertArgs} args - Arguments to update or create a Regions.
     * @example
     * // Update or create a Regions
     * const regions = await prisma.regions.upsert({
     *   create: {
     *     // ... data to create a Regions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Regions we want to update
     *   }
     * })
     */
    upsert<T extends RegionsUpsertArgs>(args: SelectSubset<T, RegionsUpsertArgs<ExtArgs>>): Prisma__RegionsClient<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsCountArgs} args - Arguments to filter Regions to count.
     * @example
     * // Count the number of Regions
     * const count = await prisma.regions.count({
     *   where: {
     *     // ... the filter for the Regions we want to count
     *   }
     * })
    **/
    count<T extends RegionsCountArgs>(
      args?: Subset<T, RegionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegionsAggregateArgs>(args: Subset<T, RegionsAggregateArgs>): Prisma.PrismaPromise<GetRegionsAggregateType<T>>

    /**
     * Group by Regions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegionsGroupByArgs['orderBy'] }
        : { orderBy?: RegionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Regions model
   */
  readonly fields: RegionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Regions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Regions model
   */ 
  interface RegionsFieldRefs {
    readonly id: FieldRef<"Regions", 'Int'>
    readonly name: FieldRef<"Regions", 'String'>
    readonly countryId: FieldRef<"Regions", 'Int'>
    readonly status: FieldRef<"Regions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Regions findUnique
   */
  export type RegionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where: RegionsWhereUniqueInput
  }

  /**
   * Regions findUniqueOrThrow
   */
  export type RegionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where: RegionsWhereUniqueInput
  }

  /**
   * Regions findFirst
   */
  export type RegionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionsOrderByWithRelationInput | RegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionsScalarFieldEnum | RegionsScalarFieldEnum[]
  }

  /**
   * Regions findFirstOrThrow
   */
  export type RegionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionsOrderByWithRelationInput | RegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Regions.
     */
    cursor?: RegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Regions.
     */
    distinct?: RegionsScalarFieldEnum | RegionsScalarFieldEnum[]
  }

  /**
   * Regions findMany
   */
  export type RegionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter, which Regions to fetch.
     */
    where?: RegionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Regions to fetch.
     */
    orderBy?: RegionsOrderByWithRelationInput | RegionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Regions.
     */
    cursor?: RegionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Regions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Regions.
     */
    skip?: number
    distinct?: RegionsScalarFieldEnum | RegionsScalarFieldEnum[]
  }

  /**
   * Regions create
   */
  export type RegionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * The data needed to create a Regions.
     */
    data: XOR<RegionsCreateInput, RegionsUncheckedCreateInput>
  }

  /**
   * Regions createMany
   */
  export type RegionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Regions.
     */
    data: RegionsCreateManyInput | RegionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Regions update
   */
  export type RegionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * The data needed to update a Regions.
     */
    data: XOR<RegionsUpdateInput, RegionsUncheckedUpdateInput>
    /**
     * Choose, which Regions to update.
     */
    where: RegionsWhereUniqueInput
  }

  /**
   * Regions updateMany
   */
  export type RegionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Regions.
     */
    data: XOR<RegionsUpdateManyMutationInput, RegionsUncheckedUpdateManyInput>
    /**
     * Filter which Regions to update
     */
    where?: RegionsWhereInput
  }

  /**
   * Regions upsert
   */
  export type RegionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * The filter to search for the Regions to update in case it exists.
     */
    where: RegionsWhereUniqueInput
    /**
     * In case the Regions found by the `where` argument doesn't exist, create a new Regions with this data.
     */
    create: XOR<RegionsCreateInput, RegionsUncheckedCreateInput>
    /**
     * In case the Regions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegionsUpdateInput, RegionsUncheckedUpdateInput>
  }

  /**
   * Regions delete
   */
  export type RegionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    /**
     * Filter which Regions to delete.
     */
    where: RegionsWhereUniqueInput
  }

  /**
   * Regions deleteMany
   */
  export type RegionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Regions to delete
     */
    where?: RegionsWhereInput
  }

  /**
   * Regions without action
   */
  export type RegionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
  }


  /**
   * Model Country
   */

  export type AggregateCountry = {
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  export type CountryAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type CountrySumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type CountryMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
  }

  export type CountryMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
  }

  export type CountryCountAggregateOutputType = {
    id: number
    name: number
    status: number
    _all: number
  }


  export type CountryAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type CountrySumAggregateInputType = {
    id?: true
    status?: true
  }

  export type CountryMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
  }

  export type CountryMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
  }

  export type CountryCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    _all?: true
  }

  export type CountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Country to aggregate.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryMaxAggregateInputType
  }

  export type GetCountryAggregateType<T extends CountryAggregateArgs> = {
        [P in keyof T & keyof AggregateCountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountry[P]>
      : GetScalarType<T[P], AggregateCountry[P]>
  }




  export type CountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryWhereInput
    orderBy?: CountryOrderByWithAggregationInput | CountryOrderByWithAggregationInput[]
    by: CountryScalarFieldEnum[] | CountryScalarFieldEnum
    having?: CountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCountAggregateInputType | true
    _avg?: CountryAvgAggregateInputType
    _sum?: CountrySumAggregateInputType
    _min?: CountryMinAggregateInputType
    _max?: CountryMaxAggregateInputType
  }

  export type CountryGroupByOutputType = {
    id: number
    name: string
    status: number | null
    _count: CountryCountAggregateOutputType | null
    _avg: CountryAvgAggregateOutputType | null
    _sum: CountrySumAggregateOutputType | null
    _min: CountryMinAggregateOutputType | null
    _max: CountryMaxAggregateOutputType | null
  }

  type GetCountryGroupByPayload<T extends CountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryGroupByOutputType[P]>
            : GetScalarType<T[P], CountryGroupByOutputType[P]>
        }
      >
    >


  export type CountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
    regions?: boolean | Country$regionsArgs<ExtArgs>
    clients?: boolean | Country$clientsArgs<ExtArgs>
    salesRep?: boolean | Country$salesRepArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["country"]>


  export type CountrySelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
  }

  export type CountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    regions?: boolean | Country$regionsArgs<ExtArgs>
    clients?: boolean | Country$clientsArgs<ExtArgs>
    salesRep?: boolean | Country$salesRepArgs<ExtArgs>
    _count?: boolean | CountryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Country"
    objects: {
      regions: Prisma.$RegionsPayload<ExtArgs>[]
      clients: Prisma.$ClientsPayload<ExtArgs>[]
      salesRep: Prisma.$SalesRepPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      status: number | null
    }, ExtArgs["result"]["country"]>
    composites: {}
  }

  type CountryGetPayload<S extends boolean | null | undefined | CountryDefaultArgs> = $Result.GetResult<Prisma.$CountryPayload, S>

  type CountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountryCountAggregateInputType | true
    }

  export interface CountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Country'], meta: { name: 'Country' } }
    /**
     * Find zero or one Country that matches the filter.
     * @param {CountryFindUniqueArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryFindUniqueArgs>(args: SelectSubset<T, CountryFindUniqueArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Country that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountryFindUniqueOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Country that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryFindFirstArgs>(args?: SelectSubset<T, CountryFindFirstArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Country that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindFirstOrThrowArgs} args - Arguments to find a Country
     * @example
     * // Get one Country
     * const country = await prisma.country.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.country.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.country.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryWithIdOnly = await prisma.country.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryFindManyArgs>(args?: SelectSubset<T, CountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Country.
     * @param {CountryCreateArgs} args - Arguments to create a Country.
     * @example
     * // Create one Country
     * const Country = await prisma.country.create({
     *   data: {
     *     // ... data to create a Country
     *   }
     * })
     * 
     */
    create<T extends CountryCreateArgs>(args: SelectSubset<T, CountryCreateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountryCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const country = await prisma.country.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCreateManyArgs>(args?: SelectSubset<T, CountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Country.
     * @param {CountryDeleteArgs} args - Arguments to delete one Country.
     * @example
     * // Delete one Country
     * const Country = await prisma.country.delete({
     *   where: {
     *     // ... filter to delete one Country
     *   }
     * })
     * 
     */
    delete<T extends CountryDeleteArgs>(args: SelectSubset<T, CountryDeleteArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Country.
     * @param {CountryUpdateArgs} args - Arguments to update one Country.
     * @example
     * // Update one Country
     * const country = await prisma.country.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryUpdateArgs>(args: SelectSubset<T, CountryUpdateArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountryDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.country.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryDeleteManyArgs>(args?: SelectSubset<T, CountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const country = await prisma.country.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryUpdateManyArgs>(args: SelectSubset<T, CountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Country.
     * @param {CountryUpsertArgs} args - Arguments to update or create a Country.
     * @example
     * // Update or create a Country
     * const country = await prisma.country.upsert({
     *   create: {
     *     // ... data to create a Country
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Country we want to update
     *   }
     * })
     */
    upsert<T extends CountryUpsertArgs>(args: SelectSubset<T, CountryUpsertArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.country.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountryCountArgs>(
      args?: Subset<T, CountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryAggregateArgs>(args: Subset<T, CountryAggregateArgs>): Prisma.PrismaPromise<GetCountryAggregateType<T>>

    /**
     * Group by Country.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryGroupByArgs['orderBy'] }
        : { orderBy?: CountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Country model
   */
  readonly fields: CountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Country.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    regions<T extends Country$regionsArgs<ExtArgs> = {}>(args?: Subset<T, Country$regionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegionsPayload<ExtArgs>, T, "findMany"> | Null>
    clients<T extends Country$clientsArgs<ExtArgs> = {}>(args?: Subset<T, Country$clientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany"> | Null>
    salesRep<T extends Country$salesRepArgs<ExtArgs> = {}>(args?: Subset<T, Country$salesRepArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Country model
   */ 
  interface CountryFieldRefs {
    readonly id: FieldRef<"Country", 'Int'>
    readonly name: FieldRef<"Country", 'String'>
    readonly status: FieldRef<"Country", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Country findUnique
   */
  export type CountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findUniqueOrThrow
   */
  export type CountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country findFirst
   */
  export type CountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findFirstOrThrow
   */
  export type CountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Country to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country findMany
   */
  export type CountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountryOrderByWithRelationInput | CountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountryScalarFieldEnum | CountryScalarFieldEnum[]
  }

  /**
   * Country create
   */
  export type CountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to create a Country.
     */
    data: XOR<CountryCreateInput, CountryUncheckedCreateInput>
  }

  /**
   * Country createMany
   */
  export type CountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountryCreateManyInput | CountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Country update
   */
  export type CountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The data needed to update a Country.
     */
    data: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
    /**
     * Choose, which Country to update.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country updateMany
   */
  export type CountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountryUpdateManyMutationInput, CountryUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountryWhereInput
  }

  /**
   * Country upsert
   */
  export type CountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * The filter to search for the Country to update in case it exists.
     */
    where: CountryWhereUniqueInput
    /**
     * In case the Country found by the `where` argument doesn't exist, create a new Country with this data.
     */
    create: XOR<CountryCreateInput, CountryUncheckedCreateInput>
    /**
     * In case the Country was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryUpdateInput, CountryUncheckedUpdateInput>
  }

  /**
   * Country delete
   */
  export type CountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
    /**
     * Filter which Country to delete.
     */
    where: CountryWhereUniqueInput
  }

  /**
   * Country deleteMany
   */
  export type CountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountryWhereInput
  }

  /**
   * Country.regions
   */
  export type Country$regionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Regions
     */
    select?: RegionsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegionsInclude<ExtArgs> | null
    where?: RegionsWhereInput
    orderBy?: RegionsOrderByWithRelationInput | RegionsOrderByWithRelationInput[]
    cursor?: RegionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegionsScalarFieldEnum | RegionsScalarFieldEnum[]
  }

  /**
   * Country.clients
   */
  export type Country$clientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    where?: ClientsWhereInput
    orderBy?: ClientsOrderByWithRelationInput | ClientsOrderByWithRelationInput[]
    cursor?: ClientsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * Country.salesRep
   */
  export type Country$salesRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    where?: SalesRepWhereInput
    orderBy?: SalesRepOrderByWithRelationInput | SalesRepOrderByWithRelationInput[]
    cursor?: SalesRepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalesRepScalarFieldEnum | SalesRepScalarFieldEnum[]
  }

  /**
   * Country without action
   */
  export type CountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Country
     */
    select?: CountrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountryInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    category_id: number | null
    currentStock: number | null
    clientId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    category_id: number | null
    currentStock: number | null
    clientId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    category: string | null
    description: string | null
    currentStock: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    image: string | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    category_id: number | null
    category: string | null
    description: string | null
    currentStock: number | null
    createdAt: Date | null
    updatedAt: Date | null
    clientId: number | null
    image: string | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    category_id: number
    category: number
    description: number
    currentStock: number
    createdAt: number
    updatedAt: number
    clientId: number
    image: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    category_id?: true
    currentStock?: true
    clientId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    category_id?: true
    currentStock?: true
    clientId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    category?: true
    description?: true
    currentStock?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    image?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    category?: true
    description?: true
    currentStock?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    image?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    category?: true
    description?: true
    currentStock?: true
    createdAt?: true
    updatedAt?: true
    clientId?: true
    image?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: number
    name: string
    category_id: number
    category: string
    description: string | null
    currentStock: number | null
    createdAt: Date
    updatedAt: Date
    clientId: number | null
    image: string | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    category?: boolean
    description?: boolean
    currentStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    image?: boolean
    client?: boolean | Product$clientArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    storeQuantities?: boolean | Product$storeQuantitiesArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    purchaseHistory?: boolean | Product$purchaseHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>


  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    category_id?: boolean
    category?: boolean
    description?: boolean
    currentStock?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientId?: boolean
    image?: boolean
  }

  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | Product$clientArgs<ExtArgs>
    orderItems?: boolean | Product$orderItemsArgs<ExtArgs>
    storeQuantities?: boolean | Product$storeQuantitiesArgs<ExtArgs>
    purchase?: boolean | Product$purchaseArgs<ExtArgs>
    purchaseHistory?: boolean | Product$purchaseHistoryArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs> | null
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      storeQuantities: Prisma.$StoreQuantityPayload<ExtArgs>[]
      purchase: Prisma.$PurchasePayload<ExtArgs>[]
      purchaseHistory: Prisma.$PurchaseHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      category_id: number
      category: string
      description: string | null
      currentStock: number | null
      createdAt: Date
      updatedAt: Date
      clientId: number | null
      image: string | null
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends Product$clientArgs<ExtArgs> = {}>(args?: Subset<T, Product$clientArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    orderItems<T extends Product$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Product$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    storeQuantities<T extends Product$storeQuantitiesArgs<ExtArgs> = {}>(args?: Subset<T, Product$storeQuantitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findMany"> | Null>
    purchase<T extends Product$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    purchaseHistory<T extends Product$purchaseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Product$purchaseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */ 
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'Int'>
    readonly name: FieldRef<"Product", 'String'>
    readonly category_id: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly currentStock: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
    readonly clientId: FieldRef<"Product", 'Int'>
    readonly image: FieldRef<"Product", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
  }

  /**
   * Product.client
   */
  export type Product$clientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    where?: ClientsWhereInput
  }

  /**
   * Product.orderItems
   */
  export type Product$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * Product.storeQuantities
   */
  export type Product$storeQuantitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    where?: StoreQuantityWhereInput
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    cursor?: StoreQuantityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreQuantityScalarFieldEnum | StoreQuantityScalarFieldEnum[]
  }

  /**
   * Product.purchase
   */
  export type Product$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Product.purchaseHistory
   */
  export type Product$purchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    cursor?: PurchaseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Category
   */

  export type AggregateCategory = {
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  export type CategoryAvgAggregateOutputType = {
    id: number | null
  }

  export type CategorySumAggregateOutputType = {
    id: number | null
  }

  export type CategoryMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type CategoryCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type CategoryAvgAggregateInputType = {
    id?: true
  }

  export type CategorySumAggregateInputType = {
    id?: true
  }

  export type CategoryMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type CategoryCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type CategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Category to aggregate.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Categories
    **/
    _count?: true | CategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoryMaxAggregateInputType
  }

  export type GetCategoryAggregateType<T extends CategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategory[P]>
      : GetScalarType<T[P], AggregateCategory[P]>
  }




  export type CategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CategoryWhereInput
    orderBy?: CategoryOrderByWithAggregationInput | CategoryOrderByWithAggregationInput[]
    by: CategoryScalarFieldEnum[] | CategoryScalarFieldEnum
    having?: CategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoryCountAggregateInputType | true
    _avg?: CategoryAvgAggregateInputType
    _sum?: CategorySumAggregateInputType
    _min?: CategoryMinAggregateInputType
    _max?: CategoryMaxAggregateInputType
  }

  export type CategoryGroupByOutputType = {
    id: number
    name: string
    _count: CategoryCountAggregateOutputType | null
    _avg: CategoryAvgAggregateOutputType | null
    _sum: CategorySumAggregateOutputType | null
    _min: CategoryMinAggregateOutputType | null
    _max: CategoryMaxAggregateOutputType | null
  }

  type GetCategoryGroupByPayload<T extends CategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoryGroupByOutputType[P]>
            : GetScalarType<T[P], CategoryGroupByOutputType[P]>
        }
      >
    >


  export type CategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    priceOptions?: boolean | Category$priceOptionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["category"]>


  export type CategorySelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type CategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceOptions?: boolean | Category$priceOptionsArgs<ExtArgs>
    _count?: boolean | CategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Category"
    objects: {
      priceOptions: Prisma.$PriceOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["category"]>
    composites: {}
  }

  type CategoryGetPayload<S extends boolean | null | undefined | CategoryDefaultArgs> = $Result.GetResult<Prisma.$CategoryPayload, S>

  type CategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CategoryCountAggregateInputType | true
    }

  export interface CategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Category'], meta: { name: 'Category' } }
    /**
     * Find zero or one Category that matches the filter.
     * @param {CategoryFindUniqueArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CategoryFindUniqueArgs>(args: SelectSubset<T, CategoryFindUniqueArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Category that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CategoryFindUniqueOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CategoryFindFirstArgs>(args?: SelectSubset<T, CategoryFindFirstArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindFirstOrThrowArgs} args - Arguments to find a Category
     * @example
     * // Get one Category
     * const category = await prisma.category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.category.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoryWithIdOnly = await prisma.category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CategoryFindManyArgs>(args?: SelectSubset<T, CategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Category.
     * @param {CategoryCreateArgs} args - Arguments to create a Category.
     * @example
     * // Create one Category
     * const Category = await prisma.category.create({
     *   data: {
     *     // ... data to create a Category
     *   }
     * })
     * 
     */
    create<T extends CategoryCreateArgs>(args: SelectSubset<T, CategoryCreateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Categories.
     * @param {CategoryCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const category = await prisma.category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CategoryCreateManyArgs>(args?: SelectSubset<T, CategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Category.
     * @param {CategoryDeleteArgs} args - Arguments to delete one Category.
     * @example
     * // Delete one Category
     * const Category = await prisma.category.delete({
     *   where: {
     *     // ... filter to delete one Category
     *   }
     * })
     * 
     */
    delete<T extends CategoryDeleteArgs>(args: SelectSubset<T, CategoryDeleteArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Category.
     * @param {CategoryUpdateArgs} args - Arguments to update one Category.
     * @example
     * // Update one Category
     * const category = await prisma.category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CategoryUpdateArgs>(args: SelectSubset<T, CategoryUpdateArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Categories.
     * @param {CategoryDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CategoryDeleteManyArgs>(args?: SelectSubset<T, CategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const category = await prisma.category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CategoryUpdateManyArgs>(args: SelectSubset<T, CategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Category.
     * @param {CategoryUpsertArgs} args - Arguments to update or create a Category.
     * @example
     * // Update or create a Category
     * const category = await prisma.category.upsert({
     *   create: {
     *     // ... data to create a Category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Category we want to update
     *   }
     * })
     */
    upsert<T extends CategoryUpsertArgs>(args: SelectSubset<T, CategoryUpsertArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.category.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends CategoryCountArgs>(
      args?: Subset<T, CategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoryAggregateArgs>(args: Subset<T, CategoryAggregateArgs>): Prisma.PrismaPromise<GetCategoryAggregateType<T>>

    /**
     * Group by Category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CategoryGroupByArgs['orderBy'] }
        : { orderBy?: CategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Category model
   */
  readonly fields: CategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceOptions<T extends Category$priceOptionsArgs<ExtArgs> = {}>(args?: Subset<T, Category$priceOptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Category model
   */ 
  interface CategoryFieldRefs {
    readonly id: FieldRef<"Category", 'Int'>
    readonly name: FieldRef<"Category", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Category findUnique
   */
  export type CategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findUniqueOrThrow
   */
  export type CategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category findFirst
   */
  export type CategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findFirstOrThrow
   */
  export type CategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Category to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Categories.
     */
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category findMany
   */
  export type CategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter, which Categories to fetch.
     */
    where?: CategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Categories to fetch.
     */
    orderBy?: CategoryOrderByWithRelationInput | CategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Categories.
     */
    cursor?: CategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Categories.
     */
    skip?: number
    distinct?: CategoryScalarFieldEnum | CategoryScalarFieldEnum[]
  }

  /**
   * Category create
   */
  export type CategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a Category.
     */
    data: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
  }

  /**
   * Category createMany
   */
  export type CategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Categories.
     */
    data: CategoryCreateManyInput | CategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Category update
   */
  export type CategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a Category.
     */
    data: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
    /**
     * Choose, which Category to update.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category updateMany
   */
  export type CategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Categories.
     */
    data: XOR<CategoryUpdateManyMutationInput, CategoryUncheckedUpdateManyInput>
    /**
     * Filter which Categories to update
     */
    where?: CategoryWhereInput
  }

  /**
   * Category upsert
   */
  export type CategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the Category to update in case it exists.
     */
    where: CategoryWhereUniqueInput
    /**
     * In case the Category found by the `where` argument doesn't exist, create a new Category with this data.
     */
    create: XOR<CategoryCreateInput, CategoryUncheckedCreateInput>
    /**
     * In case the Category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CategoryUpdateInput, CategoryUncheckedUpdateInput>
  }

  /**
   * Category delete
   */
  export type CategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
    /**
     * Filter which Category to delete.
     */
    where: CategoryWhereUniqueInput
  }

  /**
   * Category deleteMany
   */
  export type CategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Categories to delete
     */
    where?: CategoryWhereInput
  }

  /**
   * Category.priceOptions
   */
  export type Category$priceOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    where?: PriceOptionWhereInput
    orderBy?: PriceOptionOrderByWithRelationInput | PriceOptionOrderByWithRelationInput[]
    cursor?: PriceOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PriceOptionScalarFieldEnum | PriceOptionScalarFieldEnum[]
  }

  /**
   * Category without action
   */
  export type CategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Category
     */
    select?: CategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CategoryInclude<ExtArgs> | null
  }


  /**
   * Model PriceOption
   */

  export type AggregatePriceOption = {
    _count: PriceOptionCountAggregateOutputType | null
    _avg: PriceOptionAvgAggregateOutputType | null
    _sum: PriceOptionSumAggregateOutputType | null
    _min: PriceOptionMinAggregateOutputType | null
    _max: PriceOptionMaxAggregateOutputType | null
  }

  export type PriceOptionAvgAggregateOutputType = {
    id: number | null
    value: number | null
    categoryId: number | null
  }

  export type PriceOptionSumAggregateOutputType = {
    id: number | null
    value: number | null
    categoryId: number | null
  }

  export type PriceOptionMinAggregateOutputType = {
    id: number | null
    option: string | null
    value: number | null
    categoryId: number | null
  }

  export type PriceOptionMaxAggregateOutputType = {
    id: number | null
    option: string | null
    value: number | null
    categoryId: number | null
  }

  export type PriceOptionCountAggregateOutputType = {
    id: number
    option: number
    value: number
    categoryId: number
    _all: number
  }


  export type PriceOptionAvgAggregateInputType = {
    id?: true
    value?: true
    categoryId?: true
  }

  export type PriceOptionSumAggregateInputType = {
    id?: true
    value?: true
    categoryId?: true
  }

  export type PriceOptionMinAggregateInputType = {
    id?: true
    option?: true
    value?: true
    categoryId?: true
  }

  export type PriceOptionMaxAggregateInputType = {
    id?: true
    option?: true
    value?: true
    categoryId?: true
  }

  export type PriceOptionCountAggregateInputType = {
    id?: true
    option?: true
    value?: true
    categoryId?: true
    _all?: true
  }

  export type PriceOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceOption to aggregate.
     */
    where?: PriceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceOptions to fetch.
     */
    orderBy?: PriceOptionOrderByWithRelationInput | PriceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PriceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PriceOptions
    **/
    _count?: true | PriceOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PriceOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PriceOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PriceOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PriceOptionMaxAggregateInputType
  }

  export type GetPriceOptionAggregateType<T extends PriceOptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePriceOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePriceOption[P]>
      : GetScalarType<T[P], AggregatePriceOption[P]>
  }




  export type PriceOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PriceOptionWhereInput
    orderBy?: PriceOptionOrderByWithAggregationInput | PriceOptionOrderByWithAggregationInput[]
    by: PriceOptionScalarFieldEnum[] | PriceOptionScalarFieldEnum
    having?: PriceOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PriceOptionCountAggregateInputType | true
    _avg?: PriceOptionAvgAggregateInputType
    _sum?: PriceOptionSumAggregateInputType
    _min?: PriceOptionMinAggregateInputType
    _max?: PriceOptionMaxAggregateInputType
  }

  export type PriceOptionGroupByOutputType = {
    id: number
    option: string
    value: number
    categoryId: number
    _count: PriceOptionCountAggregateOutputType | null
    _avg: PriceOptionAvgAggregateOutputType | null
    _sum: PriceOptionSumAggregateOutputType | null
    _min: PriceOptionMinAggregateOutputType | null
    _max: PriceOptionMaxAggregateOutputType | null
  }

  type GetPriceOptionGroupByPayload<T extends PriceOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PriceOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PriceOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PriceOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PriceOptionGroupByOutputType[P]>
        }
      >
    >


  export type PriceOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    option?: boolean
    value?: boolean
    categoryId?: boolean
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | PriceOption$orderItemsArgs<ExtArgs>
    _count?: boolean | PriceOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["priceOption"]>


  export type PriceOptionSelectScalar = {
    id?: boolean
    option?: boolean
    value?: boolean
    categoryId?: boolean
  }

  export type PriceOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | CategoryDefaultArgs<ExtArgs>
    orderItems?: boolean | PriceOption$orderItemsArgs<ExtArgs>
    _count?: boolean | PriceOptionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PriceOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PriceOption"
    objects: {
      category: Prisma.$CategoryPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      option: string
      value: number
      categoryId: number
    }, ExtArgs["result"]["priceOption"]>
    composites: {}
  }

  type PriceOptionGetPayload<S extends boolean | null | undefined | PriceOptionDefaultArgs> = $Result.GetResult<Prisma.$PriceOptionPayload, S>

  type PriceOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PriceOptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PriceOptionCountAggregateInputType | true
    }

  export interface PriceOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PriceOption'], meta: { name: 'PriceOption' } }
    /**
     * Find zero or one PriceOption that matches the filter.
     * @param {PriceOptionFindUniqueArgs} args - Arguments to find a PriceOption
     * @example
     * // Get one PriceOption
     * const priceOption = await prisma.priceOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PriceOptionFindUniqueArgs>(args: SelectSubset<T, PriceOptionFindUniqueArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PriceOption that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PriceOptionFindUniqueOrThrowArgs} args - Arguments to find a PriceOption
     * @example
     * // Get one PriceOption
     * const priceOption = await prisma.priceOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PriceOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PriceOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PriceOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionFindFirstArgs} args - Arguments to find a PriceOption
     * @example
     * // Get one PriceOption
     * const priceOption = await prisma.priceOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PriceOptionFindFirstArgs>(args?: SelectSubset<T, PriceOptionFindFirstArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PriceOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionFindFirstOrThrowArgs} args - Arguments to find a PriceOption
     * @example
     * // Get one PriceOption
     * const priceOption = await prisma.priceOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PriceOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PriceOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PriceOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PriceOptions
     * const priceOptions = await prisma.priceOption.findMany()
     * 
     * // Get first 10 PriceOptions
     * const priceOptions = await prisma.priceOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const priceOptionWithIdOnly = await prisma.priceOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PriceOptionFindManyArgs>(args?: SelectSubset<T, PriceOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PriceOption.
     * @param {PriceOptionCreateArgs} args - Arguments to create a PriceOption.
     * @example
     * // Create one PriceOption
     * const PriceOption = await prisma.priceOption.create({
     *   data: {
     *     // ... data to create a PriceOption
     *   }
     * })
     * 
     */
    create<T extends PriceOptionCreateArgs>(args: SelectSubset<T, PriceOptionCreateArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PriceOptions.
     * @param {PriceOptionCreateManyArgs} args - Arguments to create many PriceOptions.
     * @example
     * // Create many PriceOptions
     * const priceOption = await prisma.priceOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PriceOptionCreateManyArgs>(args?: SelectSubset<T, PriceOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PriceOption.
     * @param {PriceOptionDeleteArgs} args - Arguments to delete one PriceOption.
     * @example
     * // Delete one PriceOption
     * const PriceOption = await prisma.priceOption.delete({
     *   where: {
     *     // ... filter to delete one PriceOption
     *   }
     * })
     * 
     */
    delete<T extends PriceOptionDeleteArgs>(args: SelectSubset<T, PriceOptionDeleteArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PriceOption.
     * @param {PriceOptionUpdateArgs} args - Arguments to update one PriceOption.
     * @example
     * // Update one PriceOption
     * const priceOption = await prisma.priceOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PriceOptionUpdateArgs>(args: SelectSubset<T, PriceOptionUpdateArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PriceOptions.
     * @param {PriceOptionDeleteManyArgs} args - Arguments to filter PriceOptions to delete.
     * @example
     * // Delete a few PriceOptions
     * const { count } = await prisma.priceOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PriceOptionDeleteManyArgs>(args?: SelectSubset<T, PriceOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PriceOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PriceOptions
     * const priceOption = await prisma.priceOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PriceOptionUpdateManyArgs>(args: SelectSubset<T, PriceOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PriceOption.
     * @param {PriceOptionUpsertArgs} args - Arguments to update or create a PriceOption.
     * @example
     * // Update or create a PriceOption
     * const priceOption = await prisma.priceOption.upsert({
     *   create: {
     *     // ... data to create a PriceOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PriceOption we want to update
     *   }
     * })
     */
    upsert<T extends PriceOptionUpsertArgs>(args: SelectSubset<T, PriceOptionUpsertArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PriceOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionCountArgs} args - Arguments to filter PriceOptions to count.
     * @example
     * // Count the number of PriceOptions
     * const count = await prisma.priceOption.count({
     *   where: {
     *     // ... the filter for the PriceOptions we want to count
     *   }
     * })
    **/
    count<T extends PriceOptionCountArgs>(
      args?: Subset<T, PriceOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PriceOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PriceOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PriceOptionAggregateArgs>(args: Subset<T, PriceOptionAggregateArgs>): Prisma.PrismaPromise<GetPriceOptionAggregateType<T>>

    /**
     * Group by PriceOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PriceOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PriceOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PriceOptionGroupByArgs['orderBy'] }
        : { orderBy?: PriceOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PriceOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPriceOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PriceOption model
   */
  readonly fields: PriceOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PriceOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PriceOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends CategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CategoryDefaultArgs<ExtArgs>>): Prisma__CategoryClient<$Result.GetResult<Prisma.$CategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orderItems<T extends PriceOption$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, PriceOption$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PriceOption model
   */ 
  interface PriceOptionFieldRefs {
    readonly id: FieldRef<"PriceOption", 'Int'>
    readonly option: FieldRef<"PriceOption", 'String'>
    readonly value: FieldRef<"PriceOption", 'Int'>
    readonly categoryId: FieldRef<"PriceOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PriceOption findUnique
   */
  export type PriceOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter, which PriceOption to fetch.
     */
    where: PriceOptionWhereUniqueInput
  }

  /**
   * PriceOption findUniqueOrThrow
   */
  export type PriceOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter, which PriceOption to fetch.
     */
    where: PriceOptionWhereUniqueInput
  }

  /**
   * PriceOption findFirst
   */
  export type PriceOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter, which PriceOption to fetch.
     */
    where?: PriceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceOptions to fetch.
     */
    orderBy?: PriceOptionOrderByWithRelationInput | PriceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceOptions.
     */
    cursor?: PriceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceOptions.
     */
    distinct?: PriceOptionScalarFieldEnum | PriceOptionScalarFieldEnum[]
  }

  /**
   * PriceOption findFirstOrThrow
   */
  export type PriceOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter, which PriceOption to fetch.
     */
    where?: PriceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceOptions to fetch.
     */
    orderBy?: PriceOptionOrderByWithRelationInput | PriceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PriceOptions.
     */
    cursor?: PriceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PriceOptions.
     */
    distinct?: PriceOptionScalarFieldEnum | PriceOptionScalarFieldEnum[]
  }

  /**
   * PriceOption findMany
   */
  export type PriceOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter, which PriceOptions to fetch.
     */
    where?: PriceOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PriceOptions to fetch.
     */
    orderBy?: PriceOptionOrderByWithRelationInput | PriceOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PriceOptions.
     */
    cursor?: PriceOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PriceOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PriceOptions.
     */
    skip?: number
    distinct?: PriceOptionScalarFieldEnum | PriceOptionScalarFieldEnum[]
  }

  /**
   * PriceOption create
   */
  export type PriceOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a PriceOption.
     */
    data: XOR<PriceOptionCreateInput, PriceOptionUncheckedCreateInput>
  }

  /**
   * PriceOption createMany
   */
  export type PriceOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PriceOptions.
     */
    data: PriceOptionCreateManyInput | PriceOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PriceOption update
   */
  export type PriceOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a PriceOption.
     */
    data: XOR<PriceOptionUpdateInput, PriceOptionUncheckedUpdateInput>
    /**
     * Choose, which PriceOption to update.
     */
    where: PriceOptionWhereUniqueInput
  }

  /**
   * PriceOption updateMany
   */
  export type PriceOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PriceOptions.
     */
    data: XOR<PriceOptionUpdateManyMutationInput, PriceOptionUncheckedUpdateManyInput>
    /**
     * Filter which PriceOptions to update
     */
    where?: PriceOptionWhereInput
  }

  /**
   * PriceOption upsert
   */
  export type PriceOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the PriceOption to update in case it exists.
     */
    where: PriceOptionWhereUniqueInput
    /**
     * In case the PriceOption found by the `where` argument doesn't exist, create a new PriceOption with this data.
     */
    create: XOR<PriceOptionCreateInput, PriceOptionUncheckedCreateInput>
    /**
     * In case the PriceOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PriceOptionUpdateInput, PriceOptionUncheckedUpdateInput>
  }

  /**
   * PriceOption delete
   */
  export type PriceOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    /**
     * Filter which PriceOption to delete.
     */
    where: PriceOptionWhereUniqueInput
  }

  /**
   * PriceOption deleteMany
   */
  export type PriceOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PriceOptions to delete
     */
    where?: PriceOptionWhereInput
  }

  /**
   * PriceOption.orderItems
   */
  export type PriceOption$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * PriceOption without action
   */
  export type PriceOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
  }


  /**
   * Model StoreQuantity
   */

  export type AggregateStoreQuantity = {
    _count: StoreQuantityCountAggregateOutputType | null
    _avg: StoreQuantityAvgAggregateOutputType | null
    _sum: StoreQuantitySumAggregateOutputType | null
    _min: StoreQuantityMinAggregateOutputType | null
    _max: StoreQuantityMaxAggregateOutputType | null
  }

  export type StoreQuantityAvgAggregateOutputType = {
    id: number | null
    quantity: number | null
    storeId: number | null
    productId: number | null
  }

  export type StoreQuantitySumAggregateOutputType = {
    id: number | null
    quantity: number | null
    storeId: number | null
    productId: number | null
  }

  export type StoreQuantityMinAggregateOutputType = {
    id: number | null
    quantity: number | null
    storeId: number | null
    productId: number | null
  }

  export type StoreQuantityMaxAggregateOutputType = {
    id: number | null
    quantity: number | null
    storeId: number | null
    productId: number | null
  }

  export type StoreQuantityCountAggregateOutputType = {
    id: number
    quantity: number
    storeId: number
    productId: number
    _all: number
  }


  export type StoreQuantityAvgAggregateInputType = {
    id?: true
    quantity?: true
    storeId?: true
    productId?: true
  }

  export type StoreQuantitySumAggregateInputType = {
    id?: true
    quantity?: true
    storeId?: true
    productId?: true
  }

  export type StoreQuantityMinAggregateInputType = {
    id?: true
    quantity?: true
    storeId?: true
    productId?: true
  }

  export type StoreQuantityMaxAggregateInputType = {
    id?: true
    quantity?: true
    storeId?: true
    productId?: true
  }

  export type StoreQuantityCountAggregateInputType = {
    id?: true
    quantity?: true
    storeId?: true
    productId?: true
    _all?: true
  }

  export type StoreQuantityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreQuantity to aggregate.
     */
    where?: StoreQuantityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreQuantities to fetch.
     */
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoreQuantityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreQuantities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreQuantities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StoreQuantities
    **/
    _count?: true | StoreQuantityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoreQuantityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoreQuantitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoreQuantityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoreQuantityMaxAggregateInputType
  }

  export type GetStoreQuantityAggregateType<T extends StoreQuantityAggregateArgs> = {
        [P in keyof T & keyof AggregateStoreQuantity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStoreQuantity[P]>
      : GetScalarType<T[P], AggregateStoreQuantity[P]>
  }




  export type StoreQuantityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoreQuantityWhereInput
    orderBy?: StoreQuantityOrderByWithAggregationInput | StoreQuantityOrderByWithAggregationInput[]
    by: StoreQuantityScalarFieldEnum[] | StoreQuantityScalarFieldEnum
    having?: StoreQuantityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoreQuantityCountAggregateInputType | true
    _avg?: StoreQuantityAvgAggregateInputType
    _sum?: StoreQuantitySumAggregateInputType
    _min?: StoreQuantityMinAggregateInputType
    _max?: StoreQuantityMaxAggregateInputType
  }

  export type StoreQuantityGroupByOutputType = {
    id: number
    quantity: number
    storeId: number
    productId: number
    _count: StoreQuantityCountAggregateOutputType | null
    _avg: StoreQuantityAvgAggregateOutputType | null
    _sum: StoreQuantitySumAggregateOutputType | null
    _min: StoreQuantityMinAggregateOutputType | null
    _max: StoreQuantityMaxAggregateOutputType | null
  }

  type GetStoreQuantityGroupByPayload<T extends StoreQuantityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoreQuantityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoreQuantityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoreQuantityGroupByOutputType[P]>
            : GetScalarType<T[P], StoreQuantityGroupByOutputType[P]>
        }
      >
    >


  export type StoreQuantitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    quantity?: boolean
    storeId?: boolean
    productId?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["storeQuantity"]>


  export type StoreQuantitySelectScalar = {
    id?: boolean
    quantity?: boolean
    storeId?: boolean
    productId?: boolean
  }

  export type StoreQuantityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $StoreQuantityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StoreQuantity"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      store: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      quantity: number
      storeId: number
      productId: number
    }, ExtArgs["result"]["storeQuantity"]>
    composites: {}
  }

  type StoreQuantityGetPayload<S extends boolean | null | undefined | StoreQuantityDefaultArgs> = $Result.GetResult<Prisma.$StoreQuantityPayload, S>

  type StoreQuantityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoreQuantityFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoreQuantityCountAggregateInputType | true
    }

  export interface StoreQuantityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StoreQuantity'], meta: { name: 'StoreQuantity' } }
    /**
     * Find zero or one StoreQuantity that matches the filter.
     * @param {StoreQuantityFindUniqueArgs} args - Arguments to find a StoreQuantity
     * @example
     * // Get one StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoreQuantityFindUniqueArgs>(args: SelectSubset<T, StoreQuantityFindUniqueArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one StoreQuantity that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoreQuantityFindUniqueOrThrowArgs} args - Arguments to find a StoreQuantity
     * @example
     * // Get one StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoreQuantityFindUniqueOrThrowArgs>(args: SelectSubset<T, StoreQuantityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first StoreQuantity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityFindFirstArgs} args - Arguments to find a StoreQuantity
     * @example
     * // Get one StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoreQuantityFindFirstArgs>(args?: SelectSubset<T, StoreQuantityFindFirstArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first StoreQuantity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityFindFirstOrThrowArgs} args - Arguments to find a StoreQuantity
     * @example
     * // Get one StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoreQuantityFindFirstOrThrowArgs>(args?: SelectSubset<T, StoreQuantityFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more StoreQuantities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StoreQuantities
     * const storeQuantities = await prisma.storeQuantity.findMany()
     * 
     * // Get first 10 StoreQuantities
     * const storeQuantities = await prisma.storeQuantity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storeQuantityWithIdOnly = await prisma.storeQuantity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoreQuantityFindManyArgs>(args?: SelectSubset<T, StoreQuantityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a StoreQuantity.
     * @param {StoreQuantityCreateArgs} args - Arguments to create a StoreQuantity.
     * @example
     * // Create one StoreQuantity
     * const StoreQuantity = await prisma.storeQuantity.create({
     *   data: {
     *     // ... data to create a StoreQuantity
     *   }
     * })
     * 
     */
    create<T extends StoreQuantityCreateArgs>(args: SelectSubset<T, StoreQuantityCreateArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many StoreQuantities.
     * @param {StoreQuantityCreateManyArgs} args - Arguments to create many StoreQuantities.
     * @example
     * // Create many StoreQuantities
     * const storeQuantity = await prisma.storeQuantity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoreQuantityCreateManyArgs>(args?: SelectSubset<T, StoreQuantityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StoreQuantity.
     * @param {StoreQuantityDeleteArgs} args - Arguments to delete one StoreQuantity.
     * @example
     * // Delete one StoreQuantity
     * const StoreQuantity = await prisma.storeQuantity.delete({
     *   where: {
     *     // ... filter to delete one StoreQuantity
     *   }
     * })
     * 
     */
    delete<T extends StoreQuantityDeleteArgs>(args: SelectSubset<T, StoreQuantityDeleteArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one StoreQuantity.
     * @param {StoreQuantityUpdateArgs} args - Arguments to update one StoreQuantity.
     * @example
     * // Update one StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoreQuantityUpdateArgs>(args: SelectSubset<T, StoreQuantityUpdateArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more StoreQuantities.
     * @param {StoreQuantityDeleteManyArgs} args - Arguments to filter StoreQuantities to delete.
     * @example
     * // Delete a few StoreQuantities
     * const { count } = await prisma.storeQuantity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoreQuantityDeleteManyArgs>(args?: SelectSubset<T, StoreQuantityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StoreQuantities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StoreQuantities
     * const storeQuantity = await prisma.storeQuantity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoreQuantityUpdateManyArgs>(args: SelectSubset<T, StoreQuantityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StoreQuantity.
     * @param {StoreQuantityUpsertArgs} args - Arguments to update or create a StoreQuantity.
     * @example
     * // Update or create a StoreQuantity
     * const storeQuantity = await prisma.storeQuantity.upsert({
     *   create: {
     *     // ... data to create a StoreQuantity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StoreQuantity we want to update
     *   }
     * })
     */
    upsert<T extends StoreQuantityUpsertArgs>(args: SelectSubset<T, StoreQuantityUpsertArgs<ExtArgs>>): Prisma__StoreQuantityClient<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of StoreQuantities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityCountArgs} args - Arguments to filter StoreQuantities to count.
     * @example
     * // Count the number of StoreQuantities
     * const count = await prisma.storeQuantity.count({
     *   where: {
     *     // ... the filter for the StoreQuantities we want to count
     *   }
     * })
    **/
    count<T extends StoreQuantityCountArgs>(
      args?: Subset<T, StoreQuantityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoreQuantityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StoreQuantity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoreQuantityAggregateArgs>(args: Subset<T, StoreQuantityAggregateArgs>): Prisma.PrismaPromise<GetStoreQuantityAggregateType<T>>

    /**
     * Group by StoreQuantity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoreQuantityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoreQuantityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoreQuantityGroupByArgs['orderBy'] }
        : { orderBy?: StoreQuantityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoreQuantityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoreQuantityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StoreQuantity model
   */
  readonly fields: StoreQuantityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StoreQuantity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoreQuantityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StoreQuantity model
   */ 
  interface StoreQuantityFieldRefs {
    readonly id: FieldRef<"StoreQuantity", 'Int'>
    readonly quantity: FieldRef<"StoreQuantity", 'Int'>
    readonly storeId: FieldRef<"StoreQuantity", 'Int'>
    readonly productId: FieldRef<"StoreQuantity", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * StoreQuantity findUnique
   */
  export type StoreQuantityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter, which StoreQuantity to fetch.
     */
    where: StoreQuantityWhereUniqueInput
  }

  /**
   * StoreQuantity findUniqueOrThrow
   */
  export type StoreQuantityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter, which StoreQuantity to fetch.
     */
    where: StoreQuantityWhereUniqueInput
  }

  /**
   * StoreQuantity findFirst
   */
  export type StoreQuantityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter, which StoreQuantity to fetch.
     */
    where?: StoreQuantityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreQuantities to fetch.
     */
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreQuantities.
     */
    cursor?: StoreQuantityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreQuantities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreQuantities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreQuantities.
     */
    distinct?: StoreQuantityScalarFieldEnum | StoreQuantityScalarFieldEnum[]
  }

  /**
   * StoreQuantity findFirstOrThrow
   */
  export type StoreQuantityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter, which StoreQuantity to fetch.
     */
    where?: StoreQuantityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreQuantities to fetch.
     */
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StoreQuantities.
     */
    cursor?: StoreQuantityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreQuantities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreQuantities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StoreQuantities.
     */
    distinct?: StoreQuantityScalarFieldEnum | StoreQuantityScalarFieldEnum[]
  }

  /**
   * StoreQuantity findMany
   */
  export type StoreQuantityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter, which StoreQuantities to fetch.
     */
    where?: StoreQuantityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StoreQuantities to fetch.
     */
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StoreQuantities.
     */
    cursor?: StoreQuantityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StoreQuantities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StoreQuantities.
     */
    skip?: number
    distinct?: StoreQuantityScalarFieldEnum | StoreQuantityScalarFieldEnum[]
  }

  /**
   * StoreQuantity create
   */
  export type StoreQuantityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * The data needed to create a StoreQuantity.
     */
    data: XOR<StoreQuantityCreateInput, StoreQuantityUncheckedCreateInput>
  }

  /**
   * StoreQuantity createMany
   */
  export type StoreQuantityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StoreQuantities.
     */
    data: StoreQuantityCreateManyInput | StoreQuantityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StoreQuantity update
   */
  export type StoreQuantityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * The data needed to update a StoreQuantity.
     */
    data: XOR<StoreQuantityUpdateInput, StoreQuantityUncheckedUpdateInput>
    /**
     * Choose, which StoreQuantity to update.
     */
    where: StoreQuantityWhereUniqueInput
  }

  /**
   * StoreQuantity updateMany
   */
  export type StoreQuantityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StoreQuantities.
     */
    data: XOR<StoreQuantityUpdateManyMutationInput, StoreQuantityUncheckedUpdateManyInput>
    /**
     * Filter which StoreQuantities to update
     */
    where?: StoreQuantityWhereInput
  }

  /**
   * StoreQuantity upsert
   */
  export type StoreQuantityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * The filter to search for the StoreQuantity to update in case it exists.
     */
    where: StoreQuantityWhereUniqueInput
    /**
     * In case the StoreQuantity found by the `where` argument doesn't exist, create a new StoreQuantity with this data.
     */
    create: XOR<StoreQuantityCreateInput, StoreQuantityUncheckedCreateInput>
    /**
     * In case the StoreQuantity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoreQuantityUpdateInput, StoreQuantityUncheckedUpdateInput>
  }

  /**
   * StoreQuantity delete
   */
  export type StoreQuantityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    /**
     * Filter which StoreQuantity to delete.
     */
    where: StoreQuantityWhereUniqueInput
  }

  /**
   * StoreQuantity deleteMany
   */
  export type StoreQuantityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StoreQuantities to delete
     */
    where?: StoreQuantityWhereInput
  }

  /**
   * StoreQuantity without action
   */
  export type StoreQuantityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
  }


  /**
   * Model Stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresAvgAggregateOutputType = {
    id: number | null
  }

  export type StoresSumAggregateOutputType = {
    id: number | null
  }

  export type StoresMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StoresMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type StoresAvgAggregateInputType = {
    id?: true
  }

  export type StoresSumAggregateInputType = {
    id?: true
  }

  export type StoresMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to aggregate.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type StoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StoresWhereInput
    orderBy?: StoresOrderByWithAggregationInput | StoresOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: StoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _avg?: StoresAvgAggregateInputType
    _sum?: StoresSumAggregateInputType
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: number
    name: string
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends StoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type StoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    storeQuantities?: boolean | Stores$storeQuantitiesArgs<ExtArgs>
    purchase?: boolean | Stores$purchaseArgs<ExtArgs>
    purchaseHistory?: boolean | Stores$purchaseHistoryArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>


  export type StoresSelectScalar = {
    id?: boolean
    name?: boolean
  }

  export type StoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    storeQuantities?: boolean | Stores$storeQuantitiesArgs<ExtArgs>
    purchase?: boolean | Stores$purchaseArgs<ExtArgs>
    purchaseHistory?: boolean | Stores$purchaseHistoryArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $StoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Stores"
    objects: {
      storeQuantities: Prisma.$StoreQuantityPayload<ExtArgs>[]
      purchase: Prisma.$PurchasePayload<ExtArgs>[]
      purchaseHistory: Prisma.$PurchaseHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type StoresGetPayload<S extends boolean | null | undefined | StoresDefaultArgs> = $Result.GetResult<Prisma.$StoresPayload, S>

  type StoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StoresFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface StoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Stores'], meta: { name: 'Stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {StoresFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StoresFindUniqueArgs>(args: SelectSubset<T, StoresFindUniqueArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StoresFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StoresFindUniqueOrThrowArgs>(args: SelectSubset<T, StoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StoresFindFirstArgs>(args?: SelectSubset<T, StoresFindFirstArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StoresFindFirstOrThrowArgs>(args?: SelectSubset<T, StoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StoresFindManyArgs>(args?: SelectSubset<T, StoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Stores.
     * @param {StoresCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends StoresCreateArgs>(args: SelectSubset<T, StoresCreateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stores.
     * @param {StoresCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StoresCreateManyArgs>(args?: SelectSubset<T, StoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stores.
     * @param {StoresDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends StoresDeleteArgs>(args: SelectSubset<T, StoresDeleteArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Stores.
     * @param {StoresUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StoresUpdateArgs>(args: SelectSubset<T, StoresUpdateArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stores.
     * @param {StoresDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StoresDeleteManyArgs>(args?: SelectSubset<T, StoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StoresUpdateManyArgs>(args: SelectSubset<T, StoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stores.
     * @param {StoresUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends StoresUpsertArgs>(args: SelectSubset<T, StoresUpsertArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends StoresCountArgs>(
      args?: Subset<T, StoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StoresGroupByArgs['orderBy'] }
        : { orderBy?: StoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Stores model
   */
  readonly fields: StoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    storeQuantities<T extends Stores$storeQuantitiesArgs<ExtArgs> = {}>(args?: Subset<T, Stores$storeQuantitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StoreQuantityPayload<ExtArgs>, T, "findMany"> | Null>
    purchase<T extends Stores$purchaseArgs<ExtArgs> = {}>(args?: Subset<T, Stores$purchaseArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany"> | Null>
    purchaseHistory<T extends Stores$purchaseHistoryArgs<ExtArgs> = {}>(args?: Subset<T, Stores$purchaseHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Stores model
   */ 
  interface StoresFieldRefs {
    readonly id: FieldRef<"Stores", 'Int'>
    readonly name: FieldRef<"Stores", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Stores findUnique
   */
  export type StoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findUniqueOrThrow
   */
  export type StoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores findFirst
   */
  export type StoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findFirstOrThrow
   */
  export type StoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores findMany
   */
  export type StoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter, which Stores to fetch.
     */
    where?: StoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stores to fetch.
     */
    orderBy?: StoresOrderByWithRelationInput | StoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stores.
     */
    cursor?: StoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * Stores create
   */
  export type StoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Stores.
     */
    data: XOR<StoresCreateInput, StoresUncheckedCreateInput>
  }

  /**
   * Stores createMany
   */
  export type StoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stores.
     */
    data: StoresCreateManyInput | StoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Stores update
   */
  export type StoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Stores.
     */
    data: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
    /**
     * Choose, which Stores to update.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores updateMany
   */
  export type StoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stores.
     */
    data: XOR<StoresUpdateManyMutationInput, StoresUncheckedUpdateManyInput>
    /**
     * Filter which Stores to update
     */
    where?: StoresWhereInput
  }

  /**
   * Stores upsert
   */
  export type StoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Stores to update in case it exists.
     */
    where: StoresWhereUniqueInput
    /**
     * In case the Stores found by the `where` argument doesn't exist, create a new Stores with this data.
     */
    create: XOR<StoresCreateInput, StoresUncheckedCreateInput>
    /**
     * In case the Stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StoresUpdateInput, StoresUncheckedUpdateInput>
  }

  /**
   * Stores delete
   */
  export type StoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
    /**
     * Filter which Stores to delete.
     */
    where: StoresWhereUniqueInput
  }

  /**
   * Stores deleteMany
   */
  export type StoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stores to delete
     */
    where?: StoresWhereInput
  }

  /**
   * Stores.storeQuantities
   */
  export type Stores$storeQuantitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoreQuantity
     */
    select?: StoreQuantitySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoreQuantityInclude<ExtArgs> | null
    where?: StoreQuantityWhereInput
    orderBy?: StoreQuantityOrderByWithRelationInput | StoreQuantityOrderByWithRelationInput[]
    cursor?: StoreQuantityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoreQuantityScalarFieldEnum | StoreQuantityScalarFieldEnum[]
  }

  /**
   * Stores.purchase
   */
  export type Stores$purchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    cursor?: PurchaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Stores.purchaseHistory
   */
  export type Stores$purchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    cursor?: PurchaseHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * Stores without action
   */
  export type StoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Stores
     */
    select?: StoresSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StoresInclude<ExtArgs> | null
  }


  /**
   * Model Purchase
   */

  export type AggregatePurchase = {
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  export type PurchaseAvgAggregateOutputType = {
    id: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type PurchaseSumAggregateOutputType = {
    id: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    totalPrice: number | null
  }

  export type PurchaseMinAggregateOutputType = {
    id: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    totalPrice: number | null
    date: Date | null
  }

  export type PurchaseMaxAggregateOutputType = {
    id: number | null
    productId: number | null
    storeId: number | null
    quantity: number | null
    totalPrice: number | null
    date: Date | null
  }

  export type PurchaseCountAggregateOutputType = {
    id: number
    productId: number
    storeId: number
    quantity: number
    totalPrice: number
    date: number
    _all: number
  }


  export type PurchaseAvgAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    quantity?: true
    totalPrice?: true
  }

  export type PurchaseSumAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    quantity?: true
    totalPrice?: true
  }

  export type PurchaseMinAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    quantity?: true
    totalPrice?: true
    date?: true
  }

  export type PurchaseMaxAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    quantity?: true
    totalPrice?: true
    date?: true
  }

  export type PurchaseCountAggregateInputType = {
    id?: true
    productId?: true
    storeId?: true
    quantity?: true
    totalPrice?: true
    date?: true
    _all?: true
  }

  export type PurchaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchase to aggregate.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Purchases
    **/
    _count?: true | PurchaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseMaxAggregateInputType
  }

  export type GetPurchaseAggregateType<T extends PurchaseAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchase[P]>
      : GetScalarType<T[P], AggregatePurchase[P]>
  }




  export type PurchaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseWhereInput
    orderBy?: PurchaseOrderByWithAggregationInput | PurchaseOrderByWithAggregationInput[]
    by: PurchaseScalarFieldEnum[] | PurchaseScalarFieldEnum
    having?: PurchaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseCountAggregateInputType | true
    _avg?: PurchaseAvgAggregateInputType
    _sum?: PurchaseSumAggregateInputType
    _min?: PurchaseMinAggregateInputType
    _max?: PurchaseMaxAggregateInputType
  }

  export type PurchaseGroupByOutputType = {
    id: number
    productId: number
    storeId: number
    quantity: number
    totalPrice: number
    date: Date
    _count: PurchaseCountAggregateOutputType | null
    _avg: PurchaseAvgAggregateOutputType | null
    _sum: PurchaseSumAggregateOutputType | null
    _min: PurchaseMinAggregateOutputType | null
    _max: PurchaseMaxAggregateOutputType | null
  }

  type GetPurchaseGroupByPayload<T extends PurchaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    storeId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    date?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchase"]>


  export type PurchaseSelectScalar = {
    id?: boolean
    productId?: boolean
    storeId?: boolean
    quantity?: boolean
    totalPrice?: boolean
    date?: boolean
  }

  export type PurchaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    store?: boolean | StoresDefaultArgs<ExtArgs>
  }

  export type $PurchasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Purchase"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      store: Prisma.$StoresPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      productId: number
      storeId: number
      quantity: number
      totalPrice: number
      date: Date
    }, ExtArgs["result"]["purchase"]>
    composites: {}
  }

  type PurchaseGetPayload<S extends boolean | null | undefined | PurchaseDefaultArgs> = $Result.GetResult<Prisma.$PurchasePayload, S>

  type PurchaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseCountAggregateInputType | true
    }

  export interface PurchaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Purchase'], meta: { name: 'Purchase' } }
    /**
     * Find zero or one Purchase that matches the filter.
     * @param {PurchaseFindUniqueArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseFindUniqueArgs>(args: SelectSubset<T, PurchaseFindUniqueArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Purchase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseFindUniqueOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Purchase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseFindFirstArgs>(args?: SelectSubset<T, PurchaseFindFirstArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Purchase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindFirstOrThrowArgs} args - Arguments to find a Purchase
     * @example
     * // Get one Purchase
     * const purchase = await prisma.purchase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Purchases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Purchases
     * const purchases = await prisma.purchase.findMany()
     * 
     * // Get first 10 Purchases
     * const purchases = await prisma.purchase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseWithIdOnly = await prisma.purchase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseFindManyArgs>(args?: SelectSubset<T, PurchaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Purchase.
     * @param {PurchaseCreateArgs} args - Arguments to create a Purchase.
     * @example
     * // Create one Purchase
     * const Purchase = await prisma.purchase.create({
     *   data: {
     *     // ... data to create a Purchase
     *   }
     * })
     * 
     */
    create<T extends PurchaseCreateArgs>(args: SelectSubset<T, PurchaseCreateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Purchases.
     * @param {PurchaseCreateManyArgs} args - Arguments to create many Purchases.
     * @example
     * // Create many Purchases
     * const purchase = await prisma.purchase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseCreateManyArgs>(args?: SelectSubset<T, PurchaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Purchase.
     * @param {PurchaseDeleteArgs} args - Arguments to delete one Purchase.
     * @example
     * // Delete one Purchase
     * const Purchase = await prisma.purchase.delete({
     *   where: {
     *     // ... filter to delete one Purchase
     *   }
     * })
     * 
     */
    delete<T extends PurchaseDeleteArgs>(args: SelectSubset<T, PurchaseDeleteArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Purchase.
     * @param {PurchaseUpdateArgs} args - Arguments to update one Purchase.
     * @example
     * // Update one Purchase
     * const purchase = await prisma.purchase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseUpdateArgs>(args: SelectSubset<T, PurchaseUpdateArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Purchases.
     * @param {PurchaseDeleteManyArgs} args - Arguments to filter Purchases to delete.
     * @example
     * // Delete a few Purchases
     * const { count } = await prisma.purchase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseDeleteManyArgs>(args?: SelectSubset<T, PurchaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Purchases
     * const purchase = await prisma.purchase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseUpdateManyArgs>(args: SelectSubset<T, PurchaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Purchase.
     * @param {PurchaseUpsertArgs} args - Arguments to update or create a Purchase.
     * @example
     * // Update or create a Purchase
     * const purchase = await prisma.purchase.upsert({
     *   create: {
     *     // ... data to create a Purchase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Purchase we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseUpsertArgs>(args: SelectSubset<T, PurchaseUpsertArgs<ExtArgs>>): Prisma__PurchaseClient<$Result.GetResult<Prisma.$PurchasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Purchases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseCountArgs} args - Arguments to filter Purchases to count.
     * @example
     * // Count the number of Purchases
     * const count = await prisma.purchase.count({
     *   where: {
     *     // ... the filter for the Purchases we want to count
     *   }
     * })
    **/
    count<T extends PurchaseCountArgs>(
      args?: Subset<T, PurchaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseAggregateArgs>(args: Subset<T, PurchaseAggregateArgs>): Prisma.PrismaPromise<GetPurchaseAggregateType<T>>

    /**
     * Group by Purchase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Purchase model
   */
  readonly fields: PurchaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Purchase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Purchase model
   */ 
  interface PurchaseFieldRefs {
    readonly id: FieldRef<"Purchase", 'Int'>
    readonly productId: FieldRef<"Purchase", 'Int'>
    readonly storeId: FieldRef<"Purchase", 'Int'>
    readonly quantity: FieldRef<"Purchase", 'Int'>
    readonly totalPrice: FieldRef<"Purchase", 'Int'>
    readonly date: FieldRef<"Purchase", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Purchase findUnique
   */
  export type PurchaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findUniqueOrThrow
   */
  export type PurchaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase findFirst
   */
  export type PurchaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findFirstOrThrow
   */
  export type PurchaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchase to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Purchases.
     */
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase findMany
   */
  export type PurchaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter, which Purchases to fetch.
     */
    where?: PurchaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Purchases to fetch.
     */
    orderBy?: PurchaseOrderByWithRelationInput | PurchaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Purchases.
     */
    cursor?: PurchaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Purchases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Purchases.
     */
    skip?: number
    distinct?: PurchaseScalarFieldEnum | PurchaseScalarFieldEnum[]
  }

  /**
   * Purchase create
   */
  export type PurchaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to create a Purchase.
     */
    data: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
  }

  /**
   * Purchase createMany
   */
  export type PurchaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Purchases.
     */
    data: PurchaseCreateManyInput | PurchaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Purchase update
   */
  export type PurchaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The data needed to update a Purchase.
     */
    data: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
    /**
     * Choose, which Purchase to update.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase updateMany
   */
  export type PurchaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Purchases.
     */
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyInput>
    /**
     * Filter which Purchases to update
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase upsert
   */
  export type PurchaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * The filter to search for the Purchase to update in case it exists.
     */
    where: PurchaseWhereUniqueInput
    /**
     * In case the Purchase found by the `where` argument doesn't exist, create a new Purchase with this data.
     */
    create: XOR<PurchaseCreateInput, PurchaseUncheckedCreateInput>
    /**
     * In case the Purchase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseUpdateInput, PurchaseUncheckedUpdateInput>
  }

  /**
   * Purchase delete
   */
  export type PurchaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
    /**
     * Filter which Purchase to delete.
     */
    where: PurchaseWhereUniqueInput
  }

  /**
   * Purchase deleteMany
   */
  export type PurchaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Purchases to delete
     */
    where?: PurchaseWhereInput
  }

  /**
   * Purchase without action
   */
  export type PurchaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Purchase
     */
    select?: PurchaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseHistory
   */

  export type AggregatePurchaseHistory = {
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  export type PurchaseHistoryAvgAggregateOutputType = {
    id: number | null
    storeId: number | null
    productId: number | null
    previousQuantity: number | null
    purchaseQuantity: number | null
    newBalance: number | null
  }

  export type PurchaseHistorySumAggregateOutputType = {
    id: number | null
    storeId: number | null
    productId: number | null
    previousQuantity: number | null
    purchaseQuantity: number | null
    newBalance: number | null
  }

  export type PurchaseHistoryMinAggregateOutputType = {
    id: number | null
    storeId: number | null
    productId: number | null
    previousQuantity: number | null
    purchaseQuantity: number | null
    newBalance: number | null
    createdAt: Date | null
  }

  export type PurchaseHistoryMaxAggregateOutputType = {
    id: number | null
    storeId: number | null
    productId: number | null
    previousQuantity: number | null
    purchaseQuantity: number | null
    newBalance: number | null
    createdAt: Date | null
  }

  export type PurchaseHistoryCountAggregateOutputType = {
    id: number
    storeId: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt: number
    _all: number
  }


  export type PurchaseHistoryAvgAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    previousQuantity?: true
    purchaseQuantity?: true
    newBalance?: true
  }

  export type PurchaseHistorySumAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    previousQuantity?: true
    purchaseQuantity?: true
    newBalance?: true
  }

  export type PurchaseHistoryMinAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    previousQuantity?: true
    purchaseQuantity?: true
    newBalance?: true
    createdAt?: true
  }

  export type PurchaseHistoryMaxAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    previousQuantity?: true
    purchaseQuantity?: true
    newBalance?: true
    createdAt?: true
  }

  export type PurchaseHistoryCountAggregateInputType = {
    id?: true
    storeId?: true
    productId?: true
    previousQuantity?: true
    purchaseQuantity?: true
    newBalance?: true
    createdAt?: true
    _all?: true
  }

  export type PurchaseHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistory to aggregate.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseHistories
    **/
    _count?: true | PurchaseHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type GetPurchaseHistoryAggregateType<T extends PurchaseHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseHistory[P]>
      : GetScalarType<T[P], AggregatePurchaseHistory[P]>
  }




  export type PurchaseHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseHistoryWhereInput
    orderBy?: PurchaseHistoryOrderByWithAggregationInput | PurchaseHistoryOrderByWithAggregationInput[]
    by: PurchaseHistoryScalarFieldEnum[] | PurchaseHistoryScalarFieldEnum
    having?: PurchaseHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseHistoryCountAggregateInputType | true
    _avg?: PurchaseHistoryAvgAggregateInputType
    _sum?: PurchaseHistorySumAggregateInputType
    _min?: PurchaseHistoryMinAggregateInputType
    _max?: PurchaseHistoryMaxAggregateInputType
  }

  export type PurchaseHistoryGroupByOutputType = {
    id: number
    storeId: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt: Date
    _count: PurchaseHistoryCountAggregateOutputType | null
    _avg: PurchaseHistoryAvgAggregateOutputType | null
    _sum: PurchaseHistorySumAggregateOutputType | null
    _min: PurchaseHistoryMinAggregateOutputType | null
    _max: PurchaseHistoryMaxAggregateOutputType | null
  }

  type GetPurchaseHistoryGroupByPayload<T extends PurchaseHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseHistoryGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeId?: boolean
    productId?: boolean
    previousQuantity?: boolean
    purchaseQuantity?: boolean
    newBalance?: boolean
    createdAt?: boolean
    store?: boolean | StoresDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseHistory"]>


  export type PurchaseHistorySelectScalar = {
    id?: boolean
    storeId?: boolean
    productId?: boolean
    previousQuantity?: boolean
    purchaseQuantity?: boolean
    newBalance?: boolean
    createdAt?: boolean
  }

  export type PurchaseHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    store?: boolean | StoresDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $PurchaseHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseHistory"
    objects: {
      store: Prisma.$StoresPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      storeId: number
      productId: number
      previousQuantity: number
      purchaseQuantity: number
      newBalance: number
      createdAt: Date
    }, ExtArgs["result"]["purchaseHistory"]>
    composites: {}
  }

  type PurchaseHistoryGetPayload<S extends boolean | null | undefined | PurchaseHistoryDefaultArgs> = $Result.GetResult<Prisma.$PurchaseHistoryPayload, S>

  type PurchaseHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PurchaseHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PurchaseHistoryCountAggregateInputType | true
    }

  export interface PurchaseHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseHistory'], meta: { name: 'PurchaseHistory' } }
    /**
     * Find zero or one PurchaseHistory that matches the filter.
     * @param {PurchaseHistoryFindUniqueArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseHistoryFindUniqueArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PurchaseHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PurchaseHistoryFindUniqueOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PurchaseHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseHistoryFindFirstArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PurchaseHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindFirstOrThrowArgs} args - Arguments to find a PurchaseHistory
     * @example
     * // Get one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PurchaseHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany()
     * 
     * // Get first 10 PurchaseHistories
     * const purchaseHistories = await prisma.purchaseHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseHistoryWithIdOnly = await prisma.purchaseHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseHistoryFindManyArgs>(args?: SelectSubset<T, PurchaseHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PurchaseHistory.
     * @param {PurchaseHistoryCreateArgs} args - Arguments to create a PurchaseHistory.
     * @example
     * // Create one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.create({
     *   data: {
     *     // ... data to create a PurchaseHistory
     *   }
     * })
     * 
     */
    create<T extends PurchaseHistoryCreateArgs>(args: SelectSubset<T, PurchaseHistoryCreateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PurchaseHistories.
     * @param {PurchaseHistoryCreateManyArgs} args - Arguments to create many PurchaseHistories.
     * @example
     * // Create many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseHistoryCreateManyArgs>(args?: SelectSubset<T, PurchaseHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PurchaseHistory.
     * @param {PurchaseHistoryDeleteArgs} args - Arguments to delete one PurchaseHistory.
     * @example
     * // Delete one PurchaseHistory
     * const PurchaseHistory = await prisma.purchaseHistory.delete({
     *   where: {
     *     // ... filter to delete one PurchaseHistory
     *   }
     * })
     * 
     */
    delete<T extends PurchaseHistoryDeleteArgs>(args: SelectSubset<T, PurchaseHistoryDeleteArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PurchaseHistory.
     * @param {PurchaseHistoryUpdateArgs} args - Arguments to update one PurchaseHistory.
     * @example
     * // Update one PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseHistoryUpdateArgs>(args: SelectSubset<T, PurchaseHistoryUpdateArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PurchaseHistories.
     * @param {PurchaseHistoryDeleteManyArgs} args - Arguments to filter PurchaseHistories to delete.
     * @example
     * // Delete a few PurchaseHistories
     * const { count } = await prisma.purchaseHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseHistoryDeleteManyArgs>(args?: SelectSubset<T, PurchaseHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseHistories
     * const purchaseHistory = await prisma.purchaseHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseHistoryUpdateManyArgs>(args: SelectSubset<T, PurchaseHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PurchaseHistory.
     * @param {PurchaseHistoryUpsertArgs} args - Arguments to update or create a PurchaseHistory.
     * @example
     * // Update or create a PurchaseHistory
     * const purchaseHistory = await prisma.purchaseHistory.upsert({
     *   create: {
     *     // ... data to create a PurchaseHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseHistory we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseHistoryUpsertArgs>(args: SelectSubset<T, PurchaseHistoryUpsertArgs<ExtArgs>>): Prisma__PurchaseHistoryClient<$Result.GetResult<Prisma.$PurchaseHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PurchaseHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryCountArgs} args - Arguments to filter PurchaseHistories to count.
     * @example
     * // Count the number of PurchaseHistories
     * const count = await prisma.purchaseHistory.count({
     *   where: {
     *     // ... the filter for the PurchaseHistories we want to count
     *   }
     * })
    **/
    count<T extends PurchaseHistoryCountArgs>(
      args?: Subset<T, PurchaseHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseHistoryAggregateArgs>(args: Subset<T, PurchaseHistoryAggregateArgs>): Prisma.PrismaPromise<GetPurchaseHistoryAggregateType<T>>

    /**
     * Group by PurchaseHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseHistoryGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseHistory model
   */
  readonly fields: PurchaseHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    store<T extends StoresDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StoresDefaultArgs<ExtArgs>>): Prisma__StoresClient<$Result.GetResult<Prisma.$StoresPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseHistory model
   */ 
  interface PurchaseHistoryFieldRefs {
    readonly id: FieldRef<"PurchaseHistory", 'Int'>
    readonly storeId: FieldRef<"PurchaseHistory", 'Int'>
    readonly productId: FieldRef<"PurchaseHistory", 'Int'>
    readonly previousQuantity: FieldRef<"PurchaseHistory", 'Int'>
    readonly purchaseQuantity: FieldRef<"PurchaseHistory", 'Int'>
    readonly newBalance: FieldRef<"PurchaseHistory", 'Int'>
    readonly createdAt: FieldRef<"PurchaseHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseHistory findUnique
   */
  export type PurchaseHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findUniqueOrThrow
   */
  export type PurchaseHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory findFirst
   */
  export type PurchaseHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findFirstOrThrow
   */
  export type PurchaseHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistory to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseHistories.
     */
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory findMany
   */
  export type PurchaseHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseHistories to fetch.
     */
    where?: PurchaseHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseHistories to fetch.
     */
    orderBy?: PurchaseHistoryOrderByWithRelationInput | PurchaseHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseHistories.
     */
    cursor?: PurchaseHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseHistories.
     */
    skip?: number
    distinct?: PurchaseHistoryScalarFieldEnum | PurchaseHistoryScalarFieldEnum[]
  }

  /**
   * PurchaseHistory create
   */
  export type PurchaseHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
  }

  /**
   * PurchaseHistory createMany
   */
  export type PurchaseHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseHistories.
     */
    data: PurchaseHistoryCreateManyInput | PurchaseHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseHistory update
   */
  export type PurchaseHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseHistory.
     */
    data: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
    /**
     * Choose, which PurchaseHistory to update.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory updateMany
   */
  export type PurchaseHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseHistories.
     */
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseHistories to update
     */
    where?: PurchaseHistoryWhereInput
  }

  /**
   * PurchaseHistory upsert
   */
  export type PurchaseHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseHistory to update in case it exists.
     */
    where: PurchaseHistoryWhereUniqueInput
    /**
     * In case the PurchaseHistory found by the `where` argument doesn't exist, create a new PurchaseHistory with this data.
     */
    create: XOR<PurchaseHistoryCreateInput, PurchaseHistoryUncheckedCreateInput>
    /**
     * In case the PurchaseHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseHistoryUpdateInput, PurchaseHistoryUncheckedUpdateInput>
  }

  /**
   * PurchaseHistory delete
   */
  export type PurchaseHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
    /**
     * Filter which PurchaseHistory to delete.
     */
    where: PurchaseHistoryWhereUniqueInput
  }

  /**
   * PurchaseHistory deleteMany
   */
  export type PurchaseHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseHistories to delete
     */
    where?: PurchaseHistoryWhereInput
  }

  /**
   * PurchaseHistory without action
   */
  export type PurchaseHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseHistory
     */
    select?: PurchaseHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Clients
   */

  export type AggregateClients = {
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  export type ClientsAvgAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    region_id: number | null
    status: number | null
    client_type: number | null
    countryId: number | null
  }

  export type ClientsSumAggregateOutputType = {
    id: number | null
    latitude: number | null
    longitude: number | null
    region_id: number | null
    status: number | null
    client_type: number | null
    countryId: number | null
  }

  export type ClientsMinAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    balance: string | null
    email: string | null
    region_id: number | null
    region: string | null
    contact: string | null
    tax_pin: string | null
    location: string | null
    status: number | null
    client_type: number | null
    countryId: number | null
  }

  export type ClientsMaxAggregateOutputType = {
    id: number | null
    name: string | null
    address: string | null
    latitude: number | null
    longitude: number | null
    balance: string | null
    email: string | null
    region_id: number | null
    region: string | null
    contact: string | null
    tax_pin: string | null
    location: string | null
    status: number | null
    client_type: number | null
    countryId: number | null
  }

  export type ClientsCountAggregateOutputType = {
    id: number
    name: number
    address: number
    latitude: number
    longitude: number
    balance: number
    email: number
    region_id: number
    region: number
    contact: number
    tax_pin: number
    location: number
    status: number
    client_type: number
    countryId: number
    _all: number
  }


  export type ClientsAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    region_id?: true
    status?: true
    client_type?: true
    countryId?: true
  }

  export type ClientsSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
    region_id?: true
    status?: true
    client_type?: true
    countryId?: true
  }

  export type ClientsMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    balance?: true
    email?: true
    region_id?: true
    region?: true
    contact?: true
    tax_pin?: true
    location?: true
    status?: true
    client_type?: true
    countryId?: true
  }

  export type ClientsMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    balance?: true
    email?: true
    region_id?: true
    region?: true
    contact?: true
    tax_pin?: true
    location?: true
    status?: true
    client_type?: true
    countryId?: true
  }

  export type ClientsCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    latitude?: true
    longitude?: true
    balance?: true
    email?: true
    region_id?: true
    region?: true
    contact?: true
    tax_pin?: true
    location?: true
    status?: true
    client_type?: true
    countryId?: true
    _all?: true
  }

  export type ClientsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to aggregate.
     */
    where?: ClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientsOrderByWithRelationInput | ClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clients
    **/
    _count?: true | ClientsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClientsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClientsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientsMaxAggregateInputType
  }

  export type GetClientsAggregateType<T extends ClientsAggregateArgs> = {
        [P in keyof T & keyof AggregateClients]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClients[P]>
      : GetScalarType<T[P], AggregateClients[P]>
  }




  export type ClientsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientsWhereInput
    orderBy?: ClientsOrderByWithAggregationInput | ClientsOrderByWithAggregationInput[]
    by: ClientsScalarFieldEnum[] | ClientsScalarFieldEnum
    having?: ClientsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientsCountAggregateInputType | true
    _avg?: ClientsAvgAggregateInputType
    _sum?: ClientsSumAggregateInputType
    _min?: ClientsMinAggregateInputType
    _max?: ClientsMaxAggregateInputType
  }

  export type ClientsGroupByOutputType = {
    id: number
    name: string
    address: string | null
    latitude: number | null
    longitude: number | null
    balance: string | null
    email: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status: number
    client_type: number | null
    countryId: number
    _count: ClientsCountAggregateOutputType | null
    _avg: ClientsAvgAggregateOutputType | null
    _sum: ClientsSumAggregateOutputType | null
    _min: ClientsMinAggregateOutputType | null
    _max: ClientsMaxAggregateOutputType | null
  }

  type GetClientsGroupByPayload<T extends ClientsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientsGroupByOutputType[P]>
            : GetScalarType<T[P], ClientsGroupByOutputType[P]>
        }
      >
    >


  export type ClientsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    balance?: boolean
    email?: boolean
    region_id?: boolean
    region?: boolean
    contact?: boolean
    tax_pin?: boolean
    location?: boolean
    status?: boolean
    client_type?: boolean
    countryId?: boolean
    country?: boolean | CountryDefaultArgs<ExtArgs>
    journeyPlans?: boolean | Clients$journeyPlansArgs<ExtArgs>
    MyOrder?: boolean | Clients$MyOrderArgs<ExtArgs>
    products?: boolean | Clients$productsArgs<ExtArgs>
    reports?: boolean | Clients$reportsArgs<ExtArgs>
    checkins?: boolean | Clients$checkinsArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clients"]>


  export type ClientsSelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    latitude?: boolean
    longitude?: boolean
    balance?: boolean
    email?: boolean
    region_id?: boolean
    region?: boolean
    contact?: boolean
    tax_pin?: boolean
    location?: boolean
    status?: boolean
    client_type?: boolean
    countryId?: boolean
  }

  export type ClientsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    country?: boolean | CountryDefaultArgs<ExtArgs>
    journeyPlans?: boolean | Clients$journeyPlansArgs<ExtArgs>
    MyOrder?: boolean | Clients$MyOrderArgs<ExtArgs>
    products?: boolean | Clients$productsArgs<ExtArgs>
    reports?: boolean | Clients$reportsArgs<ExtArgs>
    checkins?: boolean | Clients$checkinsArgs<ExtArgs>
    _count?: boolean | ClientsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ClientsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clients"
    objects: {
      country: Prisma.$CountryPayload<ExtArgs>
      journeyPlans: Prisma.$JourneyPlanPayload<ExtArgs>[]
      MyOrder: Prisma.$MyOrderPayload<ExtArgs>[]
      products: Prisma.$ProductPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
      checkins: Prisma.$ManagerCheckinPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      address: string | null
      latitude: number | null
      longitude: number | null
      balance: string | null
      email: string | null
      region_id: number
      region: string
      contact: string
      tax_pin: string
      location: string
      status: number
      client_type: number | null
      countryId: number
    }, ExtArgs["result"]["clients"]>
    composites: {}
  }

  type ClientsGetPayload<S extends boolean | null | undefined | ClientsDefaultArgs> = $Result.GetResult<Prisma.$ClientsPayload, S>

  type ClientsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClientsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClientsCountAggregateInputType | true
    }

  export interface ClientsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clients'], meta: { name: 'Clients' } }
    /**
     * Find zero or one Clients that matches the filter.
     * @param {ClientsFindUniqueArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientsFindUniqueArgs>(args: SelectSubset<T, ClientsFindUniqueArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clients that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClientsFindUniqueOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientsFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindFirstArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientsFindFirstArgs>(args?: SelectSubset<T, ClientsFindFirstArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clients that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindFirstOrThrowArgs} args - Arguments to find a Clients
     * @example
     * // Get one Clients
     * const clients = await prisma.clients.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientsFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientsFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clients
     * const clients = await prisma.clients.findMany()
     * 
     * // Get first 10 Clients
     * const clients = await prisma.clients.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientsWithIdOnly = await prisma.clients.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientsFindManyArgs>(args?: SelectSubset<T, ClientsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clients.
     * @param {ClientsCreateArgs} args - Arguments to create a Clients.
     * @example
     * // Create one Clients
     * const Clients = await prisma.clients.create({
     *   data: {
     *     // ... data to create a Clients
     *   }
     * })
     * 
     */
    create<T extends ClientsCreateArgs>(args: SelectSubset<T, ClientsCreateArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clients.
     * @param {ClientsCreateManyArgs} args - Arguments to create many Clients.
     * @example
     * // Create many Clients
     * const clients = await prisma.clients.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientsCreateManyArgs>(args?: SelectSubset<T, ClientsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Clients.
     * @param {ClientsDeleteArgs} args - Arguments to delete one Clients.
     * @example
     * // Delete one Clients
     * const Clients = await prisma.clients.delete({
     *   where: {
     *     // ... filter to delete one Clients
     *   }
     * })
     * 
     */
    delete<T extends ClientsDeleteArgs>(args: SelectSubset<T, ClientsDeleteArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clients.
     * @param {ClientsUpdateArgs} args - Arguments to update one Clients.
     * @example
     * // Update one Clients
     * const clients = await prisma.clients.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientsUpdateArgs>(args: SelectSubset<T, ClientsUpdateArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clients.
     * @param {ClientsDeleteManyArgs} args - Arguments to filter Clients to delete.
     * @example
     * // Delete a few Clients
     * const { count } = await prisma.clients.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientsDeleteManyArgs>(args?: SelectSubset<T, ClientsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clients
     * const clients = await prisma.clients.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientsUpdateManyArgs>(args: SelectSubset<T, ClientsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clients.
     * @param {ClientsUpsertArgs} args - Arguments to update or create a Clients.
     * @example
     * // Update or create a Clients
     * const clients = await prisma.clients.upsert({
     *   create: {
     *     // ... data to create a Clients
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clients we want to update
     *   }
     * })
     */
    upsert<T extends ClientsUpsertArgs>(args: SelectSubset<T, ClientsUpsertArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsCountArgs} args - Arguments to filter Clients to count.
     * @example
     * // Count the number of Clients
     * const count = await prisma.clients.count({
     *   where: {
     *     // ... the filter for the Clients we want to count
     *   }
     * })
    **/
    count<T extends ClientsCountArgs>(
      args?: Subset<T, ClientsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientsAggregateArgs>(args: Subset<T, ClientsAggregateArgs>): Prisma.PrismaPromise<GetClientsAggregateType<T>>

    /**
     * Group by Clients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientsGroupByArgs['orderBy'] }
        : { orderBy?: ClientsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clients model
   */
  readonly fields: ClientsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clients.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    country<T extends CountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountryDefaultArgs<ExtArgs>>): Prisma__CountryClient<$Result.GetResult<Prisma.$CountryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    journeyPlans<T extends Clients$journeyPlansArgs<ExtArgs> = {}>(args?: Subset<T, Clients$journeyPlansArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findMany"> | Null>
    MyOrder<T extends Clients$MyOrderArgs<ExtArgs> = {}>(args?: Subset<T, Clients$MyOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findMany"> | Null>
    products<T extends Clients$productsArgs<ExtArgs> = {}>(args?: Subset<T, Clients$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends Clients$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Clients$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    checkins<T extends Clients$checkinsArgs<ExtArgs> = {}>(args?: Subset<T, Clients$checkinsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clients model
   */ 
  interface ClientsFieldRefs {
    readonly id: FieldRef<"Clients", 'Int'>
    readonly name: FieldRef<"Clients", 'String'>
    readonly address: FieldRef<"Clients", 'String'>
    readonly latitude: FieldRef<"Clients", 'Float'>
    readonly longitude: FieldRef<"Clients", 'Float'>
    readonly balance: FieldRef<"Clients", 'String'>
    readonly email: FieldRef<"Clients", 'String'>
    readonly region_id: FieldRef<"Clients", 'Int'>
    readonly region: FieldRef<"Clients", 'String'>
    readonly contact: FieldRef<"Clients", 'String'>
    readonly tax_pin: FieldRef<"Clients", 'String'>
    readonly location: FieldRef<"Clients", 'String'>
    readonly status: FieldRef<"Clients", 'Int'>
    readonly client_type: FieldRef<"Clients", 'Int'>
    readonly countryId: FieldRef<"Clients", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Clients findUnique
   */
  export type ClientsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where: ClientsWhereUniqueInput
  }

  /**
   * Clients findUniqueOrThrow
   */
  export type ClientsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where: ClientsWhereUniqueInput
  }

  /**
   * Clients findFirst
   */
  export type ClientsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientsOrderByWithRelationInput | ClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * Clients findFirstOrThrow
   */
  export type ClientsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientsOrderByWithRelationInput | ClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clients.
     */
    cursor?: ClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clients.
     */
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * Clients findMany
   */
  export type ClientsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter, which Clients to fetch.
     */
    where?: ClientsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clients to fetch.
     */
    orderBy?: ClientsOrderByWithRelationInput | ClientsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clients.
     */
    cursor?: ClientsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clients.
     */
    skip?: number
    distinct?: ClientsScalarFieldEnum | ClientsScalarFieldEnum[]
  }

  /**
   * Clients create
   */
  export type ClientsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * The data needed to create a Clients.
     */
    data: XOR<ClientsCreateInput, ClientsUncheckedCreateInput>
  }

  /**
   * Clients createMany
   */
  export type ClientsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clients.
     */
    data: ClientsCreateManyInput | ClientsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clients update
   */
  export type ClientsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * The data needed to update a Clients.
     */
    data: XOR<ClientsUpdateInput, ClientsUncheckedUpdateInput>
    /**
     * Choose, which Clients to update.
     */
    where: ClientsWhereUniqueInput
  }

  /**
   * Clients updateMany
   */
  export type ClientsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clients.
     */
    data: XOR<ClientsUpdateManyMutationInput, ClientsUncheckedUpdateManyInput>
    /**
     * Filter which Clients to update
     */
    where?: ClientsWhereInput
  }

  /**
   * Clients upsert
   */
  export type ClientsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * The filter to search for the Clients to update in case it exists.
     */
    where: ClientsWhereUniqueInput
    /**
     * In case the Clients found by the `where` argument doesn't exist, create a new Clients with this data.
     */
    create: XOR<ClientsCreateInput, ClientsUncheckedCreateInput>
    /**
     * In case the Clients was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientsUpdateInput, ClientsUncheckedUpdateInput>
  }

  /**
   * Clients delete
   */
  export type ClientsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
    /**
     * Filter which Clients to delete.
     */
    where: ClientsWhereUniqueInput
  }

  /**
   * Clients deleteMany
   */
  export type ClientsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clients to delete
     */
    where?: ClientsWhereInput
  }

  /**
   * Clients.journeyPlans
   */
  export type Clients$journeyPlansArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    where?: JourneyPlanWhereInput
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    cursor?: JourneyPlanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JourneyPlanScalarFieldEnum | JourneyPlanScalarFieldEnum[]
  }

  /**
   * Clients.MyOrder
   */
  export type Clients$MyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    where?: MyOrderWhereInput
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    cursor?: MyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * Clients.products
   */
  export type Clients$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Clients.reports
   */
  export type Clients$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Clients.checkins
   */
  export type Clients$checkinsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    where?: ManagerCheckinWhereInput
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    cursor?: ManagerCheckinWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManagerCheckinScalarFieldEnum | ManagerCheckinScalarFieldEnum[]
  }

  /**
   * Clients without action
   */
  export type ClientsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clients
     */
    select?: ClientsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientsInclude<ExtArgs> | null
  }


  /**
   * Model Riders
   */

  export type AggregateRiders = {
    _count: RidersCountAggregateOutputType | null
    _avg: RidersAvgAggregateOutputType | null
    _sum: RidersSumAggregateOutputType | null
    _min: RidersMinAggregateOutputType | null
    _max: RidersMaxAggregateOutputType | null
  }

  export type RidersAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    status: number | null
  }

  export type RidersSumAggregateOutputType = {
    id: number | null
    company_id: number | null
    status: number | null
  }

  export type RidersMinAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    id_number: string | null
    company_id: number | null
    company: string | null
    status: number | null
    password: string | null
    device_id: string | null
    device_name: string | null
    device_status: string | null
    token: string | null
  }

  export type RidersMaxAggregateOutputType = {
    id: number | null
    name: string | null
    contact: string | null
    id_number: string | null
    company_id: number | null
    company: string | null
    status: number | null
    password: string | null
    device_id: string | null
    device_name: string | null
    device_status: string | null
    token: string | null
  }

  export type RidersCountAggregateOutputType = {
    id: number
    name: number
    contact: number
    id_number: number
    company_id: number
    company: number
    status: number
    password: number
    device_id: number
    device_name: number
    device_status: number
    token: number
    _all: number
  }


  export type RidersAvgAggregateInputType = {
    id?: true
    company_id?: true
    status?: true
  }

  export type RidersSumAggregateInputType = {
    id?: true
    company_id?: true
    status?: true
  }

  export type RidersMinAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    id_number?: true
    company_id?: true
    company?: true
    status?: true
    password?: true
    device_id?: true
    device_name?: true
    device_status?: true
    token?: true
  }

  export type RidersMaxAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    id_number?: true
    company_id?: true
    company?: true
    status?: true
    password?: true
    device_id?: true
    device_name?: true
    device_status?: true
    token?: true
  }

  export type RidersCountAggregateInputType = {
    id?: true
    name?: true
    contact?: true
    id_number?: true
    company_id?: true
    company?: true
    status?: true
    password?: true
    device_id?: true
    device_name?: true
    device_status?: true
    token?: true
    _all?: true
  }

  export type RidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Riders to aggregate.
     */
    where?: RidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riders to fetch.
     */
    orderBy?: RidersOrderByWithRelationInput | RidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Riders
    **/
    _count?: true | RidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RidersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RidersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RidersMaxAggregateInputType
  }

  export type GetRidersAggregateType<T extends RidersAggregateArgs> = {
        [P in keyof T & keyof AggregateRiders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiders[P]>
      : GetScalarType<T[P], AggregateRiders[P]>
  }




  export type RidersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RidersWhereInput
    orderBy?: RidersOrderByWithAggregationInput | RidersOrderByWithAggregationInput[]
    by: RidersScalarFieldEnum[] | RidersScalarFieldEnum
    having?: RidersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RidersCountAggregateInputType | true
    _avg?: RidersAvgAggregateInputType
    _sum?: RidersSumAggregateInputType
    _min?: RidersMinAggregateInputType
    _max?: RidersMaxAggregateInputType
  }

  export type RidersGroupByOutputType = {
    id: number
    name: string
    contact: string
    id_number: string
    company_id: number
    company: string
    status: number | null
    password: string | null
    device_id: string | null
    device_name: string | null
    device_status: string | null
    token: string | null
    _count: RidersCountAggregateOutputType | null
    _avg: RidersAvgAggregateOutputType | null
    _sum: RidersSumAggregateOutputType | null
    _min: RidersMinAggregateOutputType | null
    _max: RidersMaxAggregateOutputType | null
  }

  type GetRidersGroupByPayload<T extends RidersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RidersGroupByOutputType[P]>
            : GetScalarType<T[P], RidersGroupByOutputType[P]>
        }
      >
    >


  export type RidersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact?: boolean
    id_number?: boolean
    company_id?: boolean
    company?: boolean
    status?: boolean
    password?: boolean
    device_id?: boolean
    device_name?: boolean
    device_status?: boolean
    token?: boolean
  }, ExtArgs["result"]["riders"]>


  export type RidersSelectScalar = {
    id?: boolean
    name?: boolean
    contact?: boolean
    id_number?: boolean
    company_id?: boolean
    company?: boolean
    status?: boolean
    password?: boolean
    device_id?: boolean
    device_name?: boolean
    device_status?: boolean
    token?: boolean
  }


  export type $RidersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Riders"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      contact: string
      id_number: string
      company_id: number
      company: string
      status: number | null
      password: string | null
      device_id: string | null
      device_name: string | null
      device_status: string | null
      token: string | null
    }, ExtArgs["result"]["riders"]>
    composites: {}
  }

  type RidersGetPayload<S extends boolean | null | undefined | RidersDefaultArgs> = $Result.GetResult<Prisma.$RidersPayload, S>

  type RidersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RidersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RidersCountAggregateInputType | true
    }

  export interface RidersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Riders'], meta: { name: 'Riders' } }
    /**
     * Find zero or one Riders that matches the filter.
     * @param {RidersFindUniqueArgs} args - Arguments to find a Riders
     * @example
     * // Get one Riders
     * const riders = await prisma.riders.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RidersFindUniqueArgs>(args: SelectSubset<T, RidersFindUniqueArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Riders that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RidersFindUniqueOrThrowArgs} args - Arguments to find a Riders
     * @example
     * // Get one Riders
     * const riders = await prisma.riders.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RidersFindUniqueOrThrowArgs>(args: SelectSubset<T, RidersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Riders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersFindFirstArgs} args - Arguments to find a Riders
     * @example
     * // Get one Riders
     * const riders = await prisma.riders.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RidersFindFirstArgs>(args?: SelectSubset<T, RidersFindFirstArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Riders that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersFindFirstOrThrowArgs} args - Arguments to find a Riders
     * @example
     * // Get one Riders
     * const riders = await prisma.riders.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RidersFindFirstOrThrowArgs>(args?: SelectSubset<T, RidersFindFirstOrThrowArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Riders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Riders
     * const riders = await prisma.riders.findMany()
     * 
     * // Get first 10 Riders
     * const riders = await prisma.riders.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ridersWithIdOnly = await prisma.riders.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RidersFindManyArgs>(args?: SelectSubset<T, RidersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Riders.
     * @param {RidersCreateArgs} args - Arguments to create a Riders.
     * @example
     * // Create one Riders
     * const Riders = await prisma.riders.create({
     *   data: {
     *     // ... data to create a Riders
     *   }
     * })
     * 
     */
    create<T extends RidersCreateArgs>(args: SelectSubset<T, RidersCreateArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Riders.
     * @param {RidersCreateManyArgs} args - Arguments to create many Riders.
     * @example
     * // Create many Riders
     * const riders = await prisma.riders.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RidersCreateManyArgs>(args?: SelectSubset<T, RidersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Riders.
     * @param {RidersDeleteArgs} args - Arguments to delete one Riders.
     * @example
     * // Delete one Riders
     * const Riders = await prisma.riders.delete({
     *   where: {
     *     // ... filter to delete one Riders
     *   }
     * })
     * 
     */
    delete<T extends RidersDeleteArgs>(args: SelectSubset<T, RidersDeleteArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Riders.
     * @param {RidersUpdateArgs} args - Arguments to update one Riders.
     * @example
     * // Update one Riders
     * const riders = await prisma.riders.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RidersUpdateArgs>(args: SelectSubset<T, RidersUpdateArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Riders.
     * @param {RidersDeleteManyArgs} args - Arguments to filter Riders to delete.
     * @example
     * // Delete a few Riders
     * const { count } = await prisma.riders.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RidersDeleteManyArgs>(args?: SelectSubset<T, RidersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Riders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Riders
     * const riders = await prisma.riders.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RidersUpdateManyArgs>(args: SelectSubset<T, RidersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Riders.
     * @param {RidersUpsertArgs} args - Arguments to update or create a Riders.
     * @example
     * // Update or create a Riders
     * const riders = await prisma.riders.upsert({
     *   create: {
     *     // ... data to create a Riders
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Riders we want to update
     *   }
     * })
     */
    upsert<T extends RidersUpsertArgs>(args: SelectSubset<T, RidersUpsertArgs<ExtArgs>>): Prisma__RidersClient<$Result.GetResult<Prisma.$RidersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Riders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCountArgs} args - Arguments to filter Riders to count.
     * @example
     * // Count the number of Riders
     * const count = await prisma.riders.count({
     *   where: {
     *     // ... the filter for the Riders we want to count
     *   }
     * })
    **/
    count<T extends RidersCountArgs>(
      args?: Subset<T, RidersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Riders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RidersAggregateArgs>(args: Subset<T, RidersAggregateArgs>): Prisma.PrismaPromise<GetRidersAggregateType<T>>

    /**
     * Group by Riders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RidersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RidersGroupByArgs['orderBy'] }
        : { orderBy?: RidersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RidersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Riders model
   */
  readonly fields: RidersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Riders.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RidersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Riders model
   */ 
  interface RidersFieldRefs {
    readonly id: FieldRef<"Riders", 'Int'>
    readonly name: FieldRef<"Riders", 'String'>
    readonly contact: FieldRef<"Riders", 'String'>
    readonly id_number: FieldRef<"Riders", 'String'>
    readonly company_id: FieldRef<"Riders", 'Int'>
    readonly company: FieldRef<"Riders", 'String'>
    readonly status: FieldRef<"Riders", 'Int'>
    readonly password: FieldRef<"Riders", 'String'>
    readonly device_id: FieldRef<"Riders", 'String'>
    readonly device_name: FieldRef<"Riders", 'String'>
    readonly device_status: FieldRef<"Riders", 'String'>
    readonly token: FieldRef<"Riders", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Riders findUnique
   */
  export type RidersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter, which Riders to fetch.
     */
    where: RidersWhereUniqueInput
  }

  /**
   * Riders findUniqueOrThrow
   */
  export type RidersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter, which Riders to fetch.
     */
    where: RidersWhereUniqueInput
  }

  /**
   * Riders findFirst
   */
  export type RidersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter, which Riders to fetch.
     */
    where?: RidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riders to fetch.
     */
    orderBy?: RidersOrderByWithRelationInput | RidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Riders.
     */
    cursor?: RidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Riders.
     */
    distinct?: RidersScalarFieldEnum | RidersScalarFieldEnum[]
  }

  /**
   * Riders findFirstOrThrow
   */
  export type RidersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter, which Riders to fetch.
     */
    where?: RidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riders to fetch.
     */
    orderBy?: RidersOrderByWithRelationInput | RidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Riders.
     */
    cursor?: RidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Riders.
     */
    distinct?: RidersScalarFieldEnum | RidersScalarFieldEnum[]
  }

  /**
   * Riders findMany
   */
  export type RidersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter, which Riders to fetch.
     */
    where?: RidersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Riders to fetch.
     */
    orderBy?: RidersOrderByWithRelationInput | RidersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Riders.
     */
    cursor?: RidersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Riders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Riders.
     */
    skip?: number
    distinct?: RidersScalarFieldEnum | RidersScalarFieldEnum[]
  }

  /**
   * Riders create
   */
  export type RidersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * The data needed to create a Riders.
     */
    data: XOR<RidersCreateInput, RidersUncheckedCreateInput>
  }

  /**
   * Riders createMany
   */
  export type RidersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Riders.
     */
    data: RidersCreateManyInput | RidersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Riders update
   */
  export type RidersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * The data needed to update a Riders.
     */
    data: XOR<RidersUpdateInput, RidersUncheckedUpdateInput>
    /**
     * Choose, which Riders to update.
     */
    where: RidersWhereUniqueInput
  }

  /**
   * Riders updateMany
   */
  export type RidersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Riders.
     */
    data: XOR<RidersUpdateManyMutationInput, RidersUncheckedUpdateManyInput>
    /**
     * Filter which Riders to update
     */
    where?: RidersWhereInput
  }

  /**
   * Riders upsert
   */
  export type RidersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * The filter to search for the Riders to update in case it exists.
     */
    where: RidersWhereUniqueInput
    /**
     * In case the Riders found by the `where` argument doesn't exist, create a new Riders with this data.
     */
    create: XOR<RidersCreateInput, RidersUncheckedCreateInput>
    /**
     * In case the Riders was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RidersUpdateInput, RidersUncheckedUpdateInput>
  }

  /**
   * Riders delete
   */
  export type RidersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
    /**
     * Filter which Riders to delete.
     */
    where: RidersWhereUniqueInput
  }

  /**
   * Riders deleteMany
   */
  export type RidersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Riders to delete
     */
    where?: RidersWhereInput
  }

  /**
   * Riders without action
   */
  export type RidersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Riders
     */
    select?: RidersSelect<ExtArgs> | null
  }


  /**
   * Model RidersCompany
   */

  export type AggregateRidersCompany = {
    _count: RidersCompanyCountAggregateOutputType | null
    _avg: RidersCompanyAvgAggregateOutputType | null
    _sum: RidersCompanySumAggregateOutputType | null
    _min: RidersCompanyMinAggregateOutputType | null
    _max: RidersCompanyMaxAggregateOutputType | null
  }

  export type RidersCompanyAvgAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type RidersCompanySumAggregateOutputType = {
    id: number | null
    status: number | null
  }

  export type RidersCompanyMinAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
  }

  export type RidersCompanyMaxAggregateOutputType = {
    id: number | null
    name: string | null
    status: number | null
  }

  export type RidersCompanyCountAggregateOutputType = {
    id: number
    name: number
    status: number
    _all: number
  }


  export type RidersCompanyAvgAggregateInputType = {
    id?: true
    status?: true
  }

  export type RidersCompanySumAggregateInputType = {
    id?: true
    status?: true
  }

  export type RidersCompanyMinAggregateInputType = {
    id?: true
    name?: true
    status?: true
  }

  export type RidersCompanyMaxAggregateInputType = {
    id?: true
    name?: true
    status?: true
  }

  export type RidersCompanyCountAggregateInputType = {
    id?: true
    name?: true
    status?: true
    _all?: true
  }

  export type RidersCompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RidersCompany to aggregate.
     */
    where?: RidersCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RidersCompanies to fetch.
     */
    orderBy?: RidersCompanyOrderByWithRelationInput | RidersCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RidersCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RidersCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RidersCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RidersCompanies
    **/
    _count?: true | RidersCompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RidersCompanyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RidersCompanySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RidersCompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RidersCompanyMaxAggregateInputType
  }

  export type GetRidersCompanyAggregateType<T extends RidersCompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateRidersCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRidersCompany[P]>
      : GetScalarType<T[P], AggregateRidersCompany[P]>
  }




  export type RidersCompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RidersCompanyWhereInput
    orderBy?: RidersCompanyOrderByWithAggregationInput | RidersCompanyOrderByWithAggregationInput[]
    by: RidersCompanyScalarFieldEnum[] | RidersCompanyScalarFieldEnum
    having?: RidersCompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RidersCompanyCountAggregateInputType | true
    _avg?: RidersCompanyAvgAggregateInputType
    _sum?: RidersCompanySumAggregateInputType
    _min?: RidersCompanyMinAggregateInputType
    _max?: RidersCompanyMaxAggregateInputType
  }

  export type RidersCompanyGroupByOutputType = {
    id: number
    name: string
    status: number | null
    _count: RidersCompanyCountAggregateOutputType | null
    _avg: RidersCompanyAvgAggregateOutputType | null
    _sum: RidersCompanySumAggregateOutputType | null
    _min: RidersCompanyMinAggregateOutputType | null
    _max: RidersCompanyMaxAggregateOutputType | null
  }

  type GetRidersCompanyGroupByPayload<T extends RidersCompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RidersCompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RidersCompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RidersCompanyGroupByOutputType[P]>
            : GetScalarType<T[P], RidersCompanyGroupByOutputType[P]>
        }
      >
    >


  export type RidersCompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    status?: boolean
  }, ExtArgs["result"]["ridersCompany"]>


  export type RidersCompanySelectScalar = {
    id?: boolean
    name?: boolean
    status?: boolean
  }


  export type $RidersCompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RidersCompany"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      status: number | null
    }, ExtArgs["result"]["ridersCompany"]>
    composites: {}
  }

  type RidersCompanyGetPayload<S extends boolean | null | undefined | RidersCompanyDefaultArgs> = $Result.GetResult<Prisma.$RidersCompanyPayload, S>

  type RidersCompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RidersCompanyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RidersCompanyCountAggregateInputType | true
    }

  export interface RidersCompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RidersCompany'], meta: { name: 'RidersCompany' } }
    /**
     * Find zero or one RidersCompany that matches the filter.
     * @param {RidersCompanyFindUniqueArgs} args - Arguments to find a RidersCompany
     * @example
     * // Get one RidersCompany
     * const ridersCompany = await prisma.ridersCompany.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RidersCompanyFindUniqueArgs>(args: SelectSubset<T, RidersCompanyFindUniqueArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RidersCompany that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RidersCompanyFindUniqueOrThrowArgs} args - Arguments to find a RidersCompany
     * @example
     * // Get one RidersCompany
     * const ridersCompany = await prisma.ridersCompany.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RidersCompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, RidersCompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RidersCompany that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyFindFirstArgs} args - Arguments to find a RidersCompany
     * @example
     * // Get one RidersCompany
     * const ridersCompany = await prisma.ridersCompany.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RidersCompanyFindFirstArgs>(args?: SelectSubset<T, RidersCompanyFindFirstArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RidersCompany that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyFindFirstOrThrowArgs} args - Arguments to find a RidersCompany
     * @example
     * // Get one RidersCompany
     * const ridersCompany = await prisma.ridersCompany.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RidersCompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, RidersCompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RidersCompanies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RidersCompanies
     * const ridersCompanies = await prisma.ridersCompany.findMany()
     * 
     * // Get first 10 RidersCompanies
     * const ridersCompanies = await prisma.ridersCompany.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ridersCompanyWithIdOnly = await prisma.ridersCompany.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RidersCompanyFindManyArgs>(args?: SelectSubset<T, RidersCompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RidersCompany.
     * @param {RidersCompanyCreateArgs} args - Arguments to create a RidersCompany.
     * @example
     * // Create one RidersCompany
     * const RidersCompany = await prisma.ridersCompany.create({
     *   data: {
     *     // ... data to create a RidersCompany
     *   }
     * })
     * 
     */
    create<T extends RidersCompanyCreateArgs>(args: SelectSubset<T, RidersCompanyCreateArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RidersCompanies.
     * @param {RidersCompanyCreateManyArgs} args - Arguments to create many RidersCompanies.
     * @example
     * // Create many RidersCompanies
     * const ridersCompany = await prisma.ridersCompany.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RidersCompanyCreateManyArgs>(args?: SelectSubset<T, RidersCompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RidersCompany.
     * @param {RidersCompanyDeleteArgs} args - Arguments to delete one RidersCompany.
     * @example
     * // Delete one RidersCompany
     * const RidersCompany = await prisma.ridersCompany.delete({
     *   where: {
     *     // ... filter to delete one RidersCompany
     *   }
     * })
     * 
     */
    delete<T extends RidersCompanyDeleteArgs>(args: SelectSubset<T, RidersCompanyDeleteArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RidersCompany.
     * @param {RidersCompanyUpdateArgs} args - Arguments to update one RidersCompany.
     * @example
     * // Update one RidersCompany
     * const ridersCompany = await prisma.ridersCompany.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RidersCompanyUpdateArgs>(args: SelectSubset<T, RidersCompanyUpdateArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RidersCompanies.
     * @param {RidersCompanyDeleteManyArgs} args - Arguments to filter RidersCompanies to delete.
     * @example
     * // Delete a few RidersCompanies
     * const { count } = await prisma.ridersCompany.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RidersCompanyDeleteManyArgs>(args?: SelectSubset<T, RidersCompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RidersCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RidersCompanies
     * const ridersCompany = await prisma.ridersCompany.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RidersCompanyUpdateManyArgs>(args: SelectSubset<T, RidersCompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RidersCompany.
     * @param {RidersCompanyUpsertArgs} args - Arguments to update or create a RidersCompany.
     * @example
     * // Update or create a RidersCompany
     * const ridersCompany = await prisma.ridersCompany.upsert({
     *   create: {
     *     // ... data to create a RidersCompany
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RidersCompany we want to update
     *   }
     * })
     */
    upsert<T extends RidersCompanyUpsertArgs>(args: SelectSubset<T, RidersCompanyUpsertArgs<ExtArgs>>): Prisma__RidersCompanyClient<$Result.GetResult<Prisma.$RidersCompanyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RidersCompanies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyCountArgs} args - Arguments to filter RidersCompanies to count.
     * @example
     * // Count the number of RidersCompanies
     * const count = await prisma.ridersCompany.count({
     *   where: {
     *     // ... the filter for the RidersCompanies we want to count
     *   }
     * })
    **/
    count<T extends RidersCompanyCountArgs>(
      args?: Subset<T, RidersCompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RidersCompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RidersCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RidersCompanyAggregateArgs>(args: Subset<T, RidersCompanyAggregateArgs>): Prisma.PrismaPromise<GetRidersCompanyAggregateType<T>>

    /**
     * Group by RidersCompany.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RidersCompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RidersCompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RidersCompanyGroupByArgs['orderBy'] }
        : { orderBy?: RidersCompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RidersCompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRidersCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RidersCompany model
   */
  readonly fields: RidersCompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RidersCompany.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RidersCompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RidersCompany model
   */ 
  interface RidersCompanyFieldRefs {
    readonly id: FieldRef<"RidersCompany", 'Int'>
    readonly name: FieldRef<"RidersCompany", 'String'>
    readonly status: FieldRef<"RidersCompany", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * RidersCompany findUnique
   */
  export type RidersCompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter, which RidersCompany to fetch.
     */
    where: RidersCompanyWhereUniqueInput
  }

  /**
   * RidersCompany findUniqueOrThrow
   */
  export type RidersCompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter, which RidersCompany to fetch.
     */
    where: RidersCompanyWhereUniqueInput
  }

  /**
   * RidersCompany findFirst
   */
  export type RidersCompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter, which RidersCompany to fetch.
     */
    where?: RidersCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RidersCompanies to fetch.
     */
    orderBy?: RidersCompanyOrderByWithRelationInput | RidersCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RidersCompanies.
     */
    cursor?: RidersCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RidersCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RidersCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RidersCompanies.
     */
    distinct?: RidersCompanyScalarFieldEnum | RidersCompanyScalarFieldEnum[]
  }

  /**
   * RidersCompany findFirstOrThrow
   */
  export type RidersCompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter, which RidersCompany to fetch.
     */
    where?: RidersCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RidersCompanies to fetch.
     */
    orderBy?: RidersCompanyOrderByWithRelationInput | RidersCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RidersCompanies.
     */
    cursor?: RidersCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RidersCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RidersCompanies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RidersCompanies.
     */
    distinct?: RidersCompanyScalarFieldEnum | RidersCompanyScalarFieldEnum[]
  }

  /**
   * RidersCompany findMany
   */
  export type RidersCompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter, which RidersCompanies to fetch.
     */
    where?: RidersCompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RidersCompanies to fetch.
     */
    orderBy?: RidersCompanyOrderByWithRelationInput | RidersCompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RidersCompanies.
     */
    cursor?: RidersCompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RidersCompanies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RidersCompanies.
     */
    skip?: number
    distinct?: RidersCompanyScalarFieldEnum | RidersCompanyScalarFieldEnum[]
  }

  /**
   * RidersCompany create
   */
  export type RidersCompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * The data needed to create a RidersCompany.
     */
    data: XOR<RidersCompanyCreateInput, RidersCompanyUncheckedCreateInput>
  }

  /**
   * RidersCompany createMany
   */
  export type RidersCompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RidersCompanies.
     */
    data: RidersCompanyCreateManyInput | RidersCompanyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RidersCompany update
   */
  export type RidersCompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * The data needed to update a RidersCompany.
     */
    data: XOR<RidersCompanyUpdateInput, RidersCompanyUncheckedUpdateInput>
    /**
     * Choose, which RidersCompany to update.
     */
    where: RidersCompanyWhereUniqueInput
  }

  /**
   * RidersCompany updateMany
   */
  export type RidersCompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RidersCompanies.
     */
    data: XOR<RidersCompanyUpdateManyMutationInput, RidersCompanyUncheckedUpdateManyInput>
    /**
     * Filter which RidersCompanies to update
     */
    where?: RidersCompanyWhereInput
  }

  /**
   * RidersCompany upsert
   */
  export type RidersCompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * The filter to search for the RidersCompany to update in case it exists.
     */
    where: RidersCompanyWhereUniqueInput
    /**
     * In case the RidersCompany found by the `where` argument doesn't exist, create a new RidersCompany with this data.
     */
    create: XOR<RidersCompanyCreateInput, RidersCompanyUncheckedCreateInput>
    /**
     * In case the RidersCompany was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RidersCompanyUpdateInput, RidersCompanyUncheckedUpdateInput>
  }

  /**
   * RidersCompany delete
   */
  export type RidersCompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
    /**
     * Filter which RidersCompany to delete.
     */
    where: RidersCompanyWhereUniqueInput
  }

  /**
   * RidersCompany deleteMany
   */
  export type RidersCompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RidersCompanies to delete
     */
    where?: RidersCompanyWhereInput
  }

  /**
   * RidersCompany without action
   */
  export type RidersCompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RidersCompany
     */
    select?: RidersCompanySelect<ExtArgs> | null
  }


  /**
   * Model ManagerCheckin
   */

  export type AggregateManagerCheckin = {
    _count: ManagerCheckinCountAggregateOutputType | null
    _avg: ManagerCheckinAvgAggregateOutputType | null
    _sum: ManagerCheckinSumAggregateOutputType | null
    _min: ManagerCheckinMinAggregateOutputType | null
    _max: ManagerCheckinMaxAggregateOutputType | null
  }

  export type ManagerCheckinAvgAggregateOutputType = {
    id: number | null
    managerId: number | null
    clientId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ManagerCheckinSumAggregateOutputType = {
    id: number | null
    managerId: number | null
    clientId: number | null
    latitude: number | null
    longitude: number | null
  }

  export type ManagerCheckinMinAggregateOutputType = {
    id: number | null
    managerId: number | null
    clientId: number | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    notes: string | null
  }

  export type ManagerCheckinMaxAggregateOutputType = {
    id: number | null
    managerId: number | null
    clientId: number | null
    date: Date | null
    checkInAt: Date | null
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    notes: string | null
  }

  export type ManagerCheckinCountAggregateOutputType = {
    id: number
    managerId: number
    clientId: number
    date: number
    checkInAt: number
    checkOutAt: number
    latitude: number
    longitude: number
    notes: number
    _all: number
  }


  export type ManagerCheckinAvgAggregateInputType = {
    id?: true
    managerId?: true
    clientId?: true
    latitude?: true
    longitude?: true
  }

  export type ManagerCheckinSumAggregateInputType = {
    id?: true
    managerId?: true
    clientId?: true
    latitude?: true
    longitude?: true
  }

  export type ManagerCheckinMinAggregateInputType = {
    id?: true
    managerId?: true
    clientId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    notes?: true
  }

  export type ManagerCheckinMaxAggregateInputType = {
    id?: true
    managerId?: true
    clientId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    notes?: true
  }

  export type ManagerCheckinCountAggregateInputType = {
    id?: true
    managerId?: true
    clientId?: true
    date?: true
    checkInAt?: true
    checkOutAt?: true
    latitude?: true
    longitude?: true
    notes?: true
    _all?: true
  }

  export type ManagerCheckinAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManagerCheckin to aggregate.
     */
    where?: ManagerCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerCheckins to fetch.
     */
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ManagerCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ManagerCheckins
    **/
    _count?: true | ManagerCheckinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManagerCheckinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManagerCheckinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManagerCheckinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManagerCheckinMaxAggregateInputType
  }

  export type GetManagerCheckinAggregateType<T extends ManagerCheckinAggregateArgs> = {
        [P in keyof T & keyof AggregateManagerCheckin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManagerCheckin[P]>
      : GetScalarType<T[P], AggregateManagerCheckin[P]>
  }




  export type ManagerCheckinGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ManagerCheckinWhereInput
    orderBy?: ManagerCheckinOrderByWithAggregationInput | ManagerCheckinOrderByWithAggregationInput[]
    by: ManagerCheckinScalarFieldEnum[] | ManagerCheckinScalarFieldEnum
    having?: ManagerCheckinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManagerCheckinCountAggregateInputType | true
    _avg?: ManagerCheckinAvgAggregateInputType
    _sum?: ManagerCheckinSumAggregateInputType
    _min?: ManagerCheckinMinAggregateInputType
    _max?: ManagerCheckinMaxAggregateInputType
  }

  export type ManagerCheckinGroupByOutputType = {
    id: number
    managerId: number
    clientId: number
    date: Date
    checkInAt: Date | null
    checkOutAt: Date | null
    latitude: number | null
    longitude: number | null
    notes: string | null
    _count: ManagerCheckinCountAggregateOutputType | null
    _avg: ManagerCheckinAvgAggregateOutputType | null
    _sum: ManagerCheckinSumAggregateOutputType | null
    _min: ManagerCheckinMinAggregateOutputType | null
    _max: ManagerCheckinMaxAggregateOutputType | null
  }

  type GetManagerCheckinGroupByPayload<T extends ManagerCheckinGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManagerCheckinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManagerCheckinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManagerCheckinGroupByOutputType[P]>
            : GetScalarType<T[P], ManagerCheckinGroupByOutputType[P]>
        }
      >
    >


  export type ManagerCheckinSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    managerId?: boolean
    clientId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    client?: boolean | ClientsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["managerCheckin"]>


  export type ManagerCheckinSelectScalar = {
    id?: boolean
    managerId?: boolean
    clientId?: boolean
    date?: boolean
    checkInAt?: boolean
    checkOutAt?: boolean
    latitude?: boolean
    longitude?: boolean
    notes?: boolean
  }

  export type ManagerCheckinInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    manager?: boolean | ManagerDefaultArgs<ExtArgs>
    client?: boolean | ClientsDefaultArgs<ExtArgs>
  }

  export type $ManagerCheckinPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ManagerCheckin"
    objects: {
      manager: Prisma.$ManagerPayload<ExtArgs>
      client: Prisma.$ClientsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      managerId: number
      clientId: number
      date: Date
      checkInAt: Date | null
      checkOutAt: Date | null
      latitude: number | null
      longitude: number | null
      notes: string | null
    }, ExtArgs["result"]["managerCheckin"]>
    composites: {}
  }

  type ManagerCheckinGetPayload<S extends boolean | null | undefined | ManagerCheckinDefaultArgs> = $Result.GetResult<Prisma.$ManagerCheckinPayload, S>

  type ManagerCheckinCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ManagerCheckinFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ManagerCheckinCountAggregateInputType | true
    }

  export interface ManagerCheckinDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ManagerCheckin'], meta: { name: 'ManagerCheckin' } }
    /**
     * Find zero or one ManagerCheckin that matches the filter.
     * @param {ManagerCheckinFindUniqueArgs} args - Arguments to find a ManagerCheckin
     * @example
     * // Get one ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ManagerCheckinFindUniqueArgs>(args: SelectSubset<T, ManagerCheckinFindUniqueArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ManagerCheckin that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ManagerCheckinFindUniqueOrThrowArgs} args - Arguments to find a ManagerCheckin
     * @example
     * // Get one ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ManagerCheckinFindUniqueOrThrowArgs>(args: SelectSubset<T, ManagerCheckinFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ManagerCheckin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinFindFirstArgs} args - Arguments to find a ManagerCheckin
     * @example
     * // Get one ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ManagerCheckinFindFirstArgs>(args?: SelectSubset<T, ManagerCheckinFindFirstArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ManagerCheckin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinFindFirstOrThrowArgs} args - Arguments to find a ManagerCheckin
     * @example
     * // Get one ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ManagerCheckinFindFirstOrThrowArgs>(args?: SelectSubset<T, ManagerCheckinFindFirstOrThrowArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ManagerCheckins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ManagerCheckins
     * const managerCheckins = await prisma.managerCheckin.findMany()
     * 
     * // Get first 10 ManagerCheckins
     * const managerCheckins = await prisma.managerCheckin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const managerCheckinWithIdOnly = await prisma.managerCheckin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ManagerCheckinFindManyArgs>(args?: SelectSubset<T, ManagerCheckinFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ManagerCheckin.
     * @param {ManagerCheckinCreateArgs} args - Arguments to create a ManagerCheckin.
     * @example
     * // Create one ManagerCheckin
     * const ManagerCheckin = await prisma.managerCheckin.create({
     *   data: {
     *     // ... data to create a ManagerCheckin
     *   }
     * })
     * 
     */
    create<T extends ManagerCheckinCreateArgs>(args: SelectSubset<T, ManagerCheckinCreateArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ManagerCheckins.
     * @param {ManagerCheckinCreateManyArgs} args - Arguments to create many ManagerCheckins.
     * @example
     * // Create many ManagerCheckins
     * const managerCheckin = await prisma.managerCheckin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ManagerCheckinCreateManyArgs>(args?: SelectSubset<T, ManagerCheckinCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ManagerCheckin.
     * @param {ManagerCheckinDeleteArgs} args - Arguments to delete one ManagerCheckin.
     * @example
     * // Delete one ManagerCheckin
     * const ManagerCheckin = await prisma.managerCheckin.delete({
     *   where: {
     *     // ... filter to delete one ManagerCheckin
     *   }
     * })
     * 
     */
    delete<T extends ManagerCheckinDeleteArgs>(args: SelectSubset<T, ManagerCheckinDeleteArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ManagerCheckin.
     * @param {ManagerCheckinUpdateArgs} args - Arguments to update one ManagerCheckin.
     * @example
     * // Update one ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ManagerCheckinUpdateArgs>(args: SelectSubset<T, ManagerCheckinUpdateArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ManagerCheckins.
     * @param {ManagerCheckinDeleteManyArgs} args - Arguments to filter ManagerCheckins to delete.
     * @example
     * // Delete a few ManagerCheckins
     * const { count } = await prisma.managerCheckin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ManagerCheckinDeleteManyArgs>(args?: SelectSubset<T, ManagerCheckinDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ManagerCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ManagerCheckins
     * const managerCheckin = await prisma.managerCheckin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ManagerCheckinUpdateManyArgs>(args: SelectSubset<T, ManagerCheckinUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ManagerCheckin.
     * @param {ManagerCheckinUpsertArgs} args - Arguments to update or create a ManagerCheckin.
     * @example
     * // Update or create a ManagerCheckin
     * const managerCheckin = await prisma.managerCheckin.upsert({
     *   create: {
     *     // ... data to create a ManagerCheckin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ManagerCheckin we want to update
     *   }
     * })
     */
    upsert<T extends ManagerCheckinUpsertArgs>(args: SelectSubset<T, ManagerCheckinUpsertArgs<ExtArgs>>): Prisma__ManagerCheckinClient<$Result.GetResult<Prisma.$ManagerCheckinPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ManagerCheckins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinCountArgs} args - Arguments to filter ManagerCheckins to count.
     * @example
     * // Count the number of ManagerCheckins
     * const count = await prisma.managerCheckin.count({
     *   where: {
     *     // ... the filter for the ManagerCheckins we want to count
     *   }
     * })
    **/
    count<T extends ManagerCheckinCountArgs>(
      args?: Subset<T, ManagerCheckinCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManagerCheckinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ManagerCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManagerCheckinAggregateArgs>(args: Subset<T, ManagerCheckinAggregateArgs>): Prisma.PrismaPromise<GetManagerCheckinAggregateType<T>>

    /**
     * Group by ManagerCheckin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManagerCheckinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManagerCheckinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManagerCheckinGroupByArgs['orderBy'] }
        : { orderBy?: ManagerCheckinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManagerCheckinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManagerCheckinGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ManagerCheckin model
   */
  readonly fields: ManagerCheckinFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ManagerCheckin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ManagerCheckinClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    manager<T extends ManagerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ManagerDefaultArgs<ExtArgs>>): Prisma__ManagerClient<$Result.GetResult<Prisma.$ManagerPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientsDefaultArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ManagerCheckin model
   */ 
  interface ManagerCheckinFieldRefs {
    readonly id: FieldRef<"ManagerCheckin", 'Int'>
    readonly managerId: FieldRef<"ManagerCheckin", 'Int'>
    readonly clientId: FieldRef<"ManagerCheckin", 'Int'>
    readonly date: FieldRef<"ManagerCheckin", 'DateTime'>
    readonly checkInAt: FieldRef<"ManagerCheckin", 'DateTime'>
    readonly checkOutAt: FieldRef<"ManagerCheckin", 'DateTime'>
    readonly latitude: FieldRef<"ManagerCheckin", 'Float'>
    readonly longitude: FieldRef<"ManagerCheckin", 'Float'>
    readonly notes: FieldRef<"ManagerCheckin", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ManagerCheckin findUnique
   */
  export type ManagerCheckinFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter, which ManagerCheckin to fetch.
     */
    where: ManagerCheckinWhereUniqueInput
  }

  /**
   * ManagerCheckin findUniqueOrThrow
   */
  export type ManagerCheckinFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter, which ManagerCheckin to fetch.
     */
    where: ManagerCheckinWhereUniqueInput
  }

  /**
   * ManagerCheckin findFirst
   */
  export type ManagerCheckinFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter, which ManagerCheckin to fetch.
     */
    where?: ManagerCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerCheckins to fetch.
     */
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManagerCheckins.
     */
    cursor?: ManagerCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManagerCheckins.
     */
    distinct?: ManagerCheckinScalarFieldEnum | ManagerCheckinScalarFieldEnum[]
  }

  /**
   * ManagerCheckin findFirstOrThrow
   */
  export type ManagerCheckinFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter, which ManagerCheckin to fetch.
     */
    where?: ManagerCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerCheckins to fetch.
     */
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ManagerCheckins.
     */
    cursor?: ManagerCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerCheckins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ManagerCheckins.
     */
    distinct?: ManagerCheckinScalarFieldEnum | ManagerCheckinScalarFieldEnum[]
  }

  /**
   * ManagerCheckin findMany
   */
  export type ManagerCheckinFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter, which ManagerCheckins to fetch.
     */
    where?: ManagerCheckinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ManagerCheckins to fetch.
     */
    orderBy?: ManagerCheckinOrderByWithRelationInput | ManagerCheckinOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ManagerCheckins.
     */
    cursor?: ManagerCheckinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ManagerCheckins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ManagerCheckins.
     */
    skip?: number
    distinct?: ManagerCheckinScalarFieldEnum | ManagerCheckinScalarFieldEnum[]
  }

  /**
   * ManagerCheckin create
   */
  export type ManagerCheckinCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * The data needed to create a ManagerCheckin.
     */
    data: XOR<ManagerCheckinCreateInput, ManagerCheckinUncheckedCreateInput>
  }

  /**
   * ManagerCheckin createMany
   */
  export type ManagerCheckinCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ManagerCheckins.
     */
    data: ManagerCheckinCreateManyInput | ManagerCheckinCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ManagerCheckin update
   */
  export type ManagerCheckinUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * The data needed to update a ManagerCheckin.
     */
    data: XOR<ManagerCheckinUpdateInput, ManagerCheckinUncheckedUpdateInput>
    /**
     * Choose, which ManagerCheckin to update.
     */
    where: ManagerCheckinWhereUniqueInput
  }

  /**
   * ManagerCheckin updateMany
   */
  export type ManagerCheckinUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ManagerCheckins.
     */
    data: XOR<ManagerCheckinUpdateManyMutationInput, ManagerCheckinUncheckedUpdateManyInput>
    /**
     * Filter which ManagerCheckins to update
     */
    where?: ManagerCheckinWhereInput
  }

  /**
   * ManagerCheckin upsert
   */
  export type ManagerCheckinUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * The filter to search for the ManagerCheckin to update in case it exists.
     */
    where: ManagerCheckinWhereUniqueInput
    /**
     * In case the ManagerCheckin found by the `where` argument doesn't exist, create a new ManagerCheckin with this data.
     */
    create: XOR<ManagerCheckinCreateInput, ManagerCheckinUncheckedCreateInput>
    /**
     * In case the ManagerCheckin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ManagerCheckinUpdateInput, ManagerCheckinUncheckedUpdateInput>
  }

  /**
   * ManagerCheckin delete
   */
  export type ManagerCheckinDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
    /**
     * Filter which ManagerCheckin to delete.
     */
    where: ManagerCheckinWhereUniqueInput
  }

  /**
   * ManagerCheckin deleteMany
   */
  export type ManagerCheckinDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ManagerCheckins to delete
     */
    where?: ManagerCheckinWhereInput
  }

  /**
   * ManagerCheckin without action
   */
  export type ManagerCheckinDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ManagerCheckin
     */
    select?: ManagerCheckinSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ManagerCheckinInclude<ExtArgs> | null
  }


  /**
   * Model MyOrder
   */

  export type AggregateMyOrder = {
    _count: MyOrderCountAggregateOutputType | null
    _avg: MyOrderAvgAggregateOutputType | null
    _sum: MyOrderSumAggregateOutputType | null
    _min: MyOrderMinAggregateOutputType | null
    _max: MyOrderMaxAggregateOutputType | null
  }

  export type MyOrderAvgAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    riderId: number | null
    status: number | null
    userId: number | null
    clientId: number | null
  }

  export type MyOrderSumAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    riderId: number | null
    status: number | null
    userId: number | null
    clientId: number | null
  }

  export type MyOrderMinAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    comment: string | null
    customerType: string | null
    customerId: string | null
    customerName: string | null
    orderDate: Date | null
    riderId: number | null
    riderName: string | null
    status: number | null
    approvedTime: string | null
    dispatchTime: string | null
    deliveryLocation: string | null
    complete_latitude: string | null
    complete_longitude: string | null
    complete_address: string | null
    pickupTime: string | null
    deliveryTime: string | null
    cancel_reason: string | null
    recepient: string | null
    userId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MyOrderMaxAggregateOutputType = {
    id: number | null
    totalAmount: number | null
    comment: string | null
    customerType: string | null
    customerId: string | null
    customerName: string | null
    orderDate: Date | null
    riderId: number | null
    riderName: string | null
    status: number | null
    approvedTime: string | null
    dispatchTime: string | null
    deliveryLocation: string | null
    complete_latitude: string | null
    complete_longitude: string | null
    complete_address: string | null
    pickupTime: string | null
    deliveryTime: string | null
    cancel_reason: string | null
    recepient: string | null
    userId: number | null
    clientId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MyOrderCountAggregateOutputType = {
    id: number
    totalAmount: number
    comment: number
    customerType: number
    customerId: number
    customerName: number
    orderDate: number
    riderId: number
    riderName: number
    status: number
    approvedTime: number
    dispatchTime: number
    deliveryLocation: number
    complete_latitude: number
    complete_longitude: number
    complete_address: number
    pickupTime: number
    deliveryTime: number
    cancel_reason: number
    recepient: number
    userId: number
    clientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MyOrderAvgAggregateInputType = {
    id?: true
    totalAmount?: true
    riderId?: true
    status?: true
    userId?: true
    clientId?: true
  }

  export type MyOrderSumAggregateInputType = {
    id?: true
    totalAmount?: true
    riderId?: true
    status?: true
    userId?: true
    clientId?: true
  }

  export type MyOrderMinAggregateInputType = {
    id?: true
    totalAmount?: true
    comment?: true
    customerType?: true
    customerId?: true
    customerName?: true
    orderDate?: true
    riderId?: true
    riderName?: true
    status?: true
    approvedTime?: true
    dispatchTime?: true
    deliveryLocation?: true
    complete_latitude?: true
    complete_longitude?: true
    complete_address?: true
    pickupTime?: true
    deliveryTime?: true
    cancel_reason?: true
    recepient?: true
    userId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MyOrderMaxAggregateInputType = {
    id?: true
    totalAmount?: true
    comment?: true
    customerType?: true
    customerId?: true
    customerName?: true
    orderDate?: true
    riderId?: true
    riderName?: true
    status?: true
    approvedTime?: true
    dispatchTime?: true
    deliveryLocation?: true
    complete_latitude?: true
    complete_longitude?: true
    complete_address?: true
    pickupTime?: true
    deliveryTime?: true
    cancel_reason?: true
    recepient?: true
    userId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MyOrderCountAggregateInputType = {
    id?: true
    totalAmount?: true
    comment?: true
    customerType?: true
    customerId?: true
    customerName?: true
    orderDate?: true
    riderId?: true
    riderName?: true
    status?: true
    approvedTime?: true
    dispatchTime?: true
    deliveryLocation?: true
    complete_latitude?: true
    complete_longitude?: true
    complete_address?: true
    pickupTime?: true
    deliveryTime?: true
    cancel_reason?: true
    recepient?: true
    userId?: true
    clientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MyOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MyOrder to aggregate.
     */
    where?: MyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyOrders to fetch.
     */
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MyOrders
    **/
    _count?: true | MyOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MyOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MyOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MyOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MyOrderMaxAggregateInputType
  }

  export type GetMyOrderAggregateType<T extends MyOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateMyOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMyOrder[P]>
      : GetScalarType<T[P], AggregateMyOrder[P]>
  }




  export type MyOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MyOrderWhereInput
    orderBy?: MyOrderOrderByWithAggregationInput | MyOrderOrderByWithAggregationInput[]
    by: MyOrderScalarFieldEnum[] | MyOrderScalarFieldEnum
    having?: MyOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MyOrderCountAggregateInputType | true
    _avg?: MyOrderAvgAggregateInputType
    _sum?: MyOrderSumAggregateInputType
    _min?: MyOrderMinAggregateInputType
    _max?: MyOrderMaxAggregateInputType
  }

  export type MyOrderGroupByOutputType = {
    id: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate: Date
    riderId: number | null
    riderName: string | null
    status: number
    approvedTime: string | null
    dispatchTime: string | null
    deliveryLocation: string | null
    complete_latitude: string | null
    complete_longitude: string | null
    complete_address: string | null
    pickupTime: string | null
    deliveryTime: string | null
    cancel_reason: string | null
    recepient: string | null
    userId: number
    clientId: number
    createdAt: Date
    updatedAt: Date
    _count: MyOrderCountAggregateOutputType | null
    _avg: MyOrderAvgAggregateOutputType | null
    _sum: MyOrderSumAggregateOutputType | null
    _min: MyOrderMinAggregateOutputType | null
    _max: MyOrderMaxAggregateOutputType | null
  }

  type GetMyOrderGroupByPayload<T extends MyOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MyOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MyOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MyOrderGroupByOutputType[P]>
            : GetScalarType<T[P], MyOrderGroupByOutputType[P]>
        }
      >
    >


  export type MyOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    totalAmount?: boolean
    comment?: boolean
    customerType?: boolean
    customerId?: boolean
    customerName?: boolean
    orderDate?: boolean
    riderId?: boolean
    riderName?: boolean
    status?: boolean
    approvedTime?: boolean
    dispatchTime?: boolean
    deliveryLocation?: boolean
    complete_latitude?: boolean
    complete_longitude?: boolean
    complete_address?: boolean
    pickupTime?: boolean
    deliveryTime?: boolean
    cancel_reason?: boolean
    recepient?: boolean
    userId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    orderItems?: boolean | MyOrder$orderItemsArgs<ExtArgs>
    reports?: boolean | MyOrder$reportsArgs<ExtArgs>
    _count?: boolean | MyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["myOrder"]>


  export type MyOrderSelectScalar = {
    id?: boolean
    totalAmount?: boolean
    comment?: boolean
    customerType?: boolean
    customerId?: boolean
    customerName?: boolean
    orderDate?: boolean
    riderId?: boolean
    riderName?: boolean
    status?: boolean
    approvedTime?: boolean
    dispatchTime?: boolean
    deliveryLocation?: boolean
    complete_latitude?: boolean
    complete_longitude?: boolean
    complete_address?: boolean
    pickupTime?: boolean
    deliveryTime?: boolean
    cancel_reason?: boolean
    recepient?: boolean
    userId?: boolean
    clientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MyOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    orderItems?: boolean | MyOrder$orderItemsArgs<ExtArgs>
    reports?: boolean | MyOrder$reportsArgs<ExtArgs>
    _count?: boolean | MyOrderCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $MyOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MyOrder"
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs>
      user: Prisma.$SalesRepPayload<ExtArgs>
      orderItems: Prisma.$OrderItemPayload<ExtArgs>[]
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      totalAmount: number
      comment: string
      customerType: string
      customerId: string
      customerName: string
      orderDate: Date
      riderId: number | null
      riderName: string | null
      status: number
      approvedTime: string | null
      dispatchTime: string | null
      deliveryLocation: string | null
      complete_latitude: string | null
      complete_longitude: string | null
      complete_address: string | null
      pickupTime: string | null
      deliveryTime: string | null
      cancel_reason: string | null
      recepient: string | null
      userId: number
      clientId: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["myOrder"]>
    composites: {}
  }

  type MyOrderGetPayload<S extends boolean | null | undefined | MyOrderDefaultArgs> = $Result.GetResult<Prisma.$MyOrderPayload, S>

  type MyOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MyOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MyOrderCountAggregateInputType | true
    }

  export interface MyOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MyOrder'], meta: { name: 'MyOrder' } }
    /**
     * Find zero or one MyOrder that matches the filter.
     * @param {MyOrderFindUniqueArgs} args - Arguments to find a MyOrder
     * @example
     * // Get one MyOrder
     * const myOrder = await prisma.myOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MyOrderFindUniqueArgs>(args: SelectSubset<T, MyOrderFindUniqueArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MyOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MyOrderFindUniqueOrThrowArgs} args - Arguments to find a MyOrder
     * @example
     * // Get one MyOrder
     * const myOrder = await prisma.myOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MyOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, MyOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MyOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderFindFirstArgs} args - Arguments to find a MyOrder
     * @example
     * // Get one MyOrder
     * const myOrder = await prisma.myOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MyOrderFindFirstArgs>(args?: SelectSubset<T, MyOrderFindFirstArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MyOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderFindFirstOrThrowArgs} args - Arguments to find a MyOrder
     * @example
     * // Get one MyOrder
     * const myOrder = await prisma.myOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MyOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, MyOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MyOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MyOrders
     * const myOrders = await prisma.myOrder.findMany()
     * 
     * // Get first 10 MyOrders
     * const myOrders = await prisma.myOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const myOrderWithIdOnly = await prisma.myOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MyOrderFindManyArgs>(args?: SelectSubset<T, MyOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MyOrder.
     * @param {MyOrderCreateArgs} args - Arguments to create a MyOrder.
     * @example
     * // Create one MyOrder
     * const MyOrder = await prisma.myOrder.create({
     *   data: {
     *     // ... data to create a MyOrder
     *   }
     * })
     * 
     */
    create<T extends MyOrderCreateArgs>(args: SelectSubset<T, MyOrderCreateArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MyOrders.
     * @param {MyOrderCreateManyArgs} args - Arguments to create many MyOrders.
     * @example
     * // Create many MyOrders
     * const myOrder = await prisma.myOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MyOrderCreateManyArgs>(args?: SelectSubset<T, MyOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a MyOrder.
     * @param {MyOrderDeleteArgs} args - Arguments to delete one MyOrder.
     * @example
     * // Delete one MyOrder
     * const MyOrder = await prisma.myOrder.delete({
     *   where: {
     *     // ... filter to delete one MyOrder
     *   }
     * })
     * 
     */
    delete<T extends MyOrderDeleteArgs>(args: SelectSubset<T, MyOrderDeleteArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MyOrder.
     * @param {MyOrderUpdateArgs} args - Arguments to update one MyOrder.
     * @example
     * // Update one MyOrder
     * const myOrder = await prisma.myOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MyOrderUpdateArgs>(args: SelectSubset<T, MyOrderUpdateArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MyOrders.
     * @param {MyOrderDeleteManyArgs} args - Arguments to filter MyOrders to delete.
     * @example
     * // Delete a few MyOrders
     * const { count } = await prisma.myOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MyOrderDeleteManyArgs>(args?: SelectSubset<T, MyOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MyOrders
     * const myOrder = await prisma.myOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MyOrderUpdateManyArgs>(args: SelectSubset<T, MyOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MyOrder.
     * @param {MyOrderUpsertArgs} args - Arguments to update or create a MyOrder.
     * @example
     * // Update or create a MyOrder
     * const myOrder = await prisma.myOrder.upsert({
     *   create: {
     *     // ... data to create a MyOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MyOrder we want to update
     *   }
     * })
     */
    upsert<T extends MyOrderUpsertArgs>(args: SelectSubset<T, MyOrderUpsertArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MyOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderCountArgs} args - Arguments to filter MyOrders to count.
     * @example
     * // Count the number of MyOrders
     * const count = await prisma.myOrder.count({
     *   where: {
     *     // ... the filter for the MyOrders we want to count
     *   }
     * })
    **/
    count<T extends MyOrderCountArgs>(
      args?: Subset<T, MyOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MyOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MyOrderAggregateArgs>(args: Subset<T, MyOrderAggregateArgs>): Prisma.PrismaPromise<GetMyOrderAggregateType<T>>

    /**
     * Group by MyOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MyOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MyOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MyOrderGroupByArgs['orderBy'] }
        : { orderBy?: MyOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MyOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMyOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MyOrder model
   */
  readonly fields: MyOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MyOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MyOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientsDefaultArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends SalesRepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesRepDefaultArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    orderItems<T extends MyOrder$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, MyOrder$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    reports<T extends MyOrder$reportsArgs<ExtArgs> = {}>(args?: Subset<T, MyOrder$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MyOrder model
   */ 
  interface MyOrderFieldRefs {
    readonly id: FieldRef<"MyOrder", 'Int'>
    readonly totalAmount: FieldRef<"MyOrder", 'Float'>
    readonly comment: FieldRef<"MyOrder", 'String'>
    readonly customerType: FieldRef<"MyOrder", 'String'>
    readonly customerId: FieldRef<"MyOrder", 'String'>
    readonly customerName: FieldRef<"MyOrder", 'String'>
    readonly orderDate: FieldRef<"MyOrder", 'DateTime'>
    readonly riderId: FieldRef<"MyOrder", 'Int'>
    readonly riderName: FieldRef<"MyOrder", 'String'>
    readonly status: FieldRef<"MyOrder", 'Int'>
    readonly approvedTime: FieldRef<"MyOrder", 'String'>
    readonly dispatchTime: FieldRef<"MyOrder", 'String'>
    readonly deliveryLocation: FieldRef<"MyOrder", 'String'>
    readonly complete_latitude: FieldRef<"MyOrder", 'String'>
    readonly complete_longitude: FieldRef<"MyOrder", 'String'>
    readonly complete_address: FieldRef<"MyOrder", 'String'>
    readonly pickupTime: FieldRef<"MyOrder", 'String'>
    readonly deliveryTime: FieldRef<"MyOrder", 'String'>
    readonly cancel_reason: FieldRef<"MyOrder", 'String'>
    readonly recepient: FieldRef<"MyOrder", 'String'>
    readonly userId: FieldRef<"MyOrder", 'Int'>
    readonly clientId: FieldRef<"MyOrder", 'Int'>
    readonly createdAt: FieldRef<"MyOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"MyOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MyOrder findUnique
   */
  export type MyOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter, which MyOrder to fetch.
     */
    where: MyOrderWhereUniqueInput
  }

  /**
   * MyOrder findUniqueOrThrow
   */
  export type MyOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter, which MyOrder to fetch.
     */
    where: MyOrderWhereUniqueInput
  }

  /**
   * MyOrder findFirst
   */
  export type MyOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter, which MyOrder to fetch.
     */
    where?: MyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyOrders to fetch.
     */
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MyOrders.
     */
    cursor?: MyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MyOrders.
     */
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * MyOrder findFirstOrThrow
   */
  export type MyOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter, which MyOrder to fetch.
     */
    where?: MyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyOrders to fetch.
     */
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MyOrders.
     */
    cursor?: MyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MyOrders.
     */
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * MyOrder findMany
   */
  export type MyOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter, which MyOrders to fetch.
     */
    where?: MyOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MyOrders to fetch.
     */
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MyOrders.
     */
    cursor?: MyOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MyOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MyOrders.
     */
    skip?: number
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * MyOrder create
   */
  export type MyOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a MyOrder.
     */
    data: XOR<MyOrderCreateInput, MyOrderUncheckedCreateInput>
  }

  /**
   * MyOrder createMany
   */
  export type MyOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MyOrders.
     */
    data: MyOrderCreateManyInput | MyOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MyOrder update
   */
  export type MyOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a MyOrder.
     */
    data: XOR<MyOrderUpdateInput, MyOrderUncheckedUpdateInput>
    /**
     * Choose, which MyOrder to update.
     */
    where: MyOrderWhereUniqueInput
  }

  /**
   * MyOrder updateMany
   */
  export type MyOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MyOrders.
     */
    data: XOR<MyOrderUpdateManyMutationInput, MyOrderUncheckedUpdateManyInput>
    /**
     * Filter which MyOrders to update
     */
    where?: MyOrderWhereInput
  }

  /**
   * MyOrder upsert
   */
  export type MyOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the MyOrder to update in case it exists.
     */
    where: MyOrderWhereUniqueInput
    /**
     * In case the MyOrder found by the `where` argument doesn't exist, create a new MyOrder with this data.
     */
    create: XOR<MyOrderCreateInput, MyOrderUncheckedCreateInput>
    /**
     * In case the MyOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MyOrderUpdateInput, MyOrderUncheckedUpdateInput>
  }

  /**
   * MyOrder delete
   */
  export type MyOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    /**
     * Filter which MyOrder to delete.
     */
    where: MyOrderWhereUniqueInput
  }

  /**
   * MyOrder deleteMany
   */
  export type MyOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MyOrders to delete
     */
    where?: MyOrderWhereInput
  }

  /**
   * MyOrder.orderItems
   */
  export type MyOrder$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    cursor?: OrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * MyOrder.reports
   */
  export type MyOrder$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * MyOrder without action
   */
  export type MyOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
  }


  /**
   * Model OrderItem
   */

  export type AggregateOrderItem = {
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  export type OrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    priceOptionId: number | null
  }

  export type OrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    priceOptionId: number | null
  }

  export type OrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    priceOptionId: number | null
  }

  export type OrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    productId: number | null
    quantity: number | null
    priceOptionId: number | null
  }

  export type OrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    priceOptionId: number
    _all: number
  }


  export type OrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceOptionId?: true
  }

  export type OrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceOptionId?: true
  }

  export type OrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceOptionId?: true
  }

  export type OrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceOptionId?: true
  }

  export type OrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    productId?: true
    quantity?: true
    priceOptionId?: true
    _all?: true
  }

  export type OrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItem to aggregate.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OrderItems
    **/
    _count?: true | OrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OrderItemMaxAggregateInputType
  }

  export type GetOrderItemAggregateType<T extends OrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOrderItem[P]>
      : GetScalarType<T[P], AggregateOrderItem[P]>
  }




  export type OrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OrderItemWhereInput
    orderBy?: OrderItemOrderByWithAggregationInput | OrderItemOrderByWithAggregationInput[]
    by: OrderItemScalarFieldEnum[] | OrderItemScalarFieldEnum
    having?: OrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OrderItemCountAggregateInputType | true
    _avg?: OrderItemAvgAggregateInputType
    _sum?: OrderItemSumAggregateInputType
    _min?: OrderItemMinAggregateInputType
    _max?: OrderItemMaxAggregateInputType
  }

  export type OrderItemGroupByOutputType = {
    id: number
    orderId: number
    productId: number
    quantity: number
    priceOptionId: number | null
    _count: OrderItemCountAggregateOutputType | null
    _avg: OrderItemAvgAggregateOutputType | null
    _sum: OrderItemSumAggregateOutputType | null
    _min: OrderItemMinAggregateOutputType | null
    _max: OrderItemMaxAggregateOutputType | null
  }

  type GetOrderItemGroupByPayload<T extends OrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], OrderItemGroupByOutputType[P]>
        }
      >
    >


  export type OrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    priceOptionId?: boolean
    priceOption?: boolean | OrderItem$priceOptionArgs<ExtArgs>
    order?: boolean | MyOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["orderItem"]>


  export type OrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    productId?: boolean
    quantity?: boolean
    priceOptionId?: boolean
  }

  export type OrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    priceOption?: boolean | OrderItem$priceOptionArgs<ExtArgs>
    order?: boolean | MyOrderDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $OrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OrderItem"
    objects: {
      priceOption: Prisma.$PriceOptionPayload<ExtArgs> | null
      order: Prisma.$MyOrderPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      productId: number
      quantity: number
      priceOptionId: number | null
    }, ExtArgs["result"]["orderItem"]>
    composites: {}
  }

  type OrderItemGetPayload<S extends boolean | null | undefined | OrderItemDefaultArgs> = $Result.GetResult<Prisma.$OrderItemPayload, S>

  type OrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OrderItemCountAggregateInputType | true
    }

  export interface OrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OrderItem'], meta: { name: 'OrderItem' } }
    /**
     * Find zero or one OrderItem that matches the filter.
     * @param {OrderItemFindUniqueArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OrderItemFindUniqueArgs>(args: SelectSubset<T, OrderItemFindUniqueArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one OrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OrderItemFindUniqueOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, OrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OrderItemFindFirstArgs>(args?: SelectSubset<T, OrderItemFindFirstArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first OrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindFirstOrThrowArgs} args - Arguments to find a OrderItem
     * @example
     * // Get one OrderItem
     * const orderItem = await prisma.orderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, OrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more OrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OrderItems
     * const orderItems = await prisma.orderItem.findMany()
     * 
     * // Get first 10 OrderItems
     * const orderItems = await prisma.orderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const orderItemWithIdOnly = await prisma.orderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OrderItemFindManyArgs>(args?: SelectSubset<T, OrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a OrderItem.
     * @param {OrderItemCreateArgs} args - Arguments to create a OrderItem.
     * @example
     * // Create one OrderItem
     * const OrderItem = await prisma.orderItem.create({
     *   data: {
     *     // ... data to create a OrderItem
     *   }
     * })
     * 
     */
    create<T extends OrderItemCreateArgs>(args: SelectSubset<T, OrderItemCreateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many OrderItems.
     * @param {OrderItemCreateManyArgs} args - Arguments to create many OrderItems.
     * @example
     * // Create many OrderItems
     * const orderItem = await prisma.orderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OrderItemCreateManyArgs>(args?: SelectSubset<T, OrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a OrderItem.
     * @param {OrderItemDeleteArgs} args - Arguments to delete one OrderItem.
     * @example
     * // Delete one OrderItem
     * const OrderItem = await prisma.orderItem.delete({
     *   where: {
     *     // ... filter to delete one OrderItem
     *   }
     * })
     * 
     */
    delete<T extends OrderItemDeleteArgs>(args: SelectSubset<T, OrderItemDeleteArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one OrderItem.
     * @param {OrderItemUpdateArgs} args - Arguments to update one OrderItem.
     * @example
     * // Update one OrderItem
     * const orderItem = await prisma.orderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OrderItemUpdateArgs>(args: SelectSubset<T, OrderItemUpdateArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more OrderItems.
     * @param {OrderItemDeleteManyArgs} args - Arguments to filter OrderItems to delete.
     * @example
     * // Delete a few OrderItems
     * const { count } = await prisma.orderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OrderItemDeleteManyArgs>(args?: SelectSubset<T, OrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OrderItems
     * const orderItem = await prisma.orderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OrderItemUpdateManyArgs>(args: SelectSubset<T, OrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one OrderItem.
     * @param {OrderItemUpsertArgs} args - Arguments to update or create a OrderItem.
     * @example
     * // Update or create a OrderItem
     * const orderItem = await prisma.orderItem.upsert({
     *   create: {
     *     // ... data to create a OrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OrderItem we want to update
     *   }
     * })
     */
    upsert<T extends OrderItemUpsertArgs>(args: SelectSubset<T, OrderItemUpsertArgs<ExtArgs>>): Prisma__OrderItemClient<$Result.GetResult<Prisma.$OrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of OrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemCountArgs} args - Arguments to filter OrderItems to count.
     * @example
     * // Count the number of OrderItems
     * const count = await prisma.orderItem.count({
     *   where: {
     *     // ... the filter for the OrderItems we want to count
     *   }
     * })
    **/
    count<T extends OrderItemCountArgs>(
      args?: Subset<T, OrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OrderItemAggregateArgs>(args: Subset<T, OrderItemAggregateArgs>): Prisma.PrismaPromise<GetOrderItemAggregateType<T>>

    /**
     * Group by OrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OrderItemGroupByArgs['orderBy'] }
        : { orderBy?: OrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OrderItem model
   */
  readonly fields: OrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    priceOption<T extends OrderItem$priceOptionArgs<ExtArgs> = {}>(args?: Subset<T, OrderItem$priceOptionArgs<ExtArgs>>): Prisma__PriceOptionClient<$Result.GetResult<Prisma.$PriceOptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    order<T extends MyOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MyOrderDefaultArgs<ExtArgs>>): Prisma__MyOrderClient<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OrderItem model
   */ 
  interface OrderItemFieldRefs {
    readonly id: FieldRef<"OrderItem", 'Int'>
    readonly orderId: FieldRef<"OrderItem", 'Int'>
    readonly productId: FieldRef<"OrderItem", 'Int'>
    readonly quantity: FieldRef<"OrderItem", 'Int'>
    readonly priceOptionId: FieldRef<"OrderItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * OrderItem findUnique
   */
  export type OrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findUniqueOrThrow
   */
  export type OrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem findFirst
   */
  export type OrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findFirstOrThrow
   */
  export type OrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItem to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OrderItems.
     */
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem findMany
   */
  export type OrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter, which OrderItems to fetch.
     */
    where?: OrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OrderItems to fetch.
     */
    orderBy?: OrderItemOrderByWithRelationInput | OrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OrderItems.
     */
    cursor?: OrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` OrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OrderItems.
     */
    skip?: number
    distinct?: OrderItemScalarFieldEnum | OrderItemScalarFieldEnum[]
  }

  /**
   * OrderItem create
   */
  export type OrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a OrderItem.
     */
    data: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
  }

  /**
   * OrderItem createMany
   */
  export type OrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OrderItems.
     */
    data: OrderItemCreateManyInput | OrderItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OrderItem update
   */
  export type OrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a OrderItem.
     */
    data: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
    /**
     * Choose, which OrderItem to update.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem updateMany
   */
  export type OrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OrderItems.
     */
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyInput>
    /**
     * Filter which OrderItems to update
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem upsert
   */
  export type OrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the OrderItem to update in case it exists.
     */
    where: OrderItemWhereUniqueInput
    /**
     * In case the OrderItem found by the `where` argument doesn't exist, create a new OrderItem with this data.
     */
    create: XOR<OrderItemCreateInput, OrderItemUncheckedCreateInput>
    /**
     * In case the OrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OrderItemUpdateInput, OrderItemUncheckedUpdateInput>
  }

  /**
   * OrderItem delete
   */
  export type OrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
    /**
     * Filter which OrderItem to delete.
     */
    where: OrderItemWhereUniqueInput
  }

  /**
   * OrderItem deleteMany
   */
  export type OrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OrderItems to delete
     */
    where?: OrderItemWhereInput
  }

  /**
   * OrderItem.priceOption
   */
  export type OrderItem$priceOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PriceOption
     */
    select?: PriceOptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PriceOptionInclude<ExtArgs> | null
    where?: PriceOptionWhereInput
  }

  /**
   * OrderItem without action
   */
  export type OrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OrderItem
     */
    select?: OrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OrderItemInclude<ExtArgs> | null
  }


  /**
   * Model JourneyPlan
   */

  export type AggregateJourneyPlan = {
    _count: JourneyPlanCountAggregateOutputType | null
    _avg: JourneyPlanAvgAggregateOutputType | null
    _sum: JourneyPlanSumAggregateOutputType | null
    _min: JourneyPlanMinAggregateOutputType | null
    _max: JourneyPlanMaxAggregateOutputType | null
  }

  export type JourneyPlanAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
    status: number | null
    latitude: number | null
    longitude: number | null
    checkoutLatitude: number | null
    checkoutLongitude: number | null
  }

  export type JourneyPlanSumAggregateOutputType = {
    id: number | null
    userId: number | null
    clientId: number | null
    status: number | null
    latitude: number | null
    longitude: number | null
    checkoutLatitude: number | null
    checkoutLongitude: number | null
  }

  export type JourneyPlanMinAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    userId: number | null
    clientId: number | null
    status: number | null
    checkInTime: Date | null
    latitude: number | null
    longitude: number | null
    imageUrl: string | null
    notes: string | null
    checkoutLatitude: number | null
    checkoutLongitude: number | null
    checkoutTime: Date | null
  }

  export type JourneyPlanMaxAggregateOutputType = {
    id: number | null
    date: Date | null
    time: string | null
    userId: number | null
    clientId: number | null
    status: number | null
    checkInTime: Date | null
    latitude: number | null
    longitude: number | null
    imageUrl: string | null
    notes: string | null
    checkoutLatitude: number | null
    checkoutLongitude: number | null
    checkoutTime: Date | null
  }

  export type JourneyPlanCountAggregateOutputType = {
    id: number
    date: number
    time: number
    userId: number
    clientId: number
    status: number
    checkInTime: number
    latitude: number
    longitude: number
    imageUrl: number
    notes: number
    checkoutLatitude: number
    checkoutLongitude: number
    checkoutTime: number
    _all: number
  }


  export type JourneyPlanAvgAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
    status?: true
    latitude?: true
    longitude?: true
    checkoutLatitude?: true
    checkoutLongitude?: true
  }

  export type JourneyPlanSumAggregateInputType = {
    id?: true
    userId?: true
    clientId?: true
    status?: true
    latitude?: true
    longitude?: true
    checkoutLatitude?: true
    checkoutLongitude?: true
  }

  export type JourneyPlanMinAggregateInputType = {
    id?: true
    date?: true
    time?: true
    userId?: true
    clientId?: true
    status?: true
    checkInTime?: true
    latitude?: true
    longitude?: true
    imageUrl?: true
    notes?: true
    checkoutLatitude?: true
    checkoutLongitude?: true
    checkoutTime?: true
  }

  export type JourneyPlanMaxAggregateInputType = {
    id?: true
    date?: true
    time?: true
    userId?: true
    clientId?: true
    status?: true
    checkInTime?: true
    latitude?: true
    longitude?: true
    imageUrl?: true
    notes?: true
    checkoutLatitude?: true
    checkoutLongitude?: true
    checkoutTime?: true
  }

  export type JourneyPlanCountAggregateInputType = {
    id?: true
    date?: true
    time?: true
    userId?: true
    clientId?: true
    status?: true
    checkInTime?: true
    latitude?: true
    longitude?: true
    imageUrl?: true
    notes?: true
    checkoutLatitude?: true
    checkoutLongitude?: true
    checkoutTime?: true
    _all?: true
  }

  export type JourneyPlanAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JourneyPlan to aggregate.
     */
    where?: JourneyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyPlans to fetch.
     */
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JourneyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JourneyPlans
    **/
    _count?: true | JourneyPlanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JourneyPlanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JourneyPlanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JourneyPlanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JourneyPlanMaxAggregateInputType
  }

  export type GetJourneyPlanAggregateType<T extends JourneyPlanAggregateArgs> = {
        [P in keyof T & keyof AggregateJourneyPlan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJourneyPlan[P]>
      : GetScalarType<T[P], AggregateJourneyPlan[P]>
  }




  export type JourneyPlanGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JourneyPlanWhereInput
    orderBy?: JourneyPlanOrderByWithAggregationInput | JourneyPlanOrderByWithAggregationInput[]
    by: JourneyPlanScalarFieldEnum[] | JourneyPlanScalarFieldEnum
    having?: JourneyPlanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JourneyPlanCountAggregateInputType | true
    _avg?: JourneyPlanAvgAggregateInputType
    _sum?: JourneyPlanSumAggregateInputType
    _min?: JourneyPlanMinAggregateInputType
    _max?: JourneyPlanMaxAggregateInputType
  }

  export type JourneyPlanGroupByOutputType = {
    id: number
    date: Date
    time: string
    userId: number | null
    clientId: number
    status: number
    checkInTime: Date | null
    latitude: number | null
    longitude: number | null
    imageUrl: string | null
    notes: string | null
    checkoutLatitude: number | null
    checkoutLongitude: number | null
    checkoutTime: Date | null
    _count: JourneyPlanCountAggregateOutputType | null
    _avg: JourneyPlanAvgAggregateOutputType | null
    _sum: JourneyPlanSumAggregateOutputType | null
    _min: JourneyPlanMinAggregateOutputType | null
    _max: JourneyPlanMaxAggregateOutputType | null
  }

  type GetJourneyPlanGroupByPayload<T extends JourneyPlanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JourneyPlanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JourneyPlanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JourneyPlanGroupByOutputType[P]>
            : GetScalarType<T[P], JourneyPlanGroupByOutputType[P]>
        }
      >
    >


  export type JourneyPlanSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    time?: boolean
    userId?: boolean
    clientId?: boolean
    status?: boolean
    checkInTime?: boolean
    latitude?: boolean
    longitude?: boolean
    imageUrl?: boolean
    notes?: boolean
    checkoutLatitude?: boolean
    checkoutLongitude?: boolean
    checkoutTime?: boolean
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | JourneyPlan$userArgs<ExtArgs>
    reports?: boolean | JourneyPlan$reportsArgs<ExtArgs>
    _count?: boolean | JourneyPlanCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["journeyPlan"]>


  export type JourneyPlanSelectScalar = {
    id?: boolean
    date?: boolean
    time?: boolean
    userId?: boolean
    clientId?: boolean
    status?: boolean
    checkInTime?: boolean
    latitude?: boolean
    longitude?: boolean
    imageUrl?: boolean
    notes?: boolean
    checkoutLatitude?: boolean
    checkoutLongitude?: boolean
    checkoutTime?: boolean
  }

  export type JourneyPlanInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | JourneyPlan$userArgs<ExtArgs>
    reports?: boolean | JourneyPlan$reportsArgs<ExtArgs>
    _count?: boolean | JourneyPlanCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $JourneyPlanPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JourneyPlan"
    objects: {
      client: Prisma.$ClientsPayload<ExtArgs>
      user: Prisma.$SalesRepPayload<ExtArgs> | null
      reports: Prisma.$ReportPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: Date
      time: string
      userId: number | null
      clientId: number
      status: number
      checkInTime: Date | null
      latitude: number | null
      longitude: number | null
      imageUrl: string | null
      notes: string | null
      checkoutLatitude: number | null
      checkoutLongitude: number | null
      checkoutTime: Date | null
    }, ExtArgs["result"]["journeyPlan"]>
    composites: {}
  }

  type JourneyPlanGetPayload<S extends boolean | null | undefined | JourneyPlanDefaultArgs> = $Result.GetResult<Prisma.$JourneyPlanPayload, S>

  type JourneyPlanCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<JourneyPlanFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: JourneyPlanCountAggregateInputType | true
    }

  export interface JourneyPlanDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JourneyPlan'], meta: { name: 'JourneyPlan' } }
    /**
     * Find zero or one JourneyPlan that matches the filter.
     * @param {JourneyPlanFindUniqueArgs} args - Arguments to find a JourneyPlan
     * @example
     * // Get one JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JourneyPlanFindUniqueArgs>(args: SelectSubset<T, JourneyPlanFindUniqueArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one JourneyPlan that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {JourneyPlanFindUniqueOrThrowArgs} args - Arguments to find a JourneyPlan
     * @example
     * // Get one JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JourneyPlanFindUniqueOrThrowArgs>(args: SelectSubset<T, JourneyPlanFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first JourneyPlan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanFindFirstArgs} args - Arguments to find a JourneyPlan
     * @example
     * // Get one JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JourneyPlanFindFirstArgs>(args?: SelectSubset<T, JourneyPlanFindFirstArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first JourneyPlan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanFindFirstOrThrowArgs} args - Arguments to find a JourneyPlan
     * @example
     * // Get one JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JourneyPlanFindFirstOrThrowArgs>(args?: SelectSubset<T, JourneyPlanFindFirstOrThrowArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more JourneyPlans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JourneyPlans
     * const journeyPlans = await prisma.journeyPlan.findMany()
     * 
     * // Get first 10 JourneyPlans
     * const journeyPlans = await prisma.journeyPlan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const journeyPlanWithIdOnly = await prisma.journeyPlan.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JourneyPlanFindManyArgs>(args?: SelectSubset<T, JourneyPlanFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a JourneyPlan.
     * @param {JourneyPlanCreateArgs} args - Arguments to create a JourneyPlan.
     * @example
     * // Create one JourneyPlan
     * const JourneyPlan = await prisma.journeyPlan.create({
     *   data: {
     *     // ... data to create a JourneyPlan
     *   }
     * })
     * 
     */
    create<T extends JourneyPlanCreateArgs>(args: SelectSubset<T, JourneyPlanCreateArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many JourneyPlans.
     * @param {JourneyPlanCreateManyArgs} args - Arguments to create many JourneyPlans.
     * @example
     * // Create many JourneyPlans
     * const journeyPlan = await prisma.journeyPlan.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JourneyPlanCreateManyArgs>(args?: SelectSubset<T, JourneyPlanCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a JourneyPlan.
     * @param {JourneyPlanDeleteArgs} args - Arguments to delete one JourneyPlan.
     * @example
     * // Delete one JourneyPlan
     * const JourneyPlan = await prisma.journeyPlan.delete({
     *   where: {
     *     // ... filter to delete one JourneyPlan
     *   }
     * })
     * 
     */
    delete<T extends JourneyPlanDeleteArgs>(args: SelectSubset<T, JourneyPlanDeleteArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one JourneyPlan.
     * @param {JourneyPlanUpdateArgs} args - Arguments to update one JourneyPlan.
     * @example
     * // Update one JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JourneyPlanUpdateArgs>(args: SelectSubset<T, JourneyPlanUpdateArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more JourneyPlans.
     * @param {JourneyPlanDeleteManyArgs} args - Arguments to filter JourneyPlans to delete.
     * @example
     * // Delete a few JourneyPlans
     * const { count } = await prisma.journeyPlan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JourneyPlanDeleteManyArgs>(args?: SelectSubset<T, JourneyPlanDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JourneyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JourneyPlans
     * const journeyPlan = await prisma.journeyPlan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JourneyPlanUpdateManyArgs>(args: SelectSubset<T, JourneyPlanUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one JourneyPlan.
     * @param {JourneyPlanUpsertArgs} args - Arguments to update or create a JourneyPlan.
     * @example
     * // Update or create a JourneyPlan
     * const journeyPlan = await prisma.journeyPlan.upsert({
     *   create: {
     *     // ... data to create a JourneyPlan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JourneyPlan we want to update
     *   }
     * })
     */
    upsert<T extends JourneyPlanUpsertArgs>(args: SelectSubset<T, JourneyPlanUpsertArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of JourneyPlans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanCountArgs} args - Arguments to filter JourneyPlans to count.
     * @example
     * // Count the number of JourneyPlans
     * const count = await prisma.journeyPlan.count({
     *   where: {
     *     // ... the filter for the JourneyPlans we want to count
     *   }
     * })
    **/
    count<T extends JourneyPlanCountArgs>(
      args?: Subset<T, JourneyPlanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JourneyPlanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JourneyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JourneyPlanAggregateArgs>(args: Subset<T, JourneyPlanAggregateArgs>): Prisma.PrismaPromise<GetJourneyPlanAggregateType<T>>

    /**
     * Group by JourneyPlan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JourneyPlanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JourneyPlanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JourneyPlanGroupByArgs['orderBy'] }
        : { orderBy?: JourneyPlanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JourneyPlanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJourneyPlanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JourneyPlan model
   */
  readonly fields: JourneyPlanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JourneyPlan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JourneyPlanClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientsDefaultArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends JourneyPlan$userArgs<ExtArgs> = {}>(args?: Subset<T, JourneyPlan$userArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reports<T extends JourneyPlan$reportsArgs<ExtArgs> = {}>(args?: Subset<T, JourneyPlan$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JourneyPlan model
   */ 
  interface JourneyPlanFieldRefs {
    readonly id: FieldRef<"JourneyPlan", 'Int'>
    readonly date: FieldRef<"JourneyPlan", 'DateTime'>
    readonly time: FieldRef<"JourneyPlan", 'String'>
    readonly userId: FieldRef<"JourneyPlan", 'Int'>
    readonly clientId: FieldRef<"JourneyPlan", 'Int'>
    readonly status: FieldRef<"JourneyPlan", 'Int'>
    readonly checkInTime: FieldRef<"JourneyPlan", 'DateTime'>
    readonly latitude: FieldRef<"JourneyPlan", 'Float'>
    readonly longitude: FieldRef<"JourneyPlan", 'Float'>
    readonly imageUrl: FieldRef<"JourneyPlan", 'String'>
    readonly notes: FieldRef<"JourneyPlan", 'String'>
    readonly checkoutLatitude: FieldRef<"JourneyPlan", 'Float'>
    readonly checkoutLongitude: FieldRef<"JourneyPlan", 'Float'>
    readonly checkoutTime: FieldRef<"JourneyPlan", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * JourneyPlan findUnique
   */
  export type JourneyPlanFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter, which JourneyPlan to fetch.
     */
    where: JourneyPlanWhereUniqueInput
  }

  /**
   * JourneyPlan findUniqueOrThrow
   */
  export type JourneyPlanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter, which JourneyPlan to fetch.
     */
    where: JourneyPlanWhereUniqueInput
  }

  /**
   * JourneyPlan findFirst
   */
  export type JourneyPlanFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter, which JourneyPlan to fetch.
     */
    where?: JourneyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyPlans to fetch.
     */
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JourneyPlans.
     */
    cursor?: JourneyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JourneyPlans.
     */
    distinct?: JourneyPlanScalarFieldEnum | JourneyPlanScalarFieldEnum[]
  }

  /**
   * JourneyPlan findFirstOrThrow
   */
  export type JourneyPlanFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter, which JourneyPlan to fetch.
     */
    where?: JourneyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyPlans to fetch.
     */
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JourneyPlans.
     */
    cursor?: JourneyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyPlans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JourneyPlans.
     */
    distinct?: JourneyPlanScalarFieldEnum | JourneyPlanScalarFieldEnum[]
  }

  /**
   * JourneyPlan findMany
   */
  export type JourneyPlanFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter, which JourneyPlans to fetch.
     */
    where?: JourneyPlanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JourneyPlans to fetch.
     */
    orderBy?: JourneyPlanOrderByWithRelationInput | JourneyPlanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JourneyPlans.
     */
    cursor?: JourneyPlanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JourneyPlans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JourneyPlans.
     */
    skip?: number
    distinct?: JourneyPlanScalarFieldEnum | JourneyPlanScalarFieldEnum[]
  }

  /**
   * JourneyPlan create
   */
  export type JourneyPlanCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * The data needed to create a JourneyPlan.
     */
    data: XOR<JourneyPlanCreateInput, JourneyPlanUncheckedCreateInput>
  }

  /**
   * JourneyPlan createMany
   */
  export type JourneyPlanCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JourneyPlans.
     */
    data: JourneyPlanCreateManyInput | JourneyPlanCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JourneyPlan update
   */
  export type JourneyPlanUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * The data needed to update a JourneyPlan.
     */
    data: XOR<JourneyPlanUpdateInput, JourneyPlanUncheckedUpdateInput>
    /**
     * Choose, which JourneyPlan to update.
     */
    where: JourneyPlanWhereUniqueInput
  }

  /**
   * JourneyPlan updateMany
   */
  export type JourneyPlanUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JourneyPlans.
     */
    data: XOR<JourneyPlanUpdateManyMutationInput, JourneyPlanUncheckedUpdateManyInput>
    /**
     * Filter which JourneyPlans to update
     */
    where?: JourneyPlanWhereInput
  }

  /**
   * JourneyPlan upsert
   */
  export type JourneyPlanUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * The filter to search for the JourneyPlan to update in case it exists.
     */
    where: JourneyPlanWhereUniqueInput
    /**
     * In case the JourneyPlan found by the `where` argument doesn't exist, create a new JourneyPlan with this data.
     */
    create: XOR<JourneyPlanCreateInput, JourneyPlanUncheckedCreateInput>
    /**
     * In case the JourneyPlan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JourneyPlanUpdateInput, JourneyPlanUncheckedUpdateInput>
  }

  /**
   * JourneyPlan delete
   */
  export type JourneyPlanDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    /**
     * Filter which JourneyPlan to delete.
     */
    where: JourneyPlanWhereUniqueInput
  }

  /**
   * JourneyPlan deleteMany
   */
  export type JourneyPlanDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JourneyPlans to delete
     */
    where?: JourneyPlanWhereInput
  }

  /**
   * JourneyPlan.user
   */
  export type JourneyPlan$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalesRep
     */
    select?: SalesRepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalesRepInclude<ExtArgs> | null
    where?: SalesRepWhereInput
  }

  /**
   * JourneyPlan.reports
   */
  export type JourneyPlan$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    cursor?: ReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * JourneyPlan without action
   */
  export type JourneyPlanDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
  }


  /**
   * Model NoticeBoard
   */

  export type AggregateNoticeBoard = {
    _count: NoticeBoardCountAggregateOutputType | null
    _avg: NoticeBoardAvgAggregateOutputType | null
    _sum: NoticeBoardSumAggregateOutputType | null
    _min: NoticeBoardMinAggregateOutputType | null
    _max: NoticeBoardMaxAggregateOutputType | null
  }

  export type NoticeBoardAvgAggregateOutputType = {
    id: number | null
  }

  export type NoticeBoardSumAggregateOutputType = {
    id: number | null
  }

  export type NoticeBoardMinAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoticeBoardMaxAggregateOutputType = {
    id: number | null
    title: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NoticeBoardCountAggregateOutputType = {
    id: number
    title: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NoticeBoardAvgAggregateInputType = {
    id?: true
  }

  export type NoticeBoardSumAggregateInputType = {
    id?: true
  }

  export type NoticeBoardMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoticeBoardMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NoticeBoardCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NoticeBoardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoticeBoard to aggregate.
     */
    where?: NoticeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeBoards to fetch.
     */
    orderBy?: NoticeBoardOrderByWithRelationInput | NoticeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NoticeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NoticeBoards
    **/
    _count?: true | NoticeBoardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoticeBoardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoticeBoardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoticeBoardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoticeBoardMaxAggregateInputType
  }

  export type GetNoticeBoardAggregateType<T extends NoticeBoardAggregateArgs> = {
        [P in keyof T & keyof AggregateNoticeBoard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNoticeBoard[P]>
      : GetScalarType<T[P], AggregateNoticeBoard[P]>
  }




  export type NoticeBoardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NoticeBoardWhereInput
    orderBy?: NoticeBoardOrderByWithAggregationInput | NoticeBoardOrderByWithAggregationInput[]
    by: NoticeBoardScalarFieldEnum[] | NoticeBoardScalarFieldEnum
    having?: NoticeBoardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoticeBoardCountAggregateInputType | true
    _avg?: NoticeBoardAvgAggregateInputType
    _sum?: NoticeBoardSumAggregateInputType
    _min?: NoticeBoardMinAggregateInputType
    _max?: NoticeBoardMaxAggregateInputType
  }

  export type NoticeBoardGroupByOutputType = {
    id: number
    title: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: NoticeBoardCountAggregateOutputType | null
    _avg: NoticeBoardAvgAggregateOutputType | null
    _sum: NoticeBoardSumAggregateOutputType | null
    _min: NoticeBoardMinAggregateOutputType | null
    _max: NoticeBoardMaxAggregateOutputType | null
  }

  type GetNoticeBoardGroupByPayload<T extends NoticeBoardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoticeBoardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoticeBoardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoticeBoardGroupByOutputType[P]>
            : GetScalarType<T[P], NoticeBoardGroupByOutputType[P]>
        }
      >
    >


  export type NoticeBoardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["noticeBoard"]>


  export type NoticeBoardSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $NoticeBoardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NoticeBoard"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["noticeBoard"]>
    composites: {}
  }

  type NoticeBoardGetPayload<S extends boolean | null | undefined | NoticeBoardDefaultArgs> = $Result.GetResult<Prisma.$NoticeBoardPayload, S>

  type NoticeBoardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NoticeBoardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NoticeBoardCountAggregateInputType | true
    }

  export interface NoticeBoardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NoticeBoard'], meta: { name: 'NoticeBoard' } }
    /**
     * Find zero or one NoticeBoard that matches the filter.
     * @param {NoticeBoardFindUniqueArgs} args - Arguments to find a NoticeBoard
     * @example
     * // Get one NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NoticeBoardFindUniqueArgs>(args: SelectSubset<T, NoticeBoardFindUniqueArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one NoticeBoard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NoticeBoardFindUniqueOrThrowArgs} args - Arguments to find a NoticeBoard
     * @example
     * // Get one NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NoticeBoardFindUniqueOrThrowArgs>(args: SelectSubset<T, NoticeBoardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first NoticeBoard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardFindFirstArgs} args - Arguments to find a NoticeBoard
     * @example
     * // Get one NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NoticeBoardFindFirstArgs>(args?: SelectSubset<T, NoticeBoardFindFirstArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first NoticeBoard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardFindFirstOrThrowArgs} args - Arguments to find a NoticeBoard
     * @example
     * // Get one NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NoticeBoardFindFirstOrThrowArgs>(args?: SelectSubset<T, NoticeBoardFindFirstOrThrowArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more NoticeBoards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NoticeBoards
     * const noticeBoards = await prisma.noticeBoard.findMany()
     * 
     * // Get first 10 NoticeBoards
     * const noticeBoards = await prisma.noticeBoard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const noticeBoardWithIdOnly = await prisma.noticeBoard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NoticeBoardFindManyArgs>(args?: SelectSubset<T, NoticeBoardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a NoticeBoard.
     * @param {NoticeBoardCreateArgs} args - Arguments to create a NoticeBoard.
     * @example
     * // Create one NoticeBoard
     * const NoticeBoard = await prisma.noticeBoard.create({
     *   data: {
     *     // ... data to create a NoticeBoard
     *   }
     * })
     * 
     */
    create<T extends NoticeBoardCreateArgs>(args: SelectSubset<T, NoticeBoardCreateArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many NoticeBoards.
     * @param {NoticeBoardCreateManyArgs} args - Arguments to create many NoticeBoards.
     * @example
     * // Create many NoticeBoards
     * const noticeBoard = await prisma.noticeBoard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NoticeBoardCreateManyArgs>(args?: SelectSubset<T, NoticeBoardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a NoticeBoard.
     * @param {NoticeBoardDeleteArgs} args - Arguments to delete one NoticeBoard.
     * @example
     * // Delete one NoticeBoard
     * const NoticeBoard = await prisma.noticeBoard.delete({
     *   where: {
     *     // ... filter to delete one NoticeBoard
     *   }
     * })
     * 
     */
    delete<T extends NoticeBoardDeleteArgs>(args: SelectSubset<T, NoticeBoardDeleteArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one NoticeBoard.
     * @param {NoticeBoardUpdateArgs} args - Arguments to update one NoticeBoard.
     * @example
     * // Update one NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NoticeBoardUpdateArgs>(args: SelectSubset<T, NoticeBoardUpdateArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more NoticeBoards.
     * @param {NoticeBoardDeleteManyArgs} args - Arguments to filter NoticeBoards to delete.
     * @example
     * // Delete a few NoticeBoards
     * const { count } = await prisma.noticeBoard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NoticeBoardDeleteManyArgs>(args?: SelectSubset<T, NoticeBoardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NoticeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NoticeBoards
     * const noticeBoard = await prisma.noticeBoard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NoticeBoardUpdateManyArgs>(args: SelectSubset<T, NoticeBoardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one NoticeBoard.
     * @param {NoticeBoardUpsertArgs} args - Arguments to update or create a NoticeBoard.
     * @example
     * // Update or create a NoticeBoard
     * const noticeBoard = await prisma.noticeBoard.upsert({
     *   create: {
     *     // ... data to create a NoticeBoard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NoticeBoard we want to update
     *   }
     * })
     */
    upsert<T extends NoticeBoardUpsertArgs>(args: SelectSubset<T, NoticeBoardUpsertArgs<ExtArgs>>): Prisma__NoticeBoardClient<$Result.GetResult<Prisma.$NoticeBoardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of NoticeBoards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardCountArgs} args - Arguments to filter NoticeBoards to count.
     * @example
     * // Count the number of NoticeBoards
     * const count = await prisma.noticeBoard.count({
     *   where: {
     *     // ... the filter for the NoticeBoards we want to count
     *   }
     * })
    **/
    count<T extends NoticeBoardCountArgs>(
      args?: Subset<T, NoticeBoardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoticeBoardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NoticeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoticeBoardAggregateArgs>(args: Subset<T, NoticeBoardAggregateArgs>): Prisma.PrismaPromise<GetNoticeBoardAggregateType<T>>

    /**
     * Group by NoticeBoard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoticeBoardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NoticeBoardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NoticeBoardGroupByArgs['orderBy'] }
        : { orderBy?: NoticeBoardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NoticeBoardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoticeBoardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NoticeBoard model
   */
  readonly fields: NoticeBoardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NoticeBoard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NoticeBoardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NoticeBoard model
   */ 
  interface NoticeBoardFieldRefs {
    readonly id: FieldRef<"NoticeBoard", 'Int'>
    readonly title: FieldRef<"NoticeBoard", 'String'>
    readonly content: FieldRef<"NoticeBoard", 'String'>
    readonly createdAt: FieldRef<"NoticeBoard", 'DateTime'>
    readonly updatedAt: FieldRef<"NoticeBoard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NoticeBoard findUnique
   */
  export type NoticeBoardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter, which NoticeBoard to fetch.
     */
    where: NoticeBoardWhereUniqueInput
  }

  /**
   * NoticeBoard findUniqueOrThrow
   */
  export type NoticeBoardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter, which NoticeBoard to fetch.
     */
    where: NoticeBoardWhereUniqueInput
  }

  /**
   * NoticeBoard findFirst
   */
  export type NoticeBoardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter, which NoticeBoard to fetch.
     */
    where?: NoticeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeBoards to fetch.
     */
    orderBy?: NoticeBoardOrderByWithRelationInput | NoticeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoticeBoards.
     */
    cursor?: NoticeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoticeBoards.
     */
    distinct?: NoticeBoardScalarFieldEnum | NoticeBoardScalarFieldEnum[]
  }

  /**
   * NoticeBoard findFirstOrThrow
   */
  export type NoticeBoardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter, which NoticeBoard to fetch.
     */
    where?: NoticeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeBoards to fetch.
     */
    orderBy?: NoticeBoardOrderByWithRelationInput | NoticeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NoticeBoards.
     */
    cursor?: NoticeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeBoards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NoticeBoards.
     */
    distinct?: NoticeBoardScalarFieldEnum | NoticeBoardScalarFieldEnum[]
  }

  /**
   * NoticeBoard findMany
   */
  export type NoticeBoardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter, which NoticeBoards to fetch.
     */
    where?: NoticeBoardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NoticeBoards to fetch.
     */
    orderBy?: NoticeBoardOrderByWithRelationInput | NoticeBoardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NoticeBoards.
     */
    cursor?: NoticeBoardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NoticeBoards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NoticeBoards.
     */
    skip?: number
    distinct?: NoticeBoardScalarFieldEnum | NoticeBoardScalarFieldEnum[]
  }

  /**
   * NoticeBoard create
   */
  export type NoticeBoardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * The data needed to create a NoticeBoard.
     */
    data: XOR<NoticeBoardCreateInput, NoticeBoardUncheckedCreateInput>
  }

  /**
   * NoticeBoard createMany
   */
  export type NoticeBoardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NoticeBoards.
     */
    data: NoticeBoardCreateManyInput | NoticeBoardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NoticeBoard update
   */
  export type NoticeBoardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * The data needed to update a NoticeBoard.
     */
    data: XOR<NoticeBoardUpdateInput, NoticeBoardUncheckedUpdateInput>
    /**
     * Choose, which NoticeBoard to update.
     */
    where: NoticeBoardWhereUniqueInput
  }

  /**
   * NoticeBoard updateMany
   */
  export type NoticeBoardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NoticeBoards.
     */
    data: XOR<NoticeBoardUpdateManyMutationInput, NoticeBoardUncheckedUpdateManyInput>
    /**
     * Filter which NoticeBoards to update
     */
    where?: NoticeBoardWhereInput
  }

  /**
   * NoticeBoard upsert
   */
  export type NoticeBoardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * The filter to search for the NoticeBoard to update in case it exists.
     */
    where: NoticeBoardWhereUniqueInput
    /**
     * In case the NoticeBoard found by the `where` argument doesn't exist, create a new NoticeBoard with this data.
     */
    create: XOR<NoticeBoardCreateInput, NoticeBoardUncheckedCreateInput>
    /**
     * In case the NoticeBoard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NoticeBoardUpdateInput, NoticeBoardUncheckedUpdateInput>
  }

  /**
   * NoticeBoard delete
   */
  export type NoticeBoardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
    /**
     * Filter which NoticeBoard to delete.
     */
    where: NoticeBoardWhereUniqueInput
  }

  /**
   * NoticeBoard deleteMany
   */
  export type NoticeBoardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NoticeBoards to delete
     */
    where?: NoticeBoardWhereInput
  }

  /**
   * NoticeBoard without action
   */
  export type NoticeBoardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoticeBoard
     */
    select?: NoticeBoardSelect<ExtArgs> | null
  }


  /**
   * Model Report
   */

  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    clientId: number | null
    userId: number | null
    journeyPlanId: number | null
  }

  export type ReportSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    clientId: number | null
    userId: number | null
    journeyPlanId: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    clientId: number | null
    createdAt: Date | null
    userId: number | null
    journeyPlanId: number | null
    type: $Enums.ReportType | null
  }

  export type ReportMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    clientId: number | null
    createdAt: Date | null
    userId: number | null
    journeyPlanId: number | null
    type: $Enums.ReportType | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    orderId: number
    clientId: number
    createdAt: number
    userId: number
    journeyPlanId: number
    type: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    userId?: true
    journeyPlanId?: true
  }

  export type ReportSumAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    userId?: true
    journeyPlanId?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    createdAt?: true
    userId?: true
    journeyPlanId?: true
    type?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    createdAt?: true
    userId?: true
    journeyPlanId?: true
    type?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    orderId?: true
    clientId?: true
    createdAt?: true
    userId?: true
    journeyPlanId?: true
    type?: true
    _all?: true
  }

  export type ReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Report to aggregate.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportWhereInput
    orderBy?: ReportOrderByWithAggregationInput | ReportOrderByWithAggregationInput[]
    by: ReportScalarFieldEnum[] | ReportScalarFieldEnum
    having?: ReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }

  export type ReportGroupByOutputType = {
    id: number
    orderId: number | null
    clientId: number
    createdAt: Date
    userId: number
    journeyPlanId: number | null
    type: $Enums.ReportType
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type ReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyPlanId?: boolean
    type?: boolean
    feedbackReport?: boolean | Report$feedbackReportArgs<ExtArgs>
    productReport?: boolean | Report$productReportArgs<ExtArgs>
    journeyPlan?: boolean | Report$journeyPlanArgs<ExtArgs>
    MyOrder?: boolean | Report$MyOrderArgs<ExtArgs>
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    visibilityReport?: boolean | Report$visibilityReportArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["report"]>


  export type ReportSelectScalar = {
    id?: boolean
    orderId?: boolean
    clientId?: boolean
    createdAt?: boolean
    userId?: boolean
    journeyPlanId?: boolean
    type?: boolean
  }

  export type ReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    feedbackReport?: boolean | Report$feedbackReportArgs<ExtArgs>
    productReport?: boolean | Report$productReportArgs<ExtArgs>
    journeyPlan?: boolean | Report$journeyPlanArgs<ExtArgs>
    MyOrder?: boolean | Report$MyOrderArgs<ExtArgs>
    client?: boolean | ClientsDefaultArgs<ExtArgs>
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
    visibilityReport?: boolean | Report$visibilityReportArgs<ExtArgs>
    _count?: boolean | ReportCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Report"
    objects: {
      feedbackReport: Prisma.$FeedbackReportPayload<ExtArgs> | null
      productReport: Prisma.$ProductReportPayload<ExtArgs> | null
      journeyPlan: Prisma.$JourneyPlanPayload<ExtArgs> | null
      MyOrder: Prisma.$MyOrderPayload<ExtArgs>[]
      client: Prisma.$ClientsPayload<ExtArgs>
      user: Prisma.$SalesRepPayload<ExtArgs>
      visibilityReport: Prisma.$VisibilityReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number | null
      clientId: number
      createdAt: Date
      userId: number
      journeyPlanId: number | null
      type: $Enums.ReportType
    }, ExtArgs["result"]["report"]>
    composites: {}
  }

  type ReportGetPayload<S extends boolean | null | undefined | ReportDefaultArgs> = $Result.GetResult<Prisma.$ReportPayload, S>

  type ReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface ReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Report'], meta: { name: 'Report' } }
    /**
     * Find zero or one Report that matches the filter.
     * @param {ReportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportFindUniqueArgs>(args: SelectSubset<T, ReportFindUniqueArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Report that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportFindFirstArgs>(args?: SelectSubset<T, ReportFindFirstArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Report that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportFindManyArgs>(args?: SelectSubset<T, ReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Report.
     * @param {ReportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
     */
    create<T extends ReportCreateArgs>(args: SelectSubset<T, ReportCreateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reports.
     * @param {ReportCreateManyArgs} args - Arguments to create many Reports.
     * @example
     * // Create many Reports
     * const report = await prisma.report.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportCreateManyArgs>(args?: SelectSubset<T, ReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Report.
     * @param {ReportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
     */
    delete<T extends ReportDeleteArgs>(args: SelectSubset<T, ReportDeleteArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Report.
     * @param {ReportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportUpdateArgs>(args: SelectSubset<T, ReportUpdateArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reports.
     * @param {ReportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportDeleteManyArgs>(args?: SelectSubset<T, ReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportUpdateManyArgs>(args: SelectSubset<T, ReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {ReportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
     */
    upsert<T extends ReportUpsertArgs>(args: SelectSubset<T, ReportUpsertArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends ReportCountArgs>(
      args?: Subset<T, ReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Report model
   */
  readonly fields: ReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    feedbackReport<T extends Report$feedbackReportArgs<ExtArgs> = {}>(args?: Subset<T, Report$feedbackReportArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    productReport<T extends Report$productReportArgs<ExtArgs> = {}>(args?: Subset<T, Report$productReportArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    journeyPlan<T extends Report$journeyPlanArgs<ExtArgs> = {}>(args?: Subset<T, Report$journeyPlanArgs<ExtArgs>>): Prisma__JourneyPlanClient<$Result.GetResult<Prisma.$JourneyPlanPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    MyOrder<T extends Report$MyOrderArgs<ExtArgs> = {}>(args?: Subset<T, Report$MyOrderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MyOrderPayload<ExtArgs>, T, "findMany"> | Null>
    client<T extends ClientsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientsDefaultArgs<ExtArgs>>): Prisma__ClientsClient<$Result.GetResult<Prisma.$ClientsPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends SalesRepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesRepDefaultArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    visibilityReport<T extends Report$visibilityReportArgs<ExtArgs> = {}>(args?: Subset<T, Report$visibilityReportArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Report model
   */ 
  interface ReportFieldRefs {
    readonly id: FieldRef<"Report", 'Int'>
    readonly orderId: FieldRef<"Report", 'Int'>
    readonly clientId: FieldRef<"Report", 'Int'>
    readonly createdAt: FieldRef<"Report", 'DateTime'>
    readonly userId: FieldRef<"Report", 'Int'>
    readonly journeyPlanId: FieldRef<"Report", 'Int'>
    readonly type: FieldRef<"Report", 'ReportType'>
  }
    

  // Custom InputTypes
  /**
   * Report findUnique
   */
  export type ReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findUniqueOrThrow
   */
  export type ReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report findFirst
   */
  export type ReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findFirstOrThrow
   */
  export type ReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Report to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reports.
     */
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report findMany
   */
  export type ReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter, which Reports to fetch.
     */
    where?: ReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reports to fetch.
     */
    orderBy?: ReportOrderByWithRelationInput | ReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reports.
     */
    cursor?: ReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reports.
     */
    skip?: number
    distinct?: ReportScalarFieldEnum | ReportScalarFieldEnum[]
  }

  /**
   * Report create
   */
  export type ReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to create a Report.
     */
    data: XOR<ReportCreateInput, ReportUncheckedCreateInput>
  }

  /**
   * Report createMany
   */
  export type ReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reports.
     */
    data: ReportCreateManyInput | ReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Report update
   */
  export type ReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The data needed to update a Report.
     */
    data: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
    /**
     * Choose, which Report to update.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report updateMany
   */
  export type ReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reports.
     */
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyInput>
    /**
     * Filter which Reports to update
     */
    where?: ReportWhereInput
  }

  /**
   * Report upsert
   */
  export type ReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * The filter to search for the Report to update in case it exists.
     */
    where: ReportWhereUniqueInput
    /**
     * In case the Report found by the `where` argument doesn't exist, create a new Report with this data.
     */
    create: XOR<ReportCreateInput, ReportUncheckedCreateInput>
    /**
     * In case the Report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportUpdateInput, ReportUncheckedUpdateInput>
  }

  /**
   * Report delete
   */
  export type ReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
    /**
     * Filter which Report to delete.
     */
    where: ReportWhereUniqueInput
  }

  /**
   * Report deleteMany
   */
  export type ReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reports to delete
     */
    where?: ReportWhereInput
  }

  /**
   * Report.feedbackReport
   */
  export type Report$feedbackReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    where?: FeedbackReportWhereInput
  }

  /**
   * Report.productReport
   */
  export type Report$productReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    where?: ProductReportWhereInput
  }

  /**
   * Report.journeyPlan
   */
  export type Report$journeyPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JourneyPlan
     */
    select?: JourneyPlanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JourneyPlanInclude<ExtArgs> | null
    where?: JourneyPlanWhereInput
  }

  /**
   * Report.MyOrder
   */
  export type Report$MyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MyOrder
     */
    select?: MyOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MyOrderInclude<ExtArgs> | null
    where?: MyOrderWhereInput
    orderBy?: MyOrderOrderByWithRelationInput | MyOrderOrderByWithRelationInput[]
    cursor?: MyOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MyOrderScalarFieldEnum | MyOrderScalarFieldEnum[]
  }

  /**
   * Report.visibilityReport
   */
  export type Report$visibilityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    where?: VisibilityReportWhereInput
  }

  /**
   * Report without action
   */
  export type ReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Report
     */
    select?: ReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportInclude<ExtArgs> | null
  }


  /**
   * Model FeedbackReport
   */

  export type AggregateFeedbackReport = {
    _count: FeedbackReportCountAggregateOutputType | null
    _avg: FeedbackReportAvgAggregateOutputType | null
    _sum: FeedbackReportSumAggregateOutputType | null
    _min: FeedbackReportMinAggregateOutputType | null
    _max: FeedbackReportMaxAggregateOutputType | null
  }

  export type FeedbackReportAvgAggregateOutputType = {
    reportId: number | null
  }

  export type FeedbackReportSumAggregateOutputType = {
    reportId: number | null
  }

  export type FeedbackReportMinAggregateOutputType = {
    reportId: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type FeedbackReportMaxAggregateOutputType = {
    reportId: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type FeedbackReportCountAggregateOutputType = {
    reportId: number
    comment: number
    createdAt: number
    _all: number
  }


  export type FeedbackReportAvgAggregateInputType = {
    reportId?: true
  }

  export type FeedbackReportSumAggregateInputType = {
    reportId?: true
  }

  export type FeedbackReportMinAggregateInputType = {
    reportId?: true
    comment?: true
    createdAt?: true
  }

  export type FeedbackReportMaxAggregateInputType = {
    reportId?: true
    comment?: true
    createdAt?: true
  }

  export type FeedbackReportCountAggregateInputType = {
    reportId?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type FeedbackReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackReport to aggregate.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FeedbackReports
    **/
    _count?: true | FeedbackReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FeedbackReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FeedbackReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FeedbackReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FeedbackReportMaxAggregateInputType
  }

  export type GetFeedbackReportAggregateType<T extends FeedbackReportAggregateArgs> = {
        [P in keyof T & keyof AggregateFeedbackReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFeedbackReport[P]>
      : GetScalarType<T[P], AggregateFeedbackReport[P]>
  }




  export type FeedbackReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FeedbackReportWhereInput
    orderBy?: FeedbackReportOrderByWithAggregationInput | FeedbackReportOrderByWithAggregationInput[]
    by: FeedbackReportScalarFieldEnum[] | FeedbackReportScalarFieldEnum
    having?: FeedbackReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FeedbackReportCountAggregateInputType | true
    _avg?: FeedbackReportAvgAggregateInputType
    _sum?: FeedbackReportSumAggregateInputType
    _min?: FeedbackReportMinAggregateInputType
    _max?: FeedbackReportMaxAggregateInputType
  }

  export type FeedbackReportGroupByOutputType = {
    reportId: number
    comment: string | null
    createdAt: Date
    _count: FeedbackReportCountAggregateOutputType | null
    _avg: FeedbackReportAvgAggregateOutputType | null
    _sum: FeedbackReportSumAggregateOutputType | null
    _min: FeedbackReportMinAggregateOutputType | null
    _max: FeedbackReportMaxAggregateOutputType | null
  }

  type GetFeedbackReportGroupByPayload<T extends FeedbackReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FeedbackReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FeedbackReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FeedbackReportGroupByOutputType[P]>
            : GetScalarType<T[P], FeedbackReportGroupByOutputType[P]>
        }
      >
    >


  export type FeedbackReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reportId?: boolean
    comment?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["feedbackReport"]>


  export type FeedbackReportSelectScalar = {
    reportId?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type FeedbackReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $FeedbackReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FeedbackReport"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reportId: number
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["feedbackReport"]>
    composites: {}
  }

  type FeedbackReportGetPayload<S extends boolean | null | undefined | FeedbackReportDefaultArgs> = $Result.GetResult<Prisma.$FeedbackReportPayload, S>

  type FeedbackReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FeedbackReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FeedbackReportCountAggregateInputType | true
    }

  export interface FeedbackReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FeedbackReport'], meta: { name: 'FeedbackReport' } }
    /**
     * Find zero or one FeedbackReport that matches the filter.
     * @param {FeedbackReportFindUniqueArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FeedbackReportFindUniqueArgs>(args: SelectSubset<T, FeedbackReportFindUniqueArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FeedbackReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FeedbackReportFindUniqueOrThrowArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FeedbackReportFindUniqueOrThrowArgs>(args: SelectSubset<T, FeedbackReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FeedbackReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindFirstArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FeedbackReportFindFirstArgs>(args?: SelectSubset<T, FeedbackReportFindFirstArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FeedbackReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindFirstOrThrowArgs} args - Arguments to find a FeedbackReport
     * @example
     * // Get one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FeedbackReportFindFirstOrThrowArgs>(args?: SelectSubset<T, FeedbackReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FeedbackReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FeedbackReports
     * const feedbackReports = await prisma.feedbackReport.findMany()
     * 
     * // Get first 10 FeedbackReports
     * const feedbackReports = await prisma.feedbackReport.findMany({ take: 10 })
     * 
     * // Only select the `reportId`
     * const feedbackReportWithReportIdOnly = await prisma.feedbackReport.findMany({ select: { reportId: true } })
     * 
     */
    findMany<T extends FeedbackReportFindManyArgs>(args?: SelectSubset<T, FeedbackReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FeedbackReport.
     * @param {FeedbackReportCreateArgs} args - Arguments to create a FeedbackReport.
     * @example
     * // Create one FeedbackReport
     * const FeedbackReport = await prisma.feedbackReport.create({
     *   data: {
     *     // ... data to create a FeedbackReport
     *   }
     * })
     * 
     */
    create<T extends FeedbackReportCreateArgs>(args: SelectSubset<T, FeedbackReportCreateArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FeedbackReports.
     * @param {FeedbackReportCreateManyArgs} args - Arguments to create many FeedbackReports.
     * @example
     * // Create many FeedbackReports
     * const feedbackReport = await prisma.feedbackReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FeedbackReportCreateManyArgs>(args?: SelectSubset<T, FeedbackReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FeedbackReport.
     * @param {FeedbackReportDeleteArgs} args - Arguments to delete one FeedbackReport.
     * @example
     * // Delete one FeedbackReport
     * const FeedbackReport = await prisma.feedbackReport.delete({
     *   where: {
     *     // ... filter to delete one FeedbackReport
     *   }
     * })
     * 
     */
    delete<T extends FeedbackReportDeleteArgs>(args: SelectSubset<T, FeedbackReportDeleteArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FeedbackReport.
     * @param {FeedbackReportUpdateArgs} args - Arguments to update one FeedbackReport.
     * @example
     * // Update one FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FeedbackReportUpdateArgs>(args: SelectSubset<T, FeedbackReportUpdateArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FeedbackReports.
     * @param {FeedbackReportDeleteManyArgs} args - Arguments to filter FeedbackReports to delete.
     * @example
     * // Delete a few FeedbackReports
     * const { count } = await prisma.feedbackReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FeedbackReportDeleteManyArgs>(args?: SelectSubset<T, FeedbackReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FeedbackReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FeedbackReports
     * const feedbackReport = await prisma.feedbackReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FeedbackReportUpdateManyArgs>(args: SelectSubset<T, FeedbackReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FeedbackReport.
     * @param {FeedbackReportUpsertArgs} args - Arguments to update or create a FeedbackReport.
     * @example
     * // Update or create a FeedbackReport
     * const feedbackReport = await prisma.feedbackReport.upsert({
     *   create: {
     *     // ... data to create a FeedbackReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FeedbackReport we want to update
     *   }
     * })
     */
    upsert<T extends FeedbackReportUpsertArgs>(args: SelectSubset<T, FeedbackReportUpsertArgs<ExtArgs>>): Prisma__FeedbackReportClient<$Result.GetResult<Prisma.$FeedbackReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FeedbackReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportCountArgs} args - Arguments to filter FeedbackReports to count.
     * @example
     * // Count the number of FeedbackReports
     * const count = await prisma.feedbackReport.count({
     *   where: {
     *     // ... the filter for the FeedbackReports we want to count
     *   }
     * })
    **/
    count<T extends FeedbackReportCountArgs>(
      args?: Subset<T, FeedbackReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FeedbackReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FeedbackReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FeedbackReportAggregateArgs>(args: Subset<T, FeedbackReportAggregateArgs>): Prisma.PrismaPromise<GetFeedbackReportAggregateType<T>>

    /**
     * Group by FeedbackReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FeedbackReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FeedbackReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FeedbackReportGroupByArgs['orderBy'] }
        : { orderBy?: FeedbackReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FeedbackReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFeedbackReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FeedbackReport model
   */
  readonly fields: FeedbackReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FeedbackReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FeedbackReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FeedbackReport model
   */ 
  interface FeedbackReportFieldRefs {
    readonly reportId: FieldRef<"FeedbackReport", 'Int'>
    readonly comment: FieldRef<"FeedbackReport", 'String'>
    readonly createdAt: FieldRef<"FeedbackReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FeedbackReport findUnique
   */
  export type FeedbackReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport findUniqueOrThrow
   */
  export type FeedbackReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport findFirst
   */
  export type FeedbackReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackReports.
     */
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport findFirstOrThrow
   */
  export type FeedbackReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReport to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FeedbackReports.
     */
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport findMany
   */
  export type FeedbackReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter, which FeedbackReports to fetch.
     */
    where?: FeedbackReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FeedbackReports to fetch.
     */
    orderBy?: FeedbackReportOrderByWithRelationInput | FeedbackReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FeedbackReports.
     */
    cursor?: FeedbackReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FeedbackReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FeedbackReports.
     */
    skip?: number
    distinct?: FeedbackReportScalarFieldEnum | FeedbackReportScalarFieldEnum[]
  }

  /**
   * FeedbackReport create
   */
  export type FeedbackReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The data needed to create a FeedbackReport.
     */
    data: XOR<FeedbackReportCreateInput, FeedbackReportUncheckedCreateInput>
  }

  /**
   * FeedbackReport createMany
   */
  export type FeedbackReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FeedbackReports.
     */
    data: FeedbackReportCreateManyInput | FeedbackReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FeedbackReport update
   */
  export type FeedbackReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The data needed to update a FeedbackReport.
     */
    data: XOR<FeedbackReportUpdateInput, FeedbackReportUncheckedUpdateInput>
    /**
     * Choose, which FeedbackReport to update.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport updateMany
   */
  export type FeedbackReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FeedbackReports.
     */
    data: XOR<FeedbackReportUpdateManyMutationInput, FeedbackReportUncheckedUpdateManyInput>
    /**
     * Filter which FeedbackReports to update
     */
    where?: FeedbackReportWhereInput
  }

  /**
   * FeedbackReport upsert
   */
  export type FeedbackReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * The filter to search for the FeedbackReport to update in case it exists.
     */
    where: FeedbackReportWhereUniqueInput
    /**
     * In case the FeedbackReport found by the `where` argument doesn't exist, create a new FeedbackReport with this data.
     */
    create: XOR<FeedbackReportCreateInput, FeedbackReportUncheckedCreateInput>
    /**
     * In case the FeedbackReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FeedbackReportUpdateInput, FeedbackReportUncheckedUpdateInput>
  }

  /**
   * FeedbackReport delete
   */
  export type FeedbackReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
    /**
     * Filter which FeedbackReport to delete.
     */
    where: FeedbackReportWhereUniqueInput
  }

  /**
   * FeedbackReport deleteMany
   */
  export type FeedbackReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FeedbackReports to delete
     */
    where?: FeedbackReportWhereInput
  }

  /**
   * FeedbackReport without action
   */
  export type FeedbackReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FeedbackReport
     */
    select?: FeedbackReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FeedbackReportInclude<ExtArgs> | null
  }


  /**
   * Model ProductReport
   */

  export type AggregateProductReport = {
    _count: ProductReportCountAggregateOutputType | null
    _avg: ProductReportAvgAggregateOutputType | null
    _sum: ProductReportSumAggregateOutputType | null
    _min: ProductReportMinAggregateOutputType | null
    _max: ProductReportMaxAggregateOutputType | null
  }

  export type ProductReportAvgAggregateOutputType = {
    reportId: number | null
    quantity: number | null
  }

  export type ProductReportSumAggregateOutputType = {
    reportId: number | null
    quantity: number | null
  }

  export type ProductReportMinAggregateOutputType = {
    reportId: number | null
    productName: string | null
    quantity: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ProductReportMaxAggregateOutputType = {
    reportId: number | null
    productName: string | null
    quantity: number | null
    comment: string | null
    createdAt: Date | null
  }

  export type ProductReportCountAggregateOutputType = {
    reportId: number
    productName: number
    quantity: number
    comment: number
    createdAt: number
    _all: number
  }


  export type ProductReportAvgAggregateInputType = {
    reportId?: true
    quantity?: true
  }

  export type ProductReportSumAggregateInputType = {
    reportId?: true
    quantity?: true
  }

  export type ProductReportMinAggregateInputType = {
    reportId?: true
    productName?: true
    quantity?: true
    comment?: true
    createdAt?: true
  }

  export type ProductReportMaxAggregateInputType = {
    reportId?: true
    productName?: true
    quantity?: true
    comment?: true
    createdAt?: true
  }

  export type ProductReportCountAggregateInputType = {
    reportId?: true
    productName?: true
    quantity?: true
    comment?: true
    createdAt?: true
    _all?: true
  }

  export type ProductReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReport to aggregate.
     */
    where?: ProductReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReports to fetch.
     */
    orderBy?: ProductReportOrderByWithRelationInput | ProductReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductReports
    **/
    _count?: true | ProductReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductReportMaxAggregateInputType
  }

  export type GetProductReportAggregateType<T extends ProductReportAggregateArgs> = {
        [P in keyof T & keyof AggregateProductReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductReport[P]>
      : GetScalarType<T[P], AggregateProductReport[P]>
  }




  export type ProductReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductReportWhereInput
    orderBy?: ProductReportOrderByWithAggregationInput | ProductReportOrderByWithAggregationInput[]
    by: ProductReportScalarFieldEnum[] | ProductReportScalarFieldEnum
    having?: ProductReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductReportCountAggregateInputType | true
    _avg?: ProductReportAvgAggregateInputType
    _sum?: ProductReportSumAggregateInputType
    _min?: ProductReportMinAggregateInputType
    _max?: ProductReportMaxAggregateInputType
  }

  export type ProductReportGroupByOutputType = {
    reportId: number
    productName: string | null
    quantity: number | null
    comment: string | null
    createdAt: Date
    _count: ProductReportCountAggregateOutputType | null
    _avg: ProductReportAvgAggregateOutputType | null
    _sum: ProductReportSumAggregateOutputType | null
    _min: ProductReportMinAggregateOutputType | null
    _max: ProductReportMaxAggregateOutputType | null
  }

  type GetProductReportGroupByPayload<T extends ProductReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductReportGroupByOutputType[P]>
            : GetScalarType<T[P], ProductReportGroupByOutputType[P]>
        }
      >
    >


  export type ProductReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reportId?: boolean
    productName?: boolean
    quantity?: boolean
    comment?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productReport"]>


  export type ProductReportSelectScalar = {
    reportId?: boolean
    productName?: boolean
    quantity?: boolean
    comment?: boolean
    createdAt?: boolean
  }

  export type ProductReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $ProductReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductReport"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reportId: number
      productName: string | null
      quantity: number | null
      comment: string | null
      createdAt: Date
    }, ExtArgs["result"]["productReport"]>
    composites: {}
  }

  type ProductReportGetPayload<S extends boolean | null | undefined | ProductReportDefaultArgs> = $Result.GetResult<Prisma.$ProductReportPayload, S>

  type ProductReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProductReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProductReportCountAggregateInputType | true
    }

  export interface ProductReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductReport'], meta: { name: 'ProductReport' } }
    /**
     * Find zero or one ProductReport that matches the filter.
     * @param {ProductReportFindUniqueArgs} args - Arguments to find a ProductReport
     * @example
     * // Get one ProductReport
     * const productReport = await prisma.productReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductReportFindUniqueArgs>(args: SelectSubset<T, ProductReportFindUniqueArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProductReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProductReportFindUniqueOrThrowArgs} args - Arguments to find a ProductReport
     * @example
     * // Get one ProductReport
     * const productReport = await prisma.productReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProductReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportFindFirstArgs} args - Arguments to find a ProductReport
     * @example
     * // Get one ProductReport
     * const productReport = await prisma.productReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductReportFindFirstArgs>(args?: SelectSubset<T, ProductReportFindFirstArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProductReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportFindFirstOrThrowArgs} args - Arguments to find a ProductReport
     * @example
     * // Get one ProductReport
     * const productReport = await prisma.productReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProductReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductReports
     * const productReports = await prisma.productReport.findMany()
     * 
     * // Get first 10 ProductReports
     * const productReports = await prisma.productReport.findMany({ take: 10 })
     * 
     * // Only select the `reportId`
     * const productReportWithReportIdOnly = await prisma.productReport.findMany({ select: { reportId: true } })
     * 
     */
    findMany<T extends ProductReportFindManyArgs>(args?: SelectSubset<T, ProductReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProductReport.
     * @param {ProductReportCreateArgs} args - Arguments to create a ProductReport.
     * @example
     * // Create one ProductReport
     * const ProductReport = await prisma.productReport.create({
     *   data: {
     *     // ... data to create a ProductReport
     *   }
     * })
     * 
     */
    create<T extends ProductReportCreateArgs>(args: SelectSubset<T, ProductReportCreateArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProductReports.
     * @param {ProductReportCreateManyArgs} args - Arguments to create many ProductReports.
     * @example
     * // Create many ProductReports
     * const productReport = await prisma.productReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductReportCreateManyArgs>(args?: SelectSubset<T, ProductReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ProductReport.
     * @param {ProductReportDeleteArgs} args - Arguments to delete one ProductReport.
     * @example
     * // Delete one ProductReport
     * const ProductReport = await prisma.productReport.delete({
     *   where: {
     *     // ... filter to delete one ProductReport
     *   }
     * })
     * 
     */
    delete<T extends ProductReportDeleteArgs>(args: SelectSubset<T, ProductReportDeleteArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProductReport.
     * @param {ProductReportUpdateArgs} args - Arguments to update one ProductReport.
     * @example
     * // Update one ProductReport
     * const productReport = await prisma.productReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductReportUpdateArgs>(args: SelectSubset<T, ProductReportUpdateArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProductReports.
     * @param {ProductReportDeleteManyArgs} args - Arguments to filter ProductReports to delete.
     * @example
     * // Delete a few ProductReports
     * const { count } = await prisma.productReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductReportDeleteManyArgs>(args?: SelectSubset<T, ProductReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductReports
     * const productReport = await prisma.productReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductReportUpdateManyArgs>(args: SelectSubset<T, ProductReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProductReport.
     * @param {ProductReportUpsertArgs} args - Arguments to update or create a ProductReport.
     * @example
     * // Update or create a ProductReport
     * const productReport = await prisma.productReport.upsert({
     *   create: {
     *     // ... data to create a ProductReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductReport we want to update
     *   }
     * })
     */
    upsert<T extends ProductReportUpsertArgs>(args: SelectSubset<T, ProductReportUpsertArgs<ExtArgs>>): Prisma__ProductReportClient<$Result.GetResult<Prisma.$ProductReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProductReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportCountArgs} args - Arguments to filter ProductReports to count.
     * @example
     * // Count the number of ProductReports
     * const count = await prisma.productReport.count({
     *   where: {
     *     // ... the filter for the ProductReports we want to count
     *   }
     * })
    **/
    count<T extends ProductReportCountArgs>(
      args?: Subset<T, ProductReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductReportAggregateArgs>(args: Subset<T, ProductReportAggregateArgs>): Prisma.PrismaPromise<GetProductReportAggregateType<T>>

    /**
     * Group by ProductReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductReportGroupByArgs['orderBy'] }
        : { orderBy?: ProductReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductReport model
   */
  readonly fields: ProductReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductReport model
   */ 
  interface ProductReportFieldRefs {
    readonly reportId: FieldRef<"ProductReport", 'Int'>
    readonly productName: FieldRef<"ProductReport", 'String'>
    readonly quantity: FieldRef<"ProductReport", 'Int'>
    readonly comment: FieldRef<"ProductReport", 'String'>
    readonly createdAt: FieldRef<"ProductReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductReport findUnique
   */
  export type ProductReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReport to fetch.
     */
    where: ProductReportWhereUniqueInput
  }

  /**
   * ProductReport findUniqueOrThrow
   */
  export type ProductReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReport to fetch.
     */
    where: ProductReportWhereUniqueInput
  }

  /**
   * ProductReport findFirst
   */
  export type ProductReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReport to fetch.
     */
    where?: ProductReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReports to fetch.
     */
    orderBy?: ProductReportOrderByWithRelationInput | ProductReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReports.
     */
    cursor?: ProductReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReports.
     */
    distinct?: ProductReportScalarFieldEnum | ProductReportScalarFieldEnum[]
  }

  /**
   * ProductReport findFirstOrThrow
   */
  export type ProductReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReport to fetch.
     */
    where?: ProductReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReports to fetch.
     */
    orderBy?: ProductReportOrderByWithRelationInput | ProductReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductReports.
     */
    cursor?: ProductReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductReports.
     */
    distinct?: ProductReportScalarFieldEnum | ProductReportScalarFieldEnum[]
  }

  /**
   * ProductReport findMany
   */
  export type ProductReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter, which ProductReports to fetch.
     */
    where?: ProductReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductReports to fetch.
     */
    orderBy?: ProductReportOrderByWithRelationInput | ProductReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductReports.
     */
    cursor?: ProductReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductReports.
     */
    skip?: number
    distinct?: ProductReportScalarFieldEnum | ProductReportScalarFieldEnum[]
  }

  /**
   * ProductReport create
   */
  export type ProductReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductReport.
     */
    data: XOR<ProductReportCreateInput, ProductReportUncheckedCreateInput>
  }

  /**
   * ProductReport createMany
   */
  export type ProductReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductReports.
     */
    data: ProductReportCreateManyInput | ProductReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductReport update
   */
  export type ProductReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductReport.
     */
    data: XOR<ProductReportUpdateInput, ProductReportUncheckedUpdateInput>
    /**
     * Choose, which ProductReport to update.
     */
    where: ProductReportWhereUniqueInput
  }

  /**
   * ProductReport updateMany
   */
  export type ProductReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductReports.
     */
    data: XOR<ProductReportUpdateManyMutationInput, ProductReportUncheckedUpdateManyInput>
    /**
     * Filter which ProductReports to update
     */
    where?: ProductReportWhereInput
  }

  /**
   * ProductReport upsert
   */
  export type ProductReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductReport to update in case it exists.
     */
    where: ProductReportWhereUniqueInput
    /**
     * In case the ProductReport found by the `where` argument doesn't exist, create a new ProductReport with this data.
     */
    create: XOR<ProductReportCreateInput, ProductReportUncheckedCreateInput>
    /**
     * In case the ProductReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductReportUpdateInput, ProductReportUncheckedUpdateInput>
  }

  /**
   * ProductReport delete
   */
  export type ProductReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
    /**
     * Filter which ProductReport to delete.
     */
    where: ProductReportWhereUniqueInput
  }

  /**
   * ProductReport deleteMany
   */
  export type ProductReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductReports to delete
     */
    where?: ProductReportWhereInput
  }

  /**
   * ProductReport without action
   */
  export type ProductReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductReport
     */
    select?: ProductReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductReportInclude<ExtArgs> | null
  }


  /**
   * Model VisibilityReport
   */

  export type AggregateVisibilityReport = {
    _count: VisibilityReportCountAggregateOutputType | null
    _avg: VisibilityReportAvgAggregateOutputType | null
    _sum: VisibilityReportSumAggregateOutputType | null
    _min: VisibilityReportMinAggregateOutputType | null
    _max: VisibilityReportMaxAggregateOutputType | null
  }

  export type VisibilityReportAvgAggregateOutputType = {
    reportId: number | null
  }

  export type VisibilityReportSumAggregateOutputType = {
    reportId: number | null
  }

  export type VisibilityReportMinAggregateOutputType = {
    reportId: number | null
    comment: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type VisibilityReportMaxAggregateOutputType = {
    reportId: number | null
    comment: string | null
    imageUrl: string | null
    createdAt: Date | null
  }

  export type VisibilityReportCountAggregateOutputType = {
    reportId: number
    comment: number
    imageUrl: number
    createdAt: number
    _all: number
  }


  export type VisibilityReportAvgAggregateInputType = {
    reportId?: true
  }

  export type VisibilityReportSumAggregateInputType = {
    reportId?: true
  }

  export type VisibilityReportMinAggregateInputType = {
    reportId?: true
    comment?: true
    imageUrl?: true
    createdAt?: true
  }

  export type VisibilityReportMaxAggregateInputType = {
    reportId?: true
    comment?: true
    imageUrl?: true
    createdAt?: true
  }

  export type VisibilityReportCountAggregateInputType = {
    reportId?: true
    comment?: true
    imageUrl?: true
    createdAt?: true
    _all?: true
  }

  export type VisibilityReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisibilityReport to aggregate.
     */
    where?: VisibilityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisibilityReports to fetch.
     */
    orderBy?: VisibilityReportOrderByWithRelationInput | VisibilityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VisibilityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisibilityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisibilityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VisibilityReports
    **/
    _count?: true | VisibilityReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VisibilityReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VisibilityReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VisibilityReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VisibilityReportMaxAggregateInputType
  }

  export type GetVisibilityReportAggregateType<T extends VisibilityReportAggregateArgs> = {
        [P in keyof T & keyof AggregateVisibilityReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVisibilityReport[P]>
      : GetScalarType<T[P], AggregateVisibilityReport[P]>
  }




  export type VisibilityReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VisibilityReportWhereInput
    orderBy?: VisibilityReportOrderByWithAggregationInput | VisibilityReportOrderByWithAggregationInput[]
    by: VisibilityReportScalarFieldEnum[] | VisibilityReportScalarFieldEnum
    having?: VisibilityReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VisibilityReportCountAggregateInputType | true
    _avg?: VisibilityReportAvgAggregateInputType
    _sum?: VisibilityReportSumAggregateInputType
    _min?: VisibilityReportMinAggregateInputType
    _max?: VisibilityReportMaxAggregateInputType
  }

  export type VisibilityReportGroupByOutputType = {
    reportId: number
    comment: string | null
    imageUrl: string | null
    createdAt: Date
    _count: VisibilityReportCountAggregateOutputType | null
    _avg: VisibilityReportAvgAggregateOutputType | null
    _sum: VisibilityReportSumAggregateOutputType | null
    _min: VisibilityReportMinAggregateOutputType | null
    _max: VisibilityReportMaxAggregateOutputType | null
  }

  type GetVisibilityReportGroupByPayload<T extends VisibilityReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VisibilityReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VisibilityReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VisibilityReportGroupByOutputType[P]>
            : GetScalarType<T[P], VisibilityReportGroupByOutputType[P]>
        }
      >
    >


  export type VisibilityReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    reportId?: boolean
    comment?: boolean
    imageUrl?: boolean
    createdAt?: boolean
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["visibilityReport"]>


  export type VisibilityReportSelectScalar = {
    reportId?: boolean
    comment?: boolean
    imageUrl?: boolean
    createdAt?: boolean
  }

  export type VisibilityReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    report?: boolean | ReportDefaultArgs<ExtArgs>
  }

  export type $VisibilityReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VisibilityReport"
    objects: {
      report: Prisma.$ReportPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      reportId: number
      comment: string | null
      imageUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["visibilityReport"]>
    composites: {}
  }

  type VisibilityReportGetPayload<S extends boolean | null | undefined | VisibilityReportDefaultArgs> = $Result.GetResult<Prisma.$VisibilityReportPayload, S>

  type VisibilityReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VisibilityReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VisibilityReportCountAggregateInputType | true
    }

  export interface VisibilityReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VisibilityReport'], meta: { name: 'VisibilityReport' } }
    /**
     * Find zero or one VisibilityReport that matches the filter.
     * @param {VisibilityReportFindUniqueArgs} args - Arguments to find a VisibilityReport
     * @example
     * // Get one VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VisibilityReportFindUniqueArgs>(args: SelectSubset<T, VisibilityReportFindUniqueArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VisibilityReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VisibilityReportFindUniqueOrThrowArgs} args - Arguments to find a VisibilityReport
     * @example
     * // Get one VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VisibilityReportFindUniqueOrThrowArgs>(args: SelectSubset<T, VisibilityReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VisibilityReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportFindFirstArgs} args - Arguments to find a VisibilityReport
     * @example
     * // Get one VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VisibilityReportFindFirstArgs>(args?: SelectSubset<T, VisibilityReportFindFirstArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VisibilityReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportFindFirstOrThrowArgs} args - Arguments to find a VisibilityReport
     * @example
     * // Get one VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VisibilityReportFindFirstOrThrowArgs>(args?: SelectSubset<T, VisibilityReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VisibilityReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VisibilityReports
     * const visibilityReports = await prisma.visibilityReport.findMany()
     * 
     * // Get first 10 VisibilityReports
     * const visibilityReports = await prisma.visibilityReport.findMany({ take: 10 })
     * 
     * // Only select the `reportId`
     * const visibilityReportWithReportIdOnly = await prisma.visibilityReport.findMany({ select: { reportId: true } })
     * 
     */
    findMany<T extends VisibilityReportFindManyArgs>(args?: SelectSubset<T, VisibilityReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VisibilityReport.
     * @param {VisibilityReportCreateArgs} args - Arguments to create a VisibilityReport.
     * @example
     * // Create one VisibilityReport
     * const VisibilityReport = await prisma.visibilityReport.create({
     *   data: {
     *     // ... data to create a VisibilityReport
     *   }
     * })
     * 
     */
    create<T extends VisibilityReportCreateArgs>(args: SelectSubset<T, VisibilityReportCreateArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VisibilityReports.
     * @param {VisibilityReportCreateManyArgs} args - Arguments to create many VisibilityReports.
     * @example
     * // Create many VisibilityReports
     * const visibilityReport = await prisma.visibilityReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VisibilityReportCreateManyArgs>(args?: SelectSubset<T, VisibilityReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VisibilityReport.
     * @param {VisibilityReportDeleteArgs} args - Arguments to delete one VisibilityReport.
     * @example
     * // Delete one VisibilityReport
     * const VisibilityReport = await prisma.visibilityReport.delete({
     *   where: {
     *     // ... filter to delete one VisibilityReport
     *   }
     * })
     * 
     */
    delete<T extends VisibilityReportDeleteArgs>(args: SelectSubset<T, VisibilityReportDeleteArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VisibilityReport.
     * @param {VisibilityReportUpdateArgs} args - Arguments to update one VisibilityReport.
     * @example
     * // Update one VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VisibilityReportUpdateArgs>(args: SelectSubset<T, VisibilityReportUpdateArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VisibilityReports.
     * @param {VisibilityReportDeleteManyArgs} args - Arguments to filter VisibilityReports to delete.
     * @example
     * // Delete a few VisibilityReports
     * const { count } = await prisma.visibilityReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VisibilityReportDeleteManyArgs>(args?: SelectSubset<T, VisibilityReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VisibilityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VisibilityReports
     * const visibilityReport = await prisma.visibilityReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VisibilityReportUpdateManyArgs>(args: SelectSubset<T, VisibilityReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VisibilityReport.
     * @param {VisibilityReportUpsertArgs} args - Arguments to update or create a VisibilityReport.
     * @example
     * // Update or create a VisibilityReport
     * const visibilityReport = await prisma.visibilityReport.upsert({
     *   create: {
     *     // ... data to create a VisibilityReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VisibilityReport we want to update
     *   }
     * })
     */
    upsert<T extends VisibilityReportUpsertArgs>(args: SelectSubset<T, VisibilityReportUpsertArgs<ExtArgs>>): Prisma__VisibilityReportClient<$Result.GetResult<Prisma.$VisibilityReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VisibilityReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportCountArgs} args - Arguments to filter VisibilityReports to count.
     * @example
     * // Count the number of VisibilityReports
     * const count = await prisma.visibilityReport.count({
     *   where: {
     *     // ... the filter for the VisibilityReports we want to count
     *   }
     * })
    **/
    count<T extends VisibilityReportCountArgs>(
      args?: Subset<T, VisibilityReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VisibilityReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VisibilityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VisibilityReportAggregateArgs>(args: Subset<T, VisibilityReportAggregateArgs>): Prisma.PrismaPromise<GetVisibilityReportAggregateType<T>>

    /**
     * Group by VisibilityReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VisibilityReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VisibilityReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VisibilityReportGroupByArgs['orderBy'] }
        : { orderBy?: VisibilityReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VisibilityReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVisibilityReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VisibilityReport model
   */
  readonly fields: VisibilityReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VisibilityReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VisibilityReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    report<T extends ReportDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReportDefaultArgs<ExtArgs>>): Prisma__ReportClient<$Result.GetResult<Prisma.$ReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VisibilityReport model
   */ 
  interface VisibilityReportFieldRefs {
    readonly reportId: FieldRef<"VisibilityReport", 'Int'>
    readonly comment: FieldRef<"VisibilityReport", 'String'>
    readonly imageUrl: FieldRef<"VisibilityReport", 'String'>
    readonly createdAt: FieldRef<"VisibilityReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VisibilityReport findUnique
   */
  export type VisibilityReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter, which VisibilityReport to fetch.
     */
    where: VisibilityReportWhereUniqueInput
  }

  /**
   * VisibilityReport findUniqueOrThrow
   */
  export type VisibilityReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter, which VisibilityReport to fetch.
     */
    where: VisibilityReportWhereUniqueInput
  }

  /**
   * VisibilityReport findFirst
   */
  export type VisibilityReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter, which VisibilityReport to fetch.
     */
    where?: VisibilityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisibilityReports to fetch.
     */
    orderBy?: VisibilityReportOrderByWithRelationInput | VisibilityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisibilityReports.
     */
    cursor?: VisibilityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisibilityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisibilityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisibilityReports.
     */
    distinct?: VisibilityReportScalarFieldEnum | VisibilityReportScalarFieldEnum[]
  }

  /**
   * VisibilityReport findFirstOrThrow
   */
  export type VisibilityReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter, which VisibilityReport to fetch.
     */
    where?: VisibilityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisibilityReports to fetch.
     */
    orderBy?: VisibilityReportOrderByWithRelationInput | VisibilityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VisibilityReports.
     */
    cursor?: VisibilityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisibilityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisibilityReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VisibilityReports.
     */
    distinct?: VisibilityReportScalarFieldEnum | VisibilityReportScalarFieldEnum[]
  }

  /**
   * VisibilityReport findMany
   */
  export type VisibilityReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter, which VisibilityReports to fetch.
     */
    where?: VisibilityReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VisibilityReports to fetch.
     */
    orderBy?: VisibilityReportOrderByWithRelationInput | VisibilityReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VisibilityReports.
     */
    cursor?: VisibilityReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VisibilityReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VisibilityReports.
     */
    skip?: number
    distinct?: VisibilityReportScalarFieldEnum | VisibilityReportScalarFieldEnum[]
  }

  /**
   * VisibilityReport create
   */
  export type VisibilityReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * The data needed to create a VisibilityReport.
     */
    data: XOR<VisibilityReportCreateInput, VisibilityReportUncheckedCreateInput>
  }

  /**
   * VisibilityReport createMany
   */
  export type VisibilityReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VisibilityReports.
     */
    data: VisibilityReportCreateManyInput | VisibilityReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VisibilityReport update
   */
  export type VisibilityReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * The data needed to update a VisibilityReport.
     */
    data: XOR<VisibilityReportUpdateInput, VisibilityReportUncheckedUpdateInput>
    /**
     * Choose, which VisibilityReport to update.
     */
    where: VisibilityReportWhereUniqueInput
  }

  /**
   * VisibilityReport updateMany
   */
  export type VisibilityReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VisibilityReports.
     */
    data: XOR<VisibilityReportUpdateManyMutationInput, VisibilityReportUncheckedUpdateManyInput>
    /**
     * Filter which VisibilityReports to update
     */
    where?: VisibilityReportWhereInput
  }

  /**
   * VisibilityReport upsert
   */
  export type VisibilityReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * The filter to search for the VisibilityReport to update in case it exists.
     */
    where: VisibilityReportWhereUniqueInput
    /**
     * In case the VisibilityReport found by the `where` argument doesn't exist, create a new VisibilityReport with this data.
     */
    create: XOR<VisibilityReportCreateInput, VisibilityReportUncheckedCreateInput>
    /**
     * In case the VisibilityReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VisibilityReportUpdateInput, VisibilityReportUncheckedUpdateInput>
  }

  /**
   * VisibilityReport delete
   */
  export type VisibilityReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
    /**
     * Filter which VisibilityReport to delete.
     */
    where: VisibilityReportWhereUniqueInput
  }

  /**
   * VisibilityReport deleteMany
   */
  export type VisibilityReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VisibilityReports to delete
     */
    where?: VisibilityReportWhereInput
  }

  /**
   * VisibilityReport without action
   */
  export type VisibilityReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VisibilityReport
     */
    select?: VisibilityReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VisibilityReportInclude<ExtArgs> | null
  }


  /**
   * Model Leave
   */

  export type AggregateLeave = {
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  export type LeaveAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LeaveSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type LeaveMinAggregateOutputType = {
    id: number | null
    userId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    attachment: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    reason: string | null
    attachment: string | null
    status: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveCountAggregateOutputType = {
    id: number
    userId: number
    leaveType: number
    startDate: number
    endDate: number
    reason: number
    attachment: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LeaveSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type LeaveMinAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    reason?: true
    attachment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveMaxAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    reason?: true
    attachment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveCountAggregateInputType = {
    id?: true
    userId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    reason?: true
    attachment?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leave to aggregate.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaves
    **/
    _count?: true | LeaveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveMaxAggregateInputType
  }

  export type GetLeaveAggregateType<T extends LeaveAggregateArgs> = {
        [P in keyof T & keyof AggregateLeave]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeave[P]>
      : GetScalarType<T[P], AggregateLeave[P]>
  }




  export type LeaveGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveWhereInput
    orderBy?: LeaveOrderByWithAggregationInput | LeaveOrderByWithAggregationInput[]
    by: LeaveScalarFieldEnum[] | LeaveScalarFieldEnum
    having?: LeaveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveCountAggregateInputType | true
    _avg?: LeaveAvgAggregateInputType
    _sum?: LeaveSumAggregateInputType
    _min?: LeaveMinAggregateInputType
    _max?: LeaveMaxAggregateInputType
  }

  export type LeaveGroupByOutputType = {
    id: number
    userId: number
    leaveType: string
    startDate: Date
    endDate: Date
    reason: string
    attachment: string | null
    status: string
    createdAt: Date
    updatedAt: Date
    _count: LeaveCountAggregateOutputType | null
    _avg: LeaveAvgAggregateOutputType | null
    _sum: LeaveSumAggregateOutputType | null
    _min: LeaveMinAggregateOutputType | null
    _max: LeaveMaxAggregateOutputType | null
  }

  type GetLeaveGroupByPayload<T extends LeaveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveGroupByOutputType[P]>
        }
      >
    >


  export type LeaveSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leave"]>


  export type LeaveSelectScalar = {
    id?: boolean
    userId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    reason?: boolean
    attachment?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | SalesRepDefaultArgs<ExtArgs>
  }

  export type $LeavePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leave"
    objects: {
      user: Prisma.$SalesRepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      leaveType: string
      startDate: Date
      endDate: Date
      reason: string
      attachment: string | null
      status: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leave"]>
    composites: {}
  }

  type LeaveGetPayload<S extends boolean | null | undefined | LeaveDefaultArgs> = $Result.GetResult<Prisma.$LeavePayload, S>

  type LeaveCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveCountAggregateInputType | true
    }

  export interface LeaveDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leave'], meta: { name: 'Leave' } }
    /**
     * Find zero or one Leave that matches the filter.
     * @param {LeaveFindUniqueArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveFindUniqueArgs>(args: SelectSubset<T, LeaveFindUniqueArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Leave that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveFindUniqueOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Leave that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveFindFirstArgs>(args?: SelectSubset<T, LeaveFindFirstArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Leave that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindFirstOrThrowArgs} args - Arguments to find a Leave
     * @example
     * // Get one Leave
     * const leave = await prisma.leave.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leaves that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaves
     * const leaves = await prisma.leave.findMany()
     * 
     * // Get first 10 Leaves
     * const leaves = await prisma.leave.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveWithIdOnly = await prisma.leave.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveFindManyArgs>(args?: SelectSubset<T, LeaveFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Leave.
     * @param {LeaveCreateArgs} args - Arguments to create a Leave.
     * @example
     * // Create one Leave
     * const Leave = await prisma.leave.create({
     *   data: {
     *     // ... data to create a Leave
     *   }
     * })
     * 
     */
    create<T extends LeaveCreateArgs>(args: SelectSubset<T, LeaveCreateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leaves.
     * @param {LeaveCreateManyArgs} args - Arguments to create many Leaves.
     * @example
     * // Create many Leaves
     * const leave = await prisma.leave.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveCreateManyArgs>(args?: SelectSubset<T, LeaveCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leave.
     * @param {LeaveDeleteArgs} args - Arguments to delete one Leave.
     * @example
     * // Delete one Leave
     * const Leave = await prisma.leave.delete({
     *   where: {
     *     // ... filter to delete one Leave
     *   }
     * })
     * 
     */
    delete<T extends LeaveDeleteArgs>(args: SelectSubset<T, LeaveDeleteArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Leave.
     * @param {LeaveUpdateArgs} args - Arguments to update one Leave.
     * @example
     * // Update one Leave
     * const leave = await prisma.leave.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveUpdateArgs>(args: SelectSubset<T, LeaveUpdateArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leaves.
     * @param {LeaveDeleteManyArgs} args - Arguments to filter Leaves to delete.
     * @example
     * // Delete a few Leaves
     * const { count } = await prisma.leave.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveDeleteManyArgs>(args?: SelectSubset<T, LeaveDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaves
     * const leave = await prisma.leave.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveUpdateManyArgs>(args: SelectSubset<T, LeaveUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leave.
     * @param {LeaveUpsertArgs} args - Arguments to update or create a Leave.
     * @example
     * // Update or create a Leave
     * const leave = await prisma.leave.upsert({
     *   create: {
     *     // ... data to create a Leave
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leave we want to update
     *   }
     * })
     */
    upsert<T extends LeaveUpsertArgs>(args: SelectSubset<T, LeaveUpsertArgs<ExtArgs>>): Prisma__LeaveClient<$Result.GetResult<Prisma.$LeavePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leaves.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveCountArgs} args - Arguments to filter Leaves to count.
     * @example
     * // Count the number of Leaves
     * const count = await prisma.leave.count({
     *   where: {
     *     // ... the filter for the Leaves we want to count
     *   }
     * })
    **/
    count<T extends LeaveCountArgs>(
      args?: Subset<T, LeaveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveAggregateArgs>(args: Subset<T, LeaveAggregateArgs>): Prisma.PrismaPromise<GetLeaveAggregateType<T>>

    /**
     * Group by Leave.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveGroupByArgs['orderBy'] }
        : { orderBy?: LeaveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leave model
   */
  readonly fields: LeaveFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leave.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends SalesRepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SalesRepDefaultArgs<ExtArgs>>): Prisma__SalesRepClient<$Result.GetResult<Prisma.$SalesRepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leave model
   */ 
  interface LeaveFieldRefs {
    readonly id: FieldRef<"Leave", 'Int'>
    readonly userId: FieldRef<"Leave", 'Int'>
    readonly leaveType: FieldRef<"Leave", 'String'>
    readonly startDate: FieldRef<"Leave", 'DateTime'>
    readonly endDate: FieldRef<"Leave", 'DateTime'>
    readonly reason: FieldRef<"Leave", 'String'>
    readonly attachment: FieldRef<"Leave", 'String'>
    readonly status: FieldRef<"Leave", 'String'>
    readonly createdAt: FieldRef<"Leave", 'DateTime'>
    readonly updatedAt: FieldRef<"Leave", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leave findUnique
   */
  export type LeaveFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findUniqueOrThrow
   */
  export type LeaveFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave findFirst
   */
  export type LeaveFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findFirstOrThrow
   */
  export type LeaveFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leave to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaves.
     */
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave findMany
   */
  export type LeaveFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter, which Leaves to fetch.
     */
    where?: LeaveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaves to fetch.
     */
    orderBy?: LeaveOrderByWithRelationInput | LeaveOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaves.
     */
    cursor?: LeaveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaves from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaves.
     */
    skip?: number
    distinct?: LeaveScalarFieldEnum | LeaveScalarFieldEnum[]
  }

  /**
   * Leave create
   */
  export type LeaveCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to create a Leave.
     */
    data: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
  }

  /**
   * Leave createMany
   */
  export type LeaveCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaves.
     */
    data: LeaveCreateManyInput | LeaveCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leave update
   */
  export type LeaveUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The data needed to update a Leave.
     */
    data: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
    /**
     * Choose, which Leave to update.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave updateMany
   */
  export type LeaveUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaves.
     */
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyInput>
    /**
     * Filter which Leaves to update
     */
    where?: LeaveWhereInput
  }

  /**
   * Leave upsert
   */
  export type LeaveUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * The filter to search for the Leave to update in case it exists.
     */
    where: LeaveWhereUniqueInput
    /**
     * In case the Leave found by the `where` argument doesn't exist, create a new Leave with this data.
     */
    create: XOR<LeaveCreateInput, LeaveUncheckedCreateInput>
    /**
     * In case the Leave was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveUpdateInput, LeaveUncheckedUpdateInput>
  }

  /**
   * Leave delete
   */
  export type LeaveDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
    /**
     * Filter which Leave to delete.
     */
    where: LeaveWhereUniqueInput
  }

  /**
   * Leave deleteMany
   */
  export type LeaveDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaves to delete
     */
    where?: LeaveWhereInput
  }

  /**
   * Leave without action
   */
  export type LeaveDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leave
     */
    select?: LeaveSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const SalesRepScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phoneNumber: 'phoneNumber',
    password: 'password',
    countryId: 'countryId',
    region_id: 'region_id',
    region: 'region',
    role: 'role',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    photoUrl: 'photoUrl'
  };

  export type SalesRepScalarFieldEnum = (typeof SalesRepScalarFieldEnum)[keyof typeof SalesRepScalarFieldEnum]


  export const ManagerScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    department: 'department'
  };

  export type ManagerScalarFieldEnum = (typeof ManagerScalarFieldEnum)[keyof typeof ManagerScalarFieldEnum]


  export const TokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    salesRepId: 'salesRepId',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type TokenScalarFieldEnum = (typeof TokenScalarFieldEnum)[keyof typeof TokenScalarFieldEnum]


  export const RegionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    countryId: 'countryId',
    status: 'status'
  };

  export type RegionsScalarFieldEnum = (typeof RegionsScalarFieldEnum)[keyof typeof RegionsScalarFieldEnum]


  export const CountryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status'
  };

  export type CountryScalarFieldEnum = (typeof CountryScalarFieldEnum)[keyof typeof CountryScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category_id: 'category_id',
    category: 'category',
    description: 'description',
    currentStock: 'currentStock',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    clientId: 'clientId',
    image: 'image'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const CategoryScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type CategoryScalarFieldEnum = (typeof CategoryScalarFieldEnum)[keyof typeof CategoryScalarFieldEnum]


  export const PriceOptionScalarFieldEnum: {
    id: 'id',
    option: 'option',
    value: 'value',
    categoryId: 'categoryId'
  };

  export type PriceOptionScalarFieldEnum = (typeof PriceOptionScalarFieldEnum)[keyof typeof PriceOptionScalarFieldEnum]


  export const StoreQuantityScalarFieldEnum: {
    id: 'id',
    quantity: 'quantity',
    storeId: 'storeId',
    productId: 'productId'
  };

  export type StoreQuantityScalarFieldEnum = (typeof StoreQuantityScalarFieldEnum)[keyof typeof StoreQuantityScalarFieldEnum]


  export const StoresScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const PurchaseScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    storeId: 'storeId',
    quantity: 'quantity',
    totalPrice: 'totalPrice',
    date: 'date'
  };

  export type PurchaseScalarFieldEnum = (typeof PurchaseScalarFieldEnum)[keyof typeof PurchaseScalarFieldEnum]


  export const PurchaseHistoryScalarFieldEnum: {
    id: 'id',
    storeId: 'storeId',
    productId: 'productId',
    previousQuantity: 'previousQuantity',
    purchaseQuantity: 'purchaseQuantity',
    newBalance: 'newBalance',
    createdAt: 'createdAt'
  };

  export type PurchaseHistoryScalarFieldEnum = (typeof PurchaseHistoryScalarFieldEnum)[keyof typeof PurchaseHistoryScalarFieldEnum]


  export const ClientsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    latitude: 'latitude',
    longitude: 'longitude',
    balance: 'balance',
    email: 'email',
    region_id: 'region_id',
    region: 'region',
    contact: 'contact',
    tax_pin: 'tax_pin',
    location: 'location',
    status: 'status',
    client_type: 'client_type',
    countryId: 'countryId'
  };

  export type ClientsScalarFieldEnum = (typeof ClientsScalarFieldEnum)[keyof typeof ClientsScalarFieldEnum]


  export const RidersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact: 'contact',
    id_number: 'id_number',
    company_id: 'company_id',
    company: 'company',
    status: 'status',
    password: 'password',
    device_id: 'device_id',
    device_name: 'device_name',
    device_status: 'device_status',
    token: 'token'
  };

  export type RidersScalarFieldEnum = (typeof RidersScalarFieldEnum)[keyof typeof RidersScalarFieldEnum]


  export const RidersCompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    status: 'status'
  };

  export type RidersCompanyScalarFieldEnum = (typeof RidersCompanyScalarFieldEnum)[keyof typeof RidersCompanyScalarFieldEnum]


  export const ManagerCheckinScalarFieldEnum: {
    id: 'id',
    managerId: 'managerId',
    clientId: 'clientId',
    date: 'date',
    checkInAt: 'checkInAt',
    checkOutAt: 'checkOutAt',
    latitude: 'latitude',
    longitude: 'longitude',
    notes: 'notes'
  };

  export type ManagerCheckinScalarFieldEnum = (typeof ManagerCheckinScalarFieldEnum)[keyof typeof ManagerCheckinScalarFieldEnum]


  export const MyOrderScalarFieldEnum: {
    id: 'id',
    totalAmount: 'totalAmount',
    comment: 'comment',
    customerType: 'customerType',
    customerId: 'customerId',
    customerName: 'customerName',
    orderDate: 'orderDate',
    riderId: 'riderId',
    riderName: 'riderName',
    status: 'status',
    approvedTime: 'approvedTime',
    dispatchTime: 'dispatchTime',
    deliveryLocation: 'deliveryLocation',
    complete_latitude: 'complete_latitude',
    complete_longitude: 'complete_longitude',
    complete_address: 'complete_address',
    pickupTime: 'pickupTime',
    deliveryTime: 'deliveryTime',
    cancel_reason: 'cancel_reason',
    recepient: 'recepient',
    userId: 'userId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MyOrderScalarFieldEnum = (typeof MyOrderScalarFieldEnum)[keyof typeof MyOrderScalarFieldEnum]


  export const OrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    productId: 'productId',
    quantity: 'quantity',
    priceOptionId: 'priceOptionId'
  };

  export type OrderItemScalarFieldEnum = (typeof OrderItemScalarFieldEnum)[keyof typeof OrderItemScalarFieldEnum]


  export const JourneyPlanScalarFieldEnum: {
    id: 'id',
    date: 'date',
    time: 'time',
    userId: 'userId',
    clientId: 'clientId',
    status: 'status',
    checkInTime: 'checkInTime',
    latitude: 'latitude',
    longitude: 'longitude',
    imageUrl: 'imageUrl',
    notes: 'notes',
    checkoutLatitude: 'checkoutLatitude',
    checkoutLongitude: 'checkoutLongitude',
    checkoutTime: 'checkoutTime'
  };

  export type JourneyPlanScalarFieldEnum = (typeof JourneyPlanScalarFieldEnum)[keyof typeof JourneyPlanScalarFieldEnum]


  export const NoticeBoardScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NoticeBoardScalarFieldEnum = (typeof NoticeBoardScalarFieldEnum)[keyof typeof NoticeBoardScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    clientId: 'clientId',
    createdAt: 'createdAt',
    userId: 'userId',
    journeyPlanId: 'journeyPlanId',
    type: 'type'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const FeedbackReportScalarFieldEnum: {
    reportId: 'reportId',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type FeedbackReportScalarFieldEnum = (typeof FeedbackReportScalarFieldEnum)[keyof typeof FeedbackReportScalarFieldEnum]


  export const ProductReportScalarFieldEnum: {
    reportId: 'reportId',
    productName: 'productName',
    quantity: 'quantity',
    comment: 'comment',
    createdAt: 'createdAt'
  };

  export type ProductReportScalarFieldEnum = (typeof ProductReportScalarFieldEnum)[keyof typeof ProductReportScalarFieldEnum]


  export const VisibilityReportScalarFieldEnum: {
    reportId: 'reportId',
    comment: 'comment',
    imageUrl: 'imageUrl',
    createdAt: 'createdAt'
  };

  export type VisibilityReportScalarFieldEnum = (typeof VisibilityReportScalarFieldEnum)[keyof typeof VisibilityReportScalarFieldEnum]


  export const LeaveScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    reason: 'reason',
    attachment: 'attachment',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveScalarFieldEnum = (typeof LeaveScalarFieldEnum)[keyof typeof LeaveScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'ReportType'
   */
  export type EnumReportTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportType'>
    
  /**
   * Deep Input Types
   */


  export type SalesRepWhereInput = {
    AND?: SalesRepWhereInput | SalesRepWhereInput[]
    OR?: SalesRepWhereInput[]
    NOT?: SalesRepWhereInput | SalesRepWhereInput[]
    id?: IntFilter<"SalesRep"> | number
    name?: StringFilter<"SalesRep"> | string
    email?: StringFilter<"SalesRep"> | string
    phoneNumber?: StringFilter<"SalesRep"> | string
    password?: StringFilter<"SalesRep"> | string
    countryId?: IntFilter<"SalesRep"> | number
    region_id?: IntFilter<"SalesRep"> | number
    region?: StringFilter<"SalesRep"> | string
    role?: StringNullableFilter<"SalesRep"> | string | null
    status?: IntNullableFilter<"SalesRep"> | number | null
    createdAt?: DateTimeFilter<"SalesRep"> | Date | string
    updatedAt?: DateTimeFilter<"SalesRep"> | Date | string
    photoUrl?: StringNullableFilter<"SalesRep"> | string | null
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    journeyPlans?: JourneyPlanListRelationFilter
    reports?: ReportListRelationFilter
    tokens?: TokenListRelationFilter
    leaves?: LeaveListRelationFilter
    Manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    MyOrder?: MyOrderListRelationFilter
  }

  export type SalesRepOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
    journeyPlans?: JourneyPlanOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    tokens?: TokenOrderByRelationAggregateInput
    leaves?: LeaveOrderByRelationAggregateInput
    Manager?: ManagerOrderByWithRelationInput
    MyOrder?: MyOrderOrderByRelationAggregateInput
  }

  export type SalesRepWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    phoneNumber?: string
    AND?: SalesRepWhereInput | SalesRepWhereInput[]
    OR?: SalesRepWhereInput[]
    NOT?: SalesRepWhereInput | SalesRepWhereInput[]
    name?: StringFilter<"SalesRep"> | string
    password?: StringFilter<"SalesRep"> | string
    countryId?: IntFilter<"SalesRep"> | number
    region_id?: IntFilter<"SalesRep"> | number
    region?: StringFilter<"SalesRep"> | string
    role?: StringNullableFilter<"SalesRep"> | string | null
    status?: IntNullableFilter<"SalesRep"> | number | null
    createdAt?: DateTimeFilter<"SalesRep"> | Date | string
    updatedAt?: DateTimeFilter<"SalesRep"> | Date | string
    photoUrl?: StringNullableFilter<"SalesRep"> | string | null
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    journeyPlans?: JourneyPlanListRelationFilter
    reports?: ReportListRelationFilter
    tokens?: TokenListRelationFilter
    leaves?: LeaveListRelationFilter
    Manager?: XOR<ManagerNullableRelationFilter, ManagerWhereInput> | null
    MyOrder?: MyOrderListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type SalesRepOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    role?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photoUrl?: SortOrderInput | SortOrder
    _count?: SalesRepCountOrderByAggregateInput
    _avg?: SalesRepAvgOrderByAggregateInput
    _max?: SalesRepMaxOrderByAggregateInput
    _min?: SalesRepMinOrderByAggregateInput
    _sum?: SalesRepSumOrderByAggregateInput
  }

  export type SalesRepScalarWhereWithAggregatesInput = {
    AND?: SalesRepScalarWhereWithAggregatesInput | SalesRepScalarWhereWithAggregatesInput[]
    OR?: SalesRepScalarWhereWithAggregatesInput[]
    NOT?: SalesRepScalarWhereWithAggregatesInput | SalesRepScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SalesRep"> | number
    name?: StringWithAggregatesFilter<"SalesRep"> | string
    email?: StringWithAggregatesFilter<"SalesRep"> | string
    phoneNumber?: StringWithAggregatesFilter<"SalesRep"> | string
    password?: StringWithAggregatesFilter<"SalesRep"> | string
    countryId?: IntWithAggregatesFilter<"SalesRep"> | number
    region_id?: IntWithAggregatesFilter<"SalesRep"> | number
    region?: StringWithAggregatesFilter<"SalesRep"> | string
    role?: StringNullableWithAggregatesFilter<"SalesRep"> | string | null
    status?: IntNullableWithAggregatesFilter<"SalesRep"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"SalesRep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalesRep"> | Date | string
    photoUrl?: StringNullableWithAggregatesFilter<"SalesRep"> | string | null
  }

  export type ManagerWhereInput = {
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    id?: IntFilter<"Manager"> | number
    userId?: IntFilter<"Manager"> | number
    department?: StringNullableFilter<"Manager"> | string | null
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    checkins?: ManagerCheckinListRelationFilter
  }

  export type ManagerOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrderInput | SortOrder
    user?: SalesRepOrderByWithRelationInput
    checkins?: ManagerCheckinOrderByRelationAggregateInput
  }

  export type ManagerWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: ManagerWhereInput | ManagerWhereInput[]
    OR?: ManagerWhereInput[]
    NOT?: ManagerWhereInput | ManagerWhereInput[]
    department?: StringNullableFilter<"Manager"> | string | null
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    checkins?: ManagerCheckinListRelationFilter
  }, "id" | "userId">

  export type ManagerOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrderInput | SortOrder
    _count?: ManagerCountOrderByAggregateInput
    _avg?: ManagerAvgOrderByAggregateInput
    _max?: ManagerMaxOrderByAggregateInput
    _min?: ManagerMinOrderByAggregateInput
    _sum?: ManagerSumOrderByAggregateInput
  }

  export type ManagerScalarWhereWithAggregatesInput = {
    AND?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    OR?: ManagerScalarWhereWithAggregatesInput[]
    NOT?: ManagerScalarWhereWithAggregatesInput | ManagerScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Manager"> | number
    userId?: IntWithAggregatesFilter<"Manager"> | number
    department?: StringNullableWithAggregatesFilter<"Manager"> | string | null
  }

  export type TokenWhereInput = {
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    id?: IntFilter<"Token"> | number
    token?: StringFilter<"Token"> | string
    salesRepId?: IntFilter<"Token"> | number
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
  }

  export type TokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    salesRepId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    user?: SalesRepOrderByWithRelationInput
  }

  export type TokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TokenWhereInput | TokenWhereInput[]
    OR?: TokenWhereInput[]
    NOT?: TokenWhereInput | TokenWhereInput[]
    token?: StringFilter<"Token"> | string
    salesRepId?: IntFilter<"Token"> | number
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
  }, "id">

  export type TokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    salesRepId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: TokenCountOrderByAggregateInput
    _avg?: TokenAvgOrderByAggregateInput
    _max?: TokenMaxOrderByAggregateInput
    _min?: TokenMinOrderByAggregateInput
    _sum?: TokenSumOrderByAggregateInput
  }

  export type TokenScalarWhereWithAggregatesInput = {
    AND?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    OR?: TokenScalarWhereWithAggregatesInput[]
    NOT?: TokenScalarWhereWithAggregatesInput | TokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Token"> | number
    token?: StringWithAggregatesFilter<"Token"> | string
    salesRepId?: IntWithAggregatesFilter<"Token"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"Token"> | Date | string
  }

  export type RegionsWhereInput = {
    AND?: RegionsWhereInput | RegionsWhereInput[]
    OR?: RegionsWhereInput[]
    NOT?: RegionsWhereInput | RegionsWhereInput[]
    id?: IntFilter<"Regions"> | number
    name?: StringFilter<"Regions"> | string
    countryId?: IntFilter<"Regions"> | number
    status?: IntNullableFilter<"Regions"> | number | null
    country?: XOR<CountryRelationFilter, CountryWhereInput>
  }

  export type RegionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    status?: SortOrderInput | SortOrder
    country?: CountryOrderByWithRelationInput
  }

  export type RegionsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_countryId?: RegionsNameCountryIdCompoundUniqueInput
    AND?: RegionsWhereInput | RegionsWhereInput[]
    OR?: RegionsWhereInput[]
    NOT?: RegionsWhereInput | RegionsWhereInput[]
    name?: StringFilter<"Regions"> | string
    countryId?: IntFilter<"Regions"> | number
    status?: IntNullableFilter<"Regions"> | number | null
    country?: XOR<CountryRelationFilter, CountryWhereInput>
  }, "id" | "name_countryId">

  export type RegionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: RegionsCountOrderByAggregateInput
    _avg?: RegionsAvgOrderByAggregateInput
    _max?: RegionsMaxOrderByAggregateInput
    _min?: RegionsMinOrderByAggregateInput
    _sum?: RegionsSumOrderByAggregateInput
  }

  export type RegionsScalarWhereWithAggregatesInput = {
    AND?: RegionsScalarWhereWithAggregatesInput | RegionsScalarWhereWithAggregatesInput[]
    OR?: RegionsScalarWhereWithAggregatesInput[]
    NOT?: RegionsScalarWhereWithAggregatesInput | RegionsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Regions"> | number
    name?: StringWithAggregatesFilter<"Regions"> | string
    countryId?: IntWithAggregatesFilter<"Regions"> | number
    status?: IntNullableWithAggregatesFilter<"Regions"> | number | null
  }

  export type CountryWhereInput = {
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    id?: IntFilter<"Country"> | number
    name?: StringFilter<"Country"> | string
    status?: IntNullableFilter<"Country"> | number | null
    regions?: RegionsListRelationFilter
    clients?: ClientsListRelationFilter
    salesRep?: SalesRepListRelationFilter
  }

  export type CountryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    regions?: RegionsOrderByRelationAggregateInput
    clients?: ClientsOrderByRelationAggregateInput
    salesRep?: SalesRepOrderByRelationAggregateInput
  }

  export type CountryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CountryWhereInput | CountryWhereInput[]
    OR?: CountryWhereInput[]
    NOT?: CountryWhereInput | CountryWhereInput[]
    name?: StringFilter<"Country"> | string
    status?: IntNullableFilter<"Country"> | number | null
    regions?: RegionsListRelationFilter
    clients?: ClientsListRelationFilter
    salesRep?: SalesRepListRelationFilter
  }, "id">

  export type CountryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: CountryCountOrderByAggregateInput
    _avg?: CountryAvgOrderByAggregateInput
    _max?: CountryMaxOrderByAggregateInput
    _min?: CountryMinOrderByAggregateInput
    _sum?: CountrySumOrderByAggregateInput
  }

  export type CountryScalarWhereWithAggregatesInput = {
    AND?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    OR?: CountryScalarWhereWithAggregatesInput[]
    NOT?: CountryScalarWhereWithAggregatesInput | CountryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Country"> | number
    name?: StringWithAggregatesFilter<"Country"> | string
    status?: IntNullableWithAggregatesFilter<"Country"> | number | null
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    category_id?: IntFilter<"Product"> | number
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    currentStock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    clientId?: IntNullableFilter<"Product"> | number | null
    image?: StringNullableFilter<"Product"> | string | null
    client?: XOR<ClientsNullableRelationFilter, ClientsWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    storeQuantities?: StoreQuantityListRelationFilter
    purchase?: PurchaseListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    currentStock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    client?: ClientsOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    storeQuantities?: StoreQuantityOrderByRelationAggregateInput
    purchase?: PurchaseOrderByRelationAggregateInput
    purchaseHistory?: PurchaseHistoryOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    category_id?: IntFilter<"Product"> | number
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    currentStock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    clientId?: IntNullableFilter<"Product"> | number | null
    image?: StringNullableFilter<"Product"> | string | null
    client?: XOR<ClientsNullableRelationFilter, ClientsWhereInput> | null
    orderItems?: OrderItemListRelationFilter
    storeQuantities?: StoreQuantityListRelationFilter
    purchase?: PurchaseListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    category?: SortOrder
    description?: SortOrderInput | SortOrder
    currentStock?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Product"> | number
    name?: StringWithAggregatesFilter<"Product"> | string
    category_id?: IntWithAggregatesFilter<"Product"> | number
    category?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    currentStock?: IntNullableWithAggregatesFilter<"Product"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    clientId?: IntNullableWithAggregatesFilter<"Product"> | number | null
    image?: StringNullableWithAggregatesFilter<"Product"> | string | null
  }

  export type CategoryWhereInput = {
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    id?: IntFilter<"Category"> | number
    name?: StringFilter<"Category"> | string
    priceOptions?: PriceOptionListRelationFilter
  }

  export type CategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    priceOptions?: PriceOptionOrderByRelationAggregateInput
  }

  export type CategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CategoryWhereInput | CategoryWhereInput[]
    OR?: CategoryWhereInput[]
    NOT?: CategoryWhereInput | CategoryWhereInput[]
    name?: StringFilter<"Category"> | string
    priceOptions?: PriceOptionListRelationFilter
  }, "id">

  export type CategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: CategoryCountOrderByAggregateInput
    _avg?: CategoryAvgOrderByAggregateInput
    _max?: CategoryMaxOrderByAggregateInput
    _min?: CategoryMinOrderByAggregateInput
    _sum?: CategorySumOrderByAggregateInput
  }

  export type CategoryScalarWhereWithAggregatesInput = {
    AND?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    OR?: CategoryScalarWhereWithAggregatesInput[]
    NOT?: CategoryScalarWhereWithAggregatesInput | CategoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Category"> | number
    name?: StringWithAggregatesFilter<"Category"> | string
  }

  export type PriceOptionWhereInput = {
    AND?: PriceOptionWhereInput | PriceOptionWhereInput[]
    OR?: PriceOptionWhereInput[]
    NOT?: PriceOptionWhereInput | PriceOptionWhereInput[]
    id?: IntFilter<"PriceOption"> | number
    option?: StringFilter<"PriceOption"> | string
    value?: IntFilter<"PriceOption"> | number
    categoryId?: IntFilter<"PriceOption"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
  }

  export type PriceOptionOrderByWithRelationInput = {
    id?: SortOrder
    option?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    category?: CategoryOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
  }

  export type PriceOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PriceOptionWhereInput | PriceOptionWhereInput[]
    OR?: PriceOptionWhereInput[]
    NOT?: PriceOptionWhereInput | PriceOptionWhereInput[]
    option?: StringFilter<"PriceOption"> | string
    value?: IntFilter<"PriceOption"> | number
    categoryId?: IntFilter<"PriceOption"> | number
    category?: XOR<CategoryRelationFilter, CategoryWhereInput>
    orderItems?: OrderItemListRelationFilter
  }, "id">

  export type PriceOptionOrderByWithAggregationInput = {
    id?: SortOrder
    option?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
    _count?: PriceOptionCountOrderByAggregateInput
    _avg?: PriceOptionAvgOrderByAggregateInput
    _max?: PriceOptionMaxOrderByAggregateInput
    _min?: PriceOptionMinOrderByAggregateInput
    _sum?: PriceOptionSumOrderByAggregateInput
  }

  export type PriceOptionScalarWhereWithAggregatesInput = {
    AND?: PriceOptionScalarWhereWithAggregatesInput | PriceOptionScalarWhereWithAggregatesInput[]
    OR?: PriceOptionScalarWhereWithAggregatesInput[]
    NOT?: PriceOptionScalarWhereWithAggregatesInput | PriceOptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PriceOption"> | number
    option?: StringWithAggregatesFilter<"PriceOption"> | string
    value?: IntWithAggregatesFilter<"PriceOption"> | number
    categoryId?: IntWithAggregatesFilter<"PriceOption"> | number
  }

  export type StoreQuantityWhereInput = {
    AND?: StoreQuantityWhereInput | StoreQuantityWhereInput[]
    OR?: StoreQuantityWhereInput[]
    NOT?: StoreQuantityWhereInput | StoreQuantityWhereInput[]
    id?: IntFilter<"StoreQuantity"> | number
    quantity?: IntFilter<"StoreQuantity"> | number
    storeId?: IntFilter<"StoreQuantity"> | number
    productId?: IntFilter<"StoreQuantity"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type StoreQuantityOrderByWithRelationInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    product?: ProductOrderByWithRelationInput
    store?: StoresOrderByWithRelationInput
  }

  export type StoreQuantityWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StoreQuantityWhereInput | StoreQuantityWhereInput[]
    OR?: StoreQuantityWhereInput[]
    NOT?: StoreQuantityWhereInput | StoreQuantityWhereInput[]
    quantity?: IntFilter<"StoreQuantity"> | number
    storeId?: IntFilter<"StoreQuantity"> | number
    productId?: IntFilter<"StoreQuantity"> | number
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type StoreQuantityOrderByWithAggregationInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    _count?: StoreQuantityCountOrderByAggregateInput
    _avg?: StoreQuantityAvgOrderByAggregateInput
    _max?: StoreQuantityMaxOrderByAggregateInput
    _min?: StoreQuantityMinOrderByAggregateInput
    _sum?: StoreQuantitySumOrderByAggregateInput
  }

  export type StoreQuantityScalarWhereWithAggregatesInput = {
    AND?: StoreQuantityScalarWhereWithAggregatesInput | StoreQuantityScalarWhereWithAggregatesInput[]
    OR?: StoreQuantityScalarWhereWithAggregatesInput[]
    NOT?: StoreQuantityScalarWhereWithAggregatesInput | StoreQuantityScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"StoreQuantity"> | number
    quantity?: IntWithAggregatesFilter<"StoreQuantity"> | number
    storeId?: IntWithAggregatesFilter<"StoreQuantity"> | number
    productId?: IntWithAggregatesFilter<"StoreQuantity"> | number
  }

  export type StoresWhereInput = {
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    id?: IntFilter<"Stores"> | number
    name?: StringFilter<"Stores"> | string
    storeQuantities?: StoreQuantityListRelationFilter
    purchase?: PurchaseListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
  }

  export type StoresOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    storeQuantities?: StoreQuantityOrderByRelationAggregateInput
    purchase?: PurchaseOrderByRelationAggregateInput
    purchaseHistory?: PurchaseHistoryOrderByRelationAggregateInput
  }

  export type StoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: StoresWhereInput | StoresWhereInput[]
    OR?: StoresWhereInput[]
    NOT?: StoresWhereInput | StoresWhereInput[]
    name?: StringFilter<"Stores"> | string
    storeQuantities?: StoreQuantityListRelationFilter
    purchase?: PurchaseListRelationFilter
    purchaseHistory?: PurchaseHistoryListRelationFilter
  }, "id">

  export type StoresOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: StoresCountOrderByAggregateInput
    _avg?: StoresAvgOrderByAggregateInput
    _max?: StoresMaxOrderByAggregateInput
    _min?: StoresMinOrderByAggregateInput
    _sum?: StoresSumOrderByAggregateInput
  }

  export type StoresScalarWhereWithAggregatesInput = {
    AND?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    OR?: StoresScalarWhereWithAggregatesInput[]
    NOT?: StoresScalarWhereWithAggregatesInput | StoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Stores"> | number
    name?: StringWithAggregatesFilter<"Stores"> | string
  }

  export type PurchaseWhereInput = {
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    id?: IntFilter<"Purchase"> | number
    productId?: IntFilter<"Purchase"> | number
    storeId?: IntFilter<"Purchase"> | number
    quantity?: IntFilter<"Purchase"> | number
    totalPrice?: IntFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoresRelationFilter, StoresWhereInput>
  }

  export type PurchaseOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    date?: SortOrder
    product?: ProductOrderByWithRelationInput
    store?: StoresOrderByWithRelationInput
  }

  export type PurchaseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseWhereInput | PurchaseWhereInput[]
    OR?: PurchaseWhereInput[]
    NOT?: PurchaseWhereInput | PurchaseWhereInput[]
    productId?: IntFilter<"Purchase"> | number
    storeId?: IntFilter<"Purchase"> | number
    quantity?: IntFilter<"Purchase"> | number
    totalPrice?: IntFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
    product?: XOR<ProductRelationFilter, ProductWhereInput>
    store?: XOR<StoresRelationFilter, StoresWhereInput>
  }, "id">

  export type PurchaseOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    date?: SortOrder
    _count?: PurchaseCountOrderByAggregateInput
    _avg?: PurchaseAvgOrderByAggregateInput
    _max?: PurchaseMaxOrderByAggregateInput
    _min?: PurchaseMinOrderByAggregateInput
    _sum?: PurchaseSumOrderByAggregateInput
  }

  export type PurchaseScalarWhereWithAggregatesInput = {
    AND?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    OR?: PurchaseScalarWhereWithAggregatesInput[]
    NOT?: PurchaseScalarWhereWithAggregatesInput | PurchaseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Purchase"> | number
    productId?: IntWithAggregatesFilter<"Purchase"> | number
    storeId?: IntWithAggregatesFilter<"Purchase"> | number
    quantity?: IntWithAggregatesFilter<"Purchase"> | number
    totalPrice?: IntWithAggregatesFilter<"Purchase"> | number
    date?: DateTimeWithAggregatesFilter<"Purchase"> | Date | string
  }

  export type PurchaseHistoryWhereInput = {
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    id?: IntFilter<"PurchaseHistory"> | number
    storeId?: IntFilter<"PurchaseHistory"> | number
    productId?: IntFilter<"PurchaseHistory"> | number
    previousQuantity?: IntFilter<"PurchaseHistory"> | number
    purchaseQuantity?: IntFilter<"PurchaseHistory"> | number
    newBalance?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    store?: XOR<StoresRelationFilter, StoresWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type PurchaseHistoryOrderByWithRelationInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
    createdAt?: SortOrder
    store?: StoresOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type PurchaseHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    OR?: PurchaseHistoryWhereInput[]
    NOT?: PurchaseHistoryWhereInput | PurchaseHistoryWhereInput[]
    storeId?: IntFilter<"PurchaseHistory"> | number
    productId?: IntFilter<"PurchaseHistory"> | number
    previousQuantity?: IntFilter<"PurchaseHistory"> | number
    purchaseQuantity?: IntFilter<"PurchaseHistory"> | number
    newBalance?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
    store?: XOR<StoresRelationFilter, StoresWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id">

  export type PurchaseHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
    createdAt?: SortOrder
    _count?: PurchaseHistoryCountOrderByAggregateInput
    _avg?: PurchaseHistoryAvgOrderByAggregateInput
    _max?: PurchaseHistoryMaxOrderByAggregateInput
    _min?: PurchaseHistoryMinOrderByAggregateInput
    _sum?: PurchaseHistorySumOrderByAggregateInput
  }

  export type PurchaseHistoryScalarWhereWithAggregatesInput = {
    AND?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    OR?: PurchaseHistoryScalarWhereWithAggregatesInput[]
    NOT?: PurchaseHistoryScalarWhereWithAggregatesInput | PurchaseHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    storeId?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    productId?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    previousQuantity?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    purchaseQuantity?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    newBalance?: IntWithAggregatesFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PurchaseHistory"> | Date | string
  }

  export type ClientsWhereInput = {
    AND?: ClientsWhereInput | ClientsWhereInput[]
    OR?: ClientsWhereInput[]
    NOT?: ClientsWhereInput | ClientsWhereInput[]
    id?: IntFilter<"Clients"> | number
    name?: StringFilter<"Clients"> | string
    address?: StringNullableFilter<"Clients"> | string | null
    latitude?: FloatNullableFilter<"Clients"> | number | null
    longitude?: FloatNullableFilter<"Clients"> | number | null
    balance?: StringNullableFilter<"Clients"> | string | null
    email?: StringNullableFilter<"Clients"> | string | null
    region_id?: IntFilter<"Clients"> | number
    region?: StringFilter<"Clients"> | string
    contact?: StringFilter<"Clients"> | string
    tax_pin?: StringFilter<"Clients"> | string
    location?: StringFilter<"Clients"> | string
    status?: IntFilter<"Clients"> | number
    client_type?: IntNullableFilter<"Clients"> | number | null
    countryId?: IntFilter<"Clients"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    journeyPlans?: JourneyPlanListRelationFilter
    MyOrder?: MyOrderListRelationFilter
    products?: ProductListRelationFilter
    reports?: ReportListRelationFilter
    checkins?: ManagerCheckinListRelationFilter
  }

  export type ClientsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    region_id?: SortOrder
    region?: SortOrder
    contact?: SortOrder
    tax_pin?: SortOrder
    location?: SortOrder
    status?: SortOrder
    client_type?: SortOrderInput | SortOrder
    countryId?: SortOrder
    country?: CountryOrderByWithRelationInput
    journeyPlans?: JourneyPlanOrderByRelationAggregateInput
    MyOrder?: MyOrderOrderByRelationAggregateInput
    products?: ProductOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
    checkins?: ManagerCheckinOrderByRelationAggregateInput
  }

  export type ClientsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ClientsWhereInput | ClientsWhereInput[]
    OR?: ClientsWhereInput[]
    NOT?: ClientsWhereInput | ClientsWhereInput[]
    name?: StringFilter<"Clients"> | string
    address?: StringNullableFilter<"Clients"> | string | null
    latitude?: FloatNullableFilter<"Clients"> | number | null
    longitude?: FloatNullableFilter<"Clients"> | number | null
    balance?: StringNullableFilter<"Clients"> | string | null
    email?: StringNullableFilter<"Clients"> | string | null
    region_id?: IntFilter<"Clients"> | number
    region?: StringFilter<"Clients"> | string
    contact?: StringFilter<"Clients"> | string
    tax_pin?: StringFilter<"Clients"> | string
    location?: StringFilter<"Clients"> | string
    status?: IntFilter<"Clients"> | number
    client_type?: IntNullableFilter<"Clients"> | number | null
    countryId?: IntFilter<"Clients"> | number
    country?: XOR<CountryRelationFilter, CountryWhereInput>
    journeyPlans?: JourneyPlanListRelationFilter
    MyOrder?: MyOrderListRelationFilter
    products?: ProductListRelationFilter
    reports?: ReportListRelationFilter
    checkins?: ManagerCheckinListRelationFilter
  }, "id">

  export type ClientsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    balance?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    region_id?: SortOrder
    region?: SortOrder
    contact?: SortOrder
    tax_pin?: SortOrder
    location?: SortOrder
    status?: SortOrder
    client_type?: SortOrderInput | SortOrder
    countryId?: SortOrder
    _count?: ClientsCountOrderByAggregateInput
    _avg?: ClientsAvgOrderByAggregateInput
    _max?: ClientsMaxOrderByAggregateInput
    _min?: ClientsMinOrderByAggregateInput
    _sum?: ClientsSumOrderByAggregateInput
  }

  export type ClientsScalarWhereWithAggregatesInput = {
    AND?: ClientsScalarWhereWithAggregatesInput | ClientsScalarWhereWithAggregatesInput[]
    OR?: ClientsScalarWhereWithAggregatesInput[]
    NOT?: ClientsScalarWhereWithAggregatesInput | ClientsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Clients"> | number
    name?: StringWithAggregatesFilter<"Clients"> | string
    address?: StringNullableWithAggregatesFilter<"Clients"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Clients"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Clients"> | number | null
    balance?: StringNullableWithAggregatesFilter<"Clients"> | string | null
    email?: StringNullableWithAggregatesFilter<"Clients"> | string | null
    region_id?: IntWithAggregatesFilter<"Clients"> | number
    region?: StringWithAggregatesFilter<"Clients"> | string
    contact?: StringWithAggregatesFilter<"Clients"> | string
    tax_pin?: StringWithAggregatesFilter<"Clients"> | string
    location?: StringWithAggregatesFilter<"Clients"> | string
    status?: IntWithAggregatesFilter<"Clients"> | number
    client_type?: IntNullableWithAggregatesFilter<"Clients"> | number | null
    countryId?: IntWithAggregatesFilter<"Clients"> | number
  }

  export type RidersWhereInput = {
    AND?: RidersWhereInput | RidersWhereInput[]
    OR?: RidersWhereInput[]
    NOT?: RidersWhereInput | RidersWhereInput[]
    id?: IntFilter<"Riders"> | number
    name?: StringFilter<"Riders"> | string
    contact?: StringFilter<"Riders"> | string
    id_number?: StringFilter<"Riders"> | string
    company_id?: IntFilter<"Riders"> | number
    company?: StringFilter<"Riders"> | string
    status?: IntNullableFilter<"Riders"> | number | null
    password?: StringNullableFilter<"Riders"> | string | null
    device_id?: StringNullableFilter<"Riders"> | string | null
    device_name?: StringNullableFilter<"Riders"> | string | null
    device_status?: StringNullableFilter<"Riders"> | string | null
    token?: StringNullableFilter<"Riders"> | string | null
  }

  export type RidersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    id_number?: SortOrder
    company_id?: SortOrder
    company?: SortOrder
    status?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    device_name?: SortOrderInput | SortOrder
    device_status?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
  }

  export type RidersWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RidersWhereInput | RidersWhereInput[]
    OR?: RidersWhereInput[]
    NOT?: RidersWhereInput | RidersWhereInput[]
    name?: StringFilter<"Riders"> | string
    contact?: StringFilter<"Riders"> | string
    id_number?: StringFilter<"Riders"> | string
    company_id?: IntFilter<"Riders"> | number
    company?: StringFilter<"Riders"> | string
    status?: IntNullableFilter<"Riders"> | number | null
    password?: StringNullableFilter<"Riders"> | string | null
    device_id?: StringNullableFilter<"Riders"> | string | null
    device_name?: StringNullableFilter<"Riders"> | string | null
    device_status?: StringNullableFilter<"Riders"> | string | null
    token?: StringNullableFilter<"Riders"> | string | null
  }, "id">

  export type RidersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    id_number?: SortOrder
    company_id?: SortOrder
    company?: SortOrder
    status?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    device_id?: SortOrderInput | SortOrder
    device_name?: SortOrderInput | SortOrder
    device_status?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    _count?: RidersCountOrderByAggregateInput
    _avg?: RidersAvgOrderByAggregateInput
    _max?: RidersMaxOrderByAggregateInput
    _min?: RidersMinOrderByAggregateInput
    _sum?: RidersSumOrderByAggregateInput
  }

  export type RidersScalarWhereWithAggregatesInput = {
    AND?: RidersScalarWhereWithAggregatesInput | RidersScalarWhereWithAggregatesInput[]
    OR?: RidersScalarWhereWithAggregatesInput[]
    NOT?: RidersScalarWhereWithAggregatesInput | RidersScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Riders"> | number
    name?: StringWithAggregatesFilter<"Riders"> | string
    contact?: StringWithAggregatesFilter<"Riders"> | string
    id_number?: StringWithAggregatesFilter<"Riders"> | string
    company_id?: IntWithAggregatesFilter<"Riders"> | number
    company?: StringWithAggregatesFilter<"Riders"> | string
    status?: IntNullableWithAggregatesFilter<"Riders"> | number | null
    password?: StringNullableWithAggregatesFilter<"Riders"> | string | null
    device_id?: StringNullableWithAggregatesFilter<"Riders"> | string | null
    device_name?: StringNullableWithAggregatesFilter<"Riders"> | string | null
    device_status?: StringNullableWithAggregatesFilter<"Riders"> | string | null
    token?: StringNullableWithAggregatesFilter<"Riders"> | string | null
  }

  export type RidersCompanyWhereInput = {
    AND?: RidersCompanyWhereInput | RidersCompanyWhereInput[]
    OR?: RidersCompanyWhereInput[]
    NOT?: RidersCompanyWhereInput | RidersCompanyWhereInput[]
    id?: IntFilter<"RidersCompany"> | number
    name?: StringFilter<"RidersCompany"> | string
    status?: IntNullableFilter<"RidersCompany"> | number | null
  }

  export type RidersCompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
  }

  export type RidersCompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RidersCompanyWhereInput | RidersCompanyWhereInput[]
    OR?: RidersCompanyWhereInput[]
    NOT?: RidersCompanyWhereInput | RidersCompanyWhereInput[]
    name?: StringFilter<"RidersCompany"> | string
    status?: IntNullableFilter<"RidersCompany"> | number | null
  }, "id">

  export type RidersCompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrderInput | SortOrder
    _count?: RidersCompanyCountOrderByAggregateInput
    _avg?: RidersCompanyAvgOrderByAggregateInput
    _max?: RidersCompanyMaxOrderByAggregateInput
    _min?: RidersCompanyMinOrderByAggregateInput
    _sum?: RidersCompanySumOrderByAggregateInput
  }

  export type RidersCompanyScalarWhereWithAggregatesInput = {
    AND?: RidersCompanyScalarWhereWithAggregatesInput | RidersCompanyScalarWhereWithAggregatesInput[]
    OR?: RidersCompanyScalarWhereWithAggregatesInput[]
    NOT?: RidersCompanyScalarWhereWithAggregatesInput | RidersCompanyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RidersCompany"> | number
    name?: StringWithAggregatesFilter<"RidersCompany"> | string
    status?: IntNullableWithAggregatesFilter<"RidersCompany"> | number | null
  }

  export type ManagerCheckinWhereInput = {
    AND?: ManagerCheckinWhereInput | ManagerCheckinWhereInput[]
    OR?: ManagerCheckinWhereInput[]
    NOT?: ManagerCheckinWhereInput | ManagerCheckinWhereInput[]
    id?: IntFilter<"ManagerCheckin"> | number
    managerId?: IntFilter<"ManagerCheckin"> | number
    clientId?: IntFilter<"ManagerCheckin"> | number
    date?: DateTimeFilter<"ManagerCheckin"> | Date | string
    checkInAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    latitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    longitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    notes?: StringNullableFilter<"ManagerCheckin"> | string | null
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
  }

  export type ManagerCheckinOrderByWithRelationInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrderInput | SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    manager?: ManagerOrderByWithRelationInput
    client?: ClientsOrderByWithRelationInput
  }

  export type ManagerCheckinWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ManagerCheckinWhereInput | ManagerCheckinWhereInput[]
    OR?: ManagerCheckinWhereInput[]
    NOT?: ManagerCheckinWhereInput | ManagerCheckinWhereInput[]
    managerId?: IntFilter<"ManagerCheckin"> | number
    clientId?: IntFilter<"ManagerCheckin"> | number
    date?: DateTimeFilter<"ManagerCheckin"> | Date | string
    checkInAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    latitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    longitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    notes?: StringNullableFilter<"ManagerCheckin"> | string | null
    manager?: XOR<ManagerRelationFilter, ManagerWhereInput>
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
  }, "id">

  export type ManagerCheckinOrderByWithAggregationInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrderInput | SortOrder
    checkOutAt?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: ManagerCheckinCountOrderByAggregateInput
    _avg?: ManagerCheckinAvgOrderByAggregateInput
    _max?: ManagerCheckinMaxOrderByAggregateInput
    _min?: ManagerCheckinMinOrderByAggregateInput
    _sum?: ManagerCheckinSumOrderByAggregateInput
  }

  export type ManagerCheckinScalarWhereWithAggregatesInput = {
    AND?: ManagerCheckinScalarWhereWithAggregatesInput | ManagerCheckinScalarWhereWithAggregatesInput[]
    OR?: ManagerCheckinScalarWhereWithAggregatesInput[]
    NOT?: ManagerCheckinScalarWhereWithAggregatesInput | ManagerCheckinScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ManagerCheckin"> | number
    managerId?: IntWithAggregatesFilter<"ManagerCheckin"> | number
    clientId?: IntWithAggregatesFilter<"ManagerCheckin"> | number
    date?: DateTimeWithAggregatesFilter<"ManagerCheckin"> | Date | string
    checkInAt?: DateTimeNullableWithAggregatesFilter<"ManagerCheckin"> | Date | string | null
    checkOutAt?: DateTimeNullableWithAggregatesFilter<"ManagerCheckin"> | Date | string | null
    latitude?: FloatNullableWithAggregatesFilter<"ManagerCheckin"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"ManagerCheckin"> | number | null
    notes?: StringNullableWithAggregatesFilter<"ManagerCheckin"> | string | null
  }

  export type MyOrderWhereInput = {
    AND?: MyOrderWhereInput | MyOrderWhereInput[]
    OR?: MyOrderWhereInput[]
    NOT?: MyOrderWhereInput | MyOrderWhereInput[]
    id?: IntFilter<"MyOrder"> | number
    totalAmount?: FloatFilter<"MyOrder"> | number
    comment?: StringFilter<"MyOrder"> | string
    customerType?: StringFilter<"MyOrder"> | string
    customerId?: StringFilter<"MyOrder"> | string
    customerName?: StringFilter<"MyOrder"> | string
    orderDate?: DateTimeFilter<"MyOrder"> | Date | string
    riderId?: IntNullableFilter<"MyOrder"> | number | null
    riderName?: StringNullableFilter<"MyOrder"> | string | null
    status?: IntFilter<"MyOrder"> | number
    approvedTime?: StringNullableFilter<"MyOrder"> | string | null
    dispatchTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryLocation?: StringNullableFilter<"MyOrder"> | string | null
    complete_latitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_longitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_address?: StringNullableFilter<"MyOrder"> | string | null
    pickupTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryTime?: StringNullableFilter<"MyOrder"> | string | null
    cancel_reason?: StringNullableFilter<"MyOrder"> | string | null
    recepient?: StringNullableFilter<"MyOrder"> | string | null
    userId?: IntFilter<"MyOrder"> | number
    clientId?: IntFilter<"MyOrder"> | number
    createdAt?: DateTimeFilter<"MyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MyOrder"> | Date | string
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    orderItems?: OrderItemListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type MyOrderOrderByWithRelationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    comment?: SortOrder
    customerType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderDate?: SortOrder
    riderId?: SortOrderInput | SortOrder
    riderName?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedTime?: SortOrderInput | SortOrder
    dispatchTime?: SortOrderInput | SortOrder
    deliveryLocation?: SortOrderInput | SortOrder
    complete_latitude?: SortOrderInput | SortOrder
    complete_longitude?: SortOrderInput | SortOrder
    complete_address?: SortOrderInput | SortOrder
    pickupTime?: SortOrderInput | SortOrder
    deliveryTime?: SortOrderInput | SortOrder
    cancel_reason?: SortOrderInput | SortOrder
    recepient?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    client?: ClientsOrderByWithRelationInput
    user?: SalesRepOrderByWithRelationInput
    orderItems?: OrderItemOrderByRelationAggregateInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type MyOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MyOrderWhereInput | MyOrderWhereInput[]
    OR?: MyOrderWhereInput[]
    NOT?: MyOrderWhereInput | MyOrderWhereInput[]
    totalAmount?: FloatFilter<"MyOrder"> | number
    comment?: StringFilter<"MyOrder"> | string
    customerType?: StringFilter<"MyOrder"> | string
    customerId?: StringFilter<"MyOrder"> | string
    customerName?: StringFilter<"MyOrder"> | string
    orderDate?: DateTimeFilter<"MyOrder"> | Date | string
    riderId?: IntNullableFilter<"MyOrder"> | number | null
    riderName?: StringNullableFilter<"MyOrder"> | string | null
    status?: IntFilter<"MyOrder"> | number
    approvedTime?: StringNullableFilter<"MyOrder"> | string | null
    dispatchTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryLocation?: StringNullableFilter<"MyOrder"> | string | null
    complete_latitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_longitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_address?: StringNullableFilter<"MyOrder"> | string | null
    pickupTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryTime?: StringNullableFilter<"MyOrder"> | string | null
    cancel_reason?: StringNullableFilter<"MyOrder"> | string | null
    recepient?: StringNullableFilter<"MyOrder"> | string | null
    userId?: IntFilter<"MyOrder"> | number
    clientId?: IntFilter<"MyOrder"> | number
    createdAt?: DateTimeFilter<"MyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MyOrder"> | Date | string
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    orderItems?: OrderItemListRelationFilter
    reports?: ReportListRelationFilter
  }, "id">

  export type MyOrderOrderByWithAggregationInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    comment?: SortOrder
    customerType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderDate?: SortOrder
    riderId?: SortOrderInput | SortOrder
    riderName?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedTime?: SortOrderInput | SortOrder
    dispatchTime?: SortOrderInput | SortOrder
    deliveryLocation?: SortOrderInput | SortOrder
    complete_latitude?: SortOrderInput | SortOrder
    complete_longitude?: SortOrderInput | SortOrder
    complete_address?: SortOrderInput | SortOrder
    pickupTime?: SortOrderInput | SortOrder
    deliveryTime?: SortOrderInput | SortOrder
    cancel_reason?: SortOrderInput | SortOrder
    recepient?: SortOrderInput | SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MyOrderCountOrderByAggregateInput
    _avg?: MyOrderAvgOrderByAggregateInput
    _max?: MyOrderMaxOrderByAggregateInput
    _min?: MyOrderMinOrderByAggregateInput
    _sum?: MyOrderSumOrderByAggregateInput
  }

  export type MyOrderScalarWhereWithAggregatesInput = {
    AND?: MyOrderScalarWhereWithAggregatesInput | MyOrderScalarWhereWithAggregatesInput[]
    OR?: MyOrderScalarWhereWithAggregatesInput[]
    NOT?: MyOrderScalarWhereWithAggregatesInput | MyOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MyOrder"> | number
    totalAmount?: FloatWithAggregatesFilter<"MyOrder"> | number
    comment?: StringWithAggregatesFilter<"MyOrder"> | string
    customerType?: StringWithAggregatesFilter<"MyOrder"> | string
    customerId?: StringWithAggregatesFilter<"MyOrder"> | string
    customerName?: StringWithAggregatesFilter<"MyOrder"> | string
    orderDate?: DateTimeWithAggregatesFilter<"MyOrder"> | Date | string
    riderId?: IntNullableWithAggregatesFilter<"MyOrder"> | number | null
    riderName?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    status?: IntWithAggregatesFilter<"MyOrder"> | number
    approvedTime?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    dispatchTime?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    deliveryLocation?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    complete_latitude?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    complete_longitude?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    complete_address?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    pickupTime?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    deliveryTime?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    cancel_reason?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    recepient?: StringNullableWithAggregatesFilter<"MyOrder"> | string | null
    userId?: IntWithAggregatesFilter<"MyOrder"> | number
    clientId?: IntWithAggregatesFilter<"MyOrder"> | number
    createdAt?: DateTimeWithAggregatesFilter<"MyOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MyOrder"> | Date | string
  }

  export type OrderItemWhereInput = {
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    priceOptionId?: IntNullableFilter<"OrderItem"> | number | null
    priceOption?: XOR<PriceOptionNullableRelationFilter, PriceOptionWhereInput> | null
    order?: XOR<MyOrderRelationFilter, MyOrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }

  export type OrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrderInput | SortOrder
    priceOption?: PriceOptionOrderByWithRelationInput
    order?: MyOrderOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type OrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId_productId_priceOptionId?: OrderItemOrderIdProductIdPriceOptionIdCompoundUniqueInput
    AND?: OrderItemWhereInput | OrderItemWhereInput[]
    OR?: OrderItemWhereInput[]
    NOT?: OrderItemWhereInput | OrderItemWhereInput[]
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    priceOptionId?: IntNullableFilter<"OrderItem"> | number | null
    priceOption?: XOR<PriceOptionNullableRelationFilter, PriceOptionWhereInput> | null
    order?: XOR<MyOrderRelationFilter, MyOrderWhereInput>
    product?: XOR<ProductRelationFilter, ProductWhereInput>
  }, "id" | "orderId_productId_priceOptionId">

  export type OrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrderInput | SortOrder
    _count?: OrderItemCountOrderByAggregateInput
    _avg?: OrderItemAvgOrderByAggregateInput
    _max?: OrderItemMaxOrderByAggregateInput
    _min?: OrderItemMinOrderByAggregateInput
    _sum?: OrderItemSumOrderByAggregateInput
  }

  export type OrderItemScalarWhereWithAggregatesInput = {
    AND?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    OR?: OrderItemScalarWhereWithAggregatesInput[]
    NOT?: OrderItemScalarWhereWithAggregatesInput | OrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"OrderItem"> | number
    orderId?: IntWithAggregatesFilter<"OrderItem"> | number
    productId?: IntWithAggregatesFilter<"OrderItem"> | number
    quantity?: IntWithAggregatesFilter<"OrderItem"> | number
    priceOptionId?: IntNullableWithAggregatesFilter<"OrderItem"> | number | null
  }

  export type JourneyPlanWhereInput = {
    AND?: JourneyPlanWhereInput | JourneyPlanWhereInput[]
    OR?: JourneyPlanWhereInput[]
    NOT?: JourneyPlanWhereInput | JourneyPlanWhereInput[]
    id?: IntFilter<"JourneyPlan"> | number
    date?: DateTimeFilter<"JourneyPlan"> | Date | string
    time?: StringFilter<"JourneyPlan"> | string
    userId?: IntNullableFilter<"JourneyPlan"> | number | null
    clientId?: IntFilter<"JourneyPlan"> | number
    status?: IntFilter<"JourneyPlan"> | number
    checkInTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
    latitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    longitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    imageUrl?: StringNullableFilter<"JourneyPlan"> | string | null
    notes?: StringNullableFilter<"JourneyPlan"> | string | null
    checkoutLatitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutLongitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepNullableRelationFilter, SalesRepWhereInput> | null
    reports?: ReportListRelationFilter
  }

  export type JourneyPlanOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    checkoutLatitude?: SortOrderInput | SortOrder
    checkoutLongitude?: SortOrderInput | SortOrder
    checkoutTime?: SortOrderInput | SortOrder
    client?: ClientsOrderByWithRelationInput
    user?: SalesRepOrderByWithRelationInput
    reports?: ReportOrderByRelationAggregateInput
  }

  export type JourneyPlanWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: JourneyPlanWhereInput | JourneyPlanWhereInput[]
    OR?: JourneyPlanWhereInput[]
    NOT?: JourneyPlanWhereInput | JourneyPlanWhereInput[]
    date?: DateTimeFilter<"JourneyPlan"> | Date | string
    time?: StringFilter<"JourneyPlan"> | string
    userId?: IntNullableFilter<"JourneyPlan"> | number | null
    clientId?: IntFilter<"JourneyPlan"> | number
    status?: IntFilter<"JourneyPlan"> | number
    checkInTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
    latitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    longitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    imageUrl?: StringNullableFilter<"JourneyPlan"> | string | null
    notes?: StringNullableFilter<"JourneyPlan"> | string | null
    checkoutLatitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutLongitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepNullableRelationFilter, SalesRepWhereInput> | null
    reports?: ReportListRelationFilter
  }, "id">

  export type JourneyPlanOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    userId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    checkoutLatitude?: SortOrderInput | SortOrder
    checkoutLongitude?: SortOrderInput | SortOrder
    checkoutTime?: SortOrderInput | SortOrder
    _count?: JourneyPlanCountOrderByAggregateInput
    _avg?: JourneyPlanAvgOrderByAggregateInput
    _max?: JourneyPlanMaxOrderByAggregateInput
    _min?: JourneyPlanMinOrderByAggregateInput
    _sum?: JourneyPlanSumOrderByAggregateInput
  }

  export type JourneyPlanScalarWhereWithAggregatesInput = {
    AND?: JourneyPlanScalarWhereWithAggregatesInput | JourneyPlanScalarWhereWithAggregatesInput[]
    OR?: JourneyPlanScalarWhereWithAggregatesInput[]
    NOT?: JourneyPlanScalarWhereWithAggregatesInput | JourneyPlanScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"JourneyPlan"> | number
    date?: DateTimeWithAggregatesFilter<"JourneyPlan"> | Date | string
    time?: StringWithAggregatesFilter<"JourneyPlan"> | string
    userId?: IntNullableWithAggregatesFilter<"JourneyPlan"> | number | null
    clientId?: IntWithAggregatesFilter<"JourneyPlan"> | number
    status?: IntWithAggregatesFilter<"JourneyPlan"> | number
    checkInTime?: DateTimeNullableWithAggregatesFilter<"JourneyPlan"> | Date | string | null
    latitude?: FloatNullableWithAggregatesFilter<"JourneyPlan"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"JourneyPlan"> | number | null
    imageUrl?: StringNullableWithAggregatesFilter<"JourneyPlan"> | string | null
    notes?: StringNullableWithAggregatesFilter<"JourneyPlan"> | string | null
    checkoutLatitude?: FloatNullableWithAggregatesFilter<"JourneyPlan"> | number | null
    checkoutLongitude?: FloatNullableWithAggregatesFilter<"JourneyPlan"> | number | null
    checkoutTime?: DateTimeNullableWithAggregatesFilter<"JourneyPlan"> | Date | string | null
  }

  export type NoticeBoardWhereInput = {
    AND?: NoticeBoardWhereInput | NoticeBoardWhereInput[]
    OR?: NoticeBoardWhereInput[]
    NOT?: NoticeBoardWhereInput | NoticeBoardWhereInput[]
    id?: IntFilter<"NoticeBoard"> | number
    title?: StringFilter<"NoticeBoard"> | string
    content?: StringFilter<"NoticeBoard"> | string
    createdAt?: DateTimeFilter<"NoticeBoard"> | Date | string
    updatedAt?: DateTimeFilter<"NoticeBoard"> | Date | string
  }

  export type NoticeBoardOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeBoardWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NoticeBoardWhereInput | NoticeBoardWhereInput[]
    OR?: NoticeBoardWhereInput[]
    NOT?: NoticeBoardWhereInput | NoticeBoardWhereInput[]
    title?: StringFilter<"NoticeBoard"> | string
    content?: StringFilter<"NoticeBoard"> | string
    createdAt?: DateTimeFilter<"NoticeBoard"> | Date | string
    updatedAt?: DateTimeFilter<"NoticeBoard"> | Date | string
  }, "id">

  export type NoticeBoardOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NoticeBoardCountOrderByAggregateInput
    _avg?: NoticeBoardAvgOrderByAggregateInput
    _max?: NoticeBoardMaxOrderByAggregateInput
    _min?: NoticeBoardMinOrderByAggregateInput
    _sum?: NoticeBoardSumOrderByAggregateInput
  }

  export type NoticeBoardScalarWhereWithAggregatesInput = {
    AND?: NoticeBoardScalarWhereWithAggregatesInput | NoticeBoardScalarWhereWithAggregatesInput[]
    OR?: NoticeBoardScalarWhereWithAggregatesInput[]
    NOT?: NoticeBoardScalarWhereWithAggregatesInput | NoticeBoardScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"NoticeBoard"> | number
    title?: StringWithAggregatesFilter<"NoticeBoard"> | string
    content?: StringWithAggregatesFilter<"NoticeBoard"> | string
    createdAt?: DateTimeWithAggregatesFilter<"NoticeBoard"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NoticeBoard"> | Date | string
  }

  export type ReportWhereInput = {
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    id?: IntFilter<"Report"> | number
    orderId?: IntNullableFilter<"Report"> | number | null
    clientId?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    userId?: IntFilter<"Report"> | number
    journeyPlanId?: IntNullableFilter<"Report"> | number | null
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    feedbackReport?: XOR<FeedbackReportNullableRelationFilter, FeedbackReportWhereInput> | null
    productReport?: XOR<ProductReportNullableRelationFilter, ProductReportWhereInput> | null
    journeyPlan?: XOR<JourneyPlanNullableRelationFilter, JourneyPlanWhereInput> | null
    MyOrder?: MyOrderListRelationFilter
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    visibilityReport?: XOR<VisibilityReportNullableRelationFilter, VisibilityReportWhereInput> | null
  }

  export type ReportOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrderInput | SortOrder
    type?: SortOrder
    feedbackReport?: FeedbackReportOrderByWithRelationInput
    productReport?: ProductReportOrderByWithRelationInput
    journeyPlan?: JourneyPlanOrderByWithRelationInput
    MyOrder?: MyOrderOrderByRelationAggregateInput
    client?: ClientsOrderByWithRelationInput
    user?: SalesRepOrderByWithRelationInput
    visibilityReport?: VisibilityReportOrderByWithRelationInput
  }

  export type ReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportWhereInput | ReportWhereInput[]
    OR?: ReportWhereInput[]
    NOT?: ReportWhereInput | ReportWhereInput[]
    orderId?: IntNullableFilter<"Report"> | number | null
    clientId?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    userId?: IntFilter<"Report"> | number
    journeyPlanId?: IntNullableFilter<"Report"> | number | null
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
    feedbackReport?: XOR<FeedbackReportNullableRelationFilter, FeedbackReportWhereInput> | null
    productReport?: XOR<ProductReportNullableRelationFilter, ProductReportWhereInput> | null
    journeyPlan?: XOR<JourneyPlanNullableRelationFilter, JourneyPlanWhereInput> | null
    MyOrder?: MyOrderListRelationFilter
    client?: XOR<ClientsRelationFilter, ClientsWhereInput>
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
    visibilityReport?: XOR<VisibilityReportNullableRelationFilter, VisibilityReportWhereInput> | null
  }, "id">

  export type ReportOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrderInput | SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrderInput | SortOrder
    type?: SortOrder
    _count?: ReportCountOrderByAggregateInput
    _avg?: ReportAvgOrderByAggregateInput
    _max?: ReportMaxOrderByAggregateInput
    _min?: ReportMinOrderByAggregateInput
    _sum?: ReportSumOrderByAggregateInput
  }

  export type ReportScalarWhereWithAggregatesInput = {
    AND?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    OR?: ReportScalarWhereWithAggregatesInput[]
    NOT?: ReportScalarWhereWithAggregatesInput | ReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Report"> | number
    orderId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    clientId?: IntWithAggregatesFilter<"Report"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Report"> | Date | string
    userId?: IntWithAggregatesFilter<"Report"> | number
    journeyPlanId?: IntNullableWithAggregatesFilter<"Report"> | number | null
    type?: EnumReportTypeWithAggregatesFilter<"Report"> | $Enums.ReportType
  }

  export type FeedbackReportWhereInput = {
    AND?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    OR?: FeedbackReportWhereInput[]
    NOT?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    reportId?: IntFilter<"FeedbackReport"> | number
    comment?: StringNullableFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }

  export type FeedbackReportOrderByWithRelationInput = {
    reportId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type FeedbackReportWhereUniqueInput = Prisma.AtLeast<{
    reportId?: number
    AND?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    OR?: FeedbackReportWhereInput[]
    NOT?: FeedbackReportWhereInput | FeedbackReportWhereInput[]
    comment?: StringNullableFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeFilter<"FeedbackReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }, "reportId">

  export type FeedbackReportOrderByWithAggregationInput = {
    reportId?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: FeedbackReportCountOrderByAggregateInput
    _avg?: FeedbackReportAvgOrderByAggregateInput
    _max?: FeedbackReportMaxOrderByAggregateInput
    _min?: FeedbackReportMinOrderByAggregateInput
    _sum?: FeedbackReportSumOrderByAggregateInput
  }

  export type FeedbackReportScalarWhereWithAggregatesInput = {
    AND?: FeedbackReportScalarWhereWithAggregatesInput | FeedbackReportScalarWhereWithAggregatesInput[]
    OR?: FeedbackReportScalarWhereWithAggregatesInput[]
    NOT?: FeedbackReportScalarWhereWithAggregatesInput | FeedbackReportScalarWhereWithAggregatesInput[]
    reportId?: IntWithAggregatesFilter<"FeedbackReport"> | number
    comment?: StringNullableWithAggregatesFilter<"FeedbackReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"FeedbackReport"> | Date | string
  }

  export type ProductReportWhereInput = {
    AND?: ProductReportWhereInput | ProductReportWhereInput[]
    OR?: ProductReportWhereInput[]
    NOT?: ProductReportWhereInput | ProductReportWhereInput[]
    reportId?: IntFilter<"ProductReport"> | number
    productName?: StringNullableFilter<"ProductReport"> | string | null
    quantity?: IntNullableFilter<"ProductReport"> | number | null
    comment?: StringNullableFilter<"ProductReport"> | string | null
    createdAt?: DateTimeFilter<"ProductReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }

  export type ProductReportOrderByWithRelationInput = {
    reportId?: SortOrder
    productName?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type ProductReportWhereUniqueInput = Prisma.AtLeast<{
    reportId?: number
    AND?: ProductReportWhereInput | ProductReportWhereInput[]
    OR?: ProductReportWhereInput[]
    NOT?: ProductReportWhereInput | ProductReportWhereInput[]
    productName?: StringNullableFilter<"ProductReport"> | string | null
    quantity?: IntNullableFilter<"ProductReport"> | number | null
    comment?: StringNullableFilter<"ProductReport"> | string | null
    createdAt?: DateTimeFilter<"ProductReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }, "reportId">

  export type ProductReportOrderByWithAggregationInput = {
    reportId?: SortOrder
    productName?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ProductReportCountOrderByAggregateInput
    _avg?: ProductReportAvgOrderByAggregateInput
    _max?: ProductReportMaxOrderByAggregateInput
    _min?: ProductReportMinOrderByAggregateInput
    _sum?: ProductReportSumOrderByAggregateInput
  }

  export type ProductReportScalarWhereWithAggregatesInput = {
    AND?: ProductReportScalarWhereWithAggregatesInput | ProductReportScalarWhereWithAggregatesInput[]
    OR?: ProductReportScalarWhereWithAggregatesInput[]
    NOT?: ProductReportScalarWhereWithAggregatesInput | ProductReportScalarWhereWithAggregatesInput[]
    reportId?: IntWithAggregatesFilter<"ProductReport"> | number
    productName?: StringNullableWithAggregatesFilter<"ProductReport"> | string | null
    quantity?: IntNullableWithAggregatesFilter<"ProductReport"> | number | null
    comment?: StringNullableWithAggregatesFilter<"ProductReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ProductReport"> | Date | string
  }

  export type VisibilityReportWhereInput = {
    AND?: VisibilityReportWhereInput | VisibilityReportWhereInput[]
    OR?: VisibilityReportWhereInput[]
    NOT?: VisibilityReportWhereInput | VisibilityReportWhereInput[]
    reportId?: IntFilter<"VisibilityReport"> | number
    comment?: StringNullableFilter<"VisibilityReport"> | string | null
    imageUrl?: StringNullableFilter<"VisibilityReport"> | string | null
    createdAt?: DateTimeFilter<"VisibilityReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }

  export type VisibilityReportOrderByWithRelationInput = {
    reportId?: SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    report?: ReportOrderByWithRelationInput
  }

  export type VisibilityReportWhereUniqueInput = Prisma.AtLeast<{
    reportId?: number
    AND?: VisibilityReportWhereInput | VisibilityReportWhereInput[]
    OR?: VisibilityReportWhereInput[]
    NOT?: VisibilityReportWhereInput | VisibilityReportWhereInput[]
    comment?: StringNullableFilter<"VisibilityReport"> | string | null
    imageUrl?: StringNullableFilter<"VisibilityReport"> | string | null
    createdAt?: DateTimeFilter<"VisibilityReport"> | Date | string
    report?: XOR<ReportRelationFilter, ReportWhereInput>
  }, "reportId">

  export type VisibilityReportOrderByWithAggregationInput = {
    reportId?: SortOrder
    comment?: SortOrderInput | SortOrder
    imageUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: VisibilityReportCountOrderByAggregateInput
    _avg?: VisibilityReportAvgOrderByAggregateInput
    _max?: VisibilityReportMaxOrderByAggregateInput
    _min?: VisibilityReportMinOrderByAggregateInput
    _sum?: VisibilityReportSumOrderByAggregateInput
  }

  export type VisibilityReportScalarWhereWithAggregatesInput = {
    AND?: VisibilityReportScalarWhereWithAggregatesInput | VisibilityReportScalarWhereWithAggregatesInput[]
    OR?: VisibilityReportScalarWhereWithAggregatesInput[]
    NOT?: VisibilityReportScalarWhereWithAggregatesInput | VisibilityReportScalarWhereWithAggregatesInput[]
    reportId?: IntWithAggregatesFilter<"VisibilityReport"> | number
    comment?: StringNullableWithAggregatesFilter<"VisibilityReport"> | string | null
    imageUrl?: StringNullableWithAggregatesFilter<"VisibilityReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"VisibilityReport"> | Date | string
  }

  export type LeaveWhereInput = {
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    id?: IntFilter<"Leave"> | number
    userId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
  }

  export type LeaveOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    attachment?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: SalesRepOrderByWithRelationInput
  }

  export type LeaveWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LeaveWhereInput | LeaveWhereInput[]
    OR?: LeaveWhereInput[]
    NOT?: LeaveWhereInput | LeaveWhereInput[]
    userId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
    user?: XOR<SalesRepRelationFilter, SalesRepWhereInput>
  }, "id">

  export type LeaveOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    attachment?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveCountOrderByAggregateInput
    _avg?: LeaveAvgOrderByAggregateInput
    _max?: LeaveMaxOrderByAggregateInput
    _min?: LeaveMinOrderByAggregateInput
    _sum?: LeaveSumOrderByAggregateInput
  }

  export type LeaveScalarWhereWithAggregatesInput = {
    AND?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    OR?: LeaveScalarWhereWithAggregatesInput[]
    NOT?: LeaveScalarWhereWithAggregatesInput | LeaveScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Leave"> | number
    userId?: IntWithAggregatesFilter<"Leave"> | number
    leaveType?: StringWithAggregatesFilter<"Leave"> | string
    startDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    reason?: StringWithAggregatesFilter<"Leave"> | string
    attachment?: StringNullableWithAggregatesFilter<"Leave"> | string | null
    status?: StringWithAggregatesFilter<"Leave"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Leave"> | Date | string
  }

  export type SalesRepCreateInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalesRepCreateManyInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
  }

  export type SalesRepUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SalesRepUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCreateInput = {
    department?: string | null
    user: SalesRepCreateNestedOneWithoutManagerInput
    checkins?: ManagerCheckinCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateInput = {
    id?: number
    userId: number
    department?: string | null
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerUpdateInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    user?: SalesRepUpdateOneRequiredWithoutManagerNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type ManagerCreateManyInput = {
    id?: number
    userId: number
    department?: string | null
  }

  export type ManagerUpdateManyMutationInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TokenCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
    user: SalesRepCreateNestedOneWithoutTokensInput
  }

  export type TokenUncheckedCreateInput = {
    id?: number
    token: string
    salesRepId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: SalesRepUpdateOneRequiredWithoutTokensNestedInput
  }

  export type TokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    salesRepId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenCreateManyInput = {
    id?: number
    token: string
    salesRepId: number
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    salesRepId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegionsCreateInput = {
    name: string
    status?: number | null
    country: CountryCreateNestedOneWithoutRegionsInput
  }

  export type RegionsUncheckedCreateInput = {
    id?: number
    name: string
    countryId: number
    status?: number | null
  }

  export type RegionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutRegionsNestedInput
  }

  export type RegionsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RegionsCreateManyInput = {
    id?: number
    name: string
    countryId: number
    status?: number | null
  }

  export type RegionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RegionsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountryCreateInput = {
    name: string
    status?: number | null
    regions?: RegionsCreateNestedManyWithoutCountryInput
    clients?: ClientsCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateInput = {
    id?: number
    name: string
    status?: number | null
    regions?: RegionsUncheckedCreateNestedManyWithoutCountryInput
    clients?: ClientsUncheckedCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUpdateManyWithoutCountryNestedInput
    clients?: ClientsUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUncheckedUpdateManyWithoutCountryNestedInput
    clients?: ClientsUncheckedUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountryCreateManyInput = {
    id?: number
    name: string
    status?: number | null
  }

  export type CountryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CountryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    client?: ClientsCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutProductInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CategoryCreateInput = {
    name: string
    priceOptions?: PriceOptionCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUncheckedCreateInput = {
    id?: number
    name: string
    priceOptions?: PriceOptionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type CategoryUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    priceOptions?: PriceOptionUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    priceOptions?: PriceOptionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type CategoryCreateManyInput = {
    id?: number
    name: string
  }

  export type CategoryUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PriceOptionCreateInput = {
    option: string
    value: number
    category: CategoryCreateNestedOneWithoutPriceOptionsInput
    orderItems?: OrderItemCreateNestedManyWithoutPriceOptionInput
  }

  export type PriceOptionUncheckedCreateInput = {
    id?: number
    option: string
    value: number
    categoryId: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutPriceOptionInput
  }

  export type PriceOptionUpdateInput = {
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutPriceOptionsNestedInput
    orderItems?: OrderItemUpdateManyWithoutPriceOptionNestedInput
  }

  export type PriceOptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutPriceOptionNestedInput
  }

  export type PriceOptionCreateManyInput = {
    id?: number
    option: string
    value: number
    categoryId: number
  }

  export type PriceOptionUpdateManyMutationInput = {
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type PriceOptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityCreateInput = {
    quantity: number
    product: ProductCreateNestedOneWithoutStoreQuantitiesInput
    store: StoresCreateNestedOneWithoutStoreQuantitiesInput
  }

  export type StoreQuantityUncheckedCreateInput = {
    id?: number
    quantity: number
    storeId: number
    productId: number
  }

  export type StoreQuantityUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutStoreQuantitiesNestedInput
    store?: StoresUpdateOneRequiredWithoutStoreQuantitiesNestedInput
  }

  export type StoreQuantityUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityCreateManyInput = {
    id?: number
    quantity: number
    storeId: number
    productId: number
  }

  export type StoreQuantityUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type StoresCreateInput = {
    name: string
    storeQuantities?: StoreQuantityCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateInput = {
    id?: number
    name: string
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoresCreateManyInput = {
    id?: number
    name: string
  }

  export type StoresUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type StoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type PurchaseCreateInput = {
    quantity: number
    totalPrice: number
    date?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseInput
    store: StoresCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateInput = {
    id?: number
    productId: number
    storeId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseNestedInput
    store?: StoresUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseCreateManyInput = {
    id?: number
    productId: number
    storeId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateInput = {
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
    store: StoresCreateNestedOneWithoutPurchaseHistoryInput
    product: ProductCreateNestedOneWithoutPurchaseHistoryInput
  }

  export type PurchaseHistoryUncheckedCreateInput = {
    id?: number
    storeId: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryUpdateInput = {
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutPurchaseHistoryNestedInput
    product?: ProductUpdateOneRequiredWithoutPurchaseHistoryNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryCreateManyInput = {
    id?: number
    storeId: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryUpdateManyMutationInput = {
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientsCreateInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientsCreateManyInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
  }

  export type ClientsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
  }

  export type RidersCreateInput = {
    name: string
    contact: string
    id_number: string
    company_id: number
    company: string
    status?: number | null
    password?: string | null
    device_id?: string | null
    device_name?: string | null
    device_status?: string | null
    token?: string | null
  }

  export type RidersUncheckedCreateInput = {
    id?: number
    name: string
    contact: string
    id_number: string
    company_id: number
    company: string
    status?: number | null
    password?: string | null
    device_id?: string | null
    device_name?: string | null
    device_status?: string | null
    token?: string | null
  }

  export type RidersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    id_number?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: NullableStringFieldUpdateOperationsInput | string | null
    device_name?: NullableStringFieldUpdateOperationsInput | string | null
    device_status?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RidersUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    id_number?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: NullableStringFieldUpdateOperationsInput | string | null
    device_name?: NullableStringFieldUpdateOperationsInput | string | null
    device_status?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RidersCreateManyInput = {
    id?: number
    name: string
    contact: string
    id_number: string
    company_id: number
    company: string
    status?: number | null
    password?: string | null
    device_id?: string | null
    device_name?: string | null
    device_status?: string | null
    token?: string | null
  }

  export type RidersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    id_number?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: NullableStringFieldUpdateOperationsInput | string | null
    device_name?: NullableStringFieldUpdateOperationsInput | string | null
    device_status?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RidersUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    id_number?: StringFieldUpdateOperationsInput | string
    company_id?: IntFieldUpdateOperationsInput | number
    company?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    device_id?: NullableStringFieldUpdateOperationsInput | string | null
    device_name?: NullableStringFieldUpdateOperationsInput | string | null
    device_status?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RidersCompanyCreateInput = {
    name: string
    status?: number | null
  }

  export type RidersCompanyUncheckedCreateInput = {
    id?: number
    name: string
    status?: number | null
  }

  export type RidersCompanyUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RidersCompanyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RidersCompanyCreateManyInput = {
    id?: number
    name: string
    status?: number | null
  }

  export type RidersCompanyUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RidersCompanyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ManagerCheckinCreateInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
    manager: ManagerCreateNestedOneWithoutCheckinsInput
    client: ClientsCreateNestedOneWithoutCheckinsInput
  }

  export type ManagerCheckinUncheckedCreateInput = {
    id?: number
    managerId: number
    clientId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type ManagerCheckinUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneRequiredWithoutCheckinsNestedInput
    client?: ClientsUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type ManagerCheckinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    managerId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCheckinCreateManyInput = {
    id?: number
    managerId: number
    clientId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type ManagerCheckinUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCheckinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    managerId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MyOrderCreateInput = {
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientsCreateNestedOneWithoutMyOrderInput
    user: SalesRepCreateNestedOneWithoutMyOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    reports?: ReportCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderUncheckedCreateInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    reports?: ReportUncheckedCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderUpdateInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientsUpdateOneRequiredWithoutMyOrderNestedInput
    user?: SalesRepUpdateOneRequiredWithoutMyOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    reports?: ReportUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderCreateManyInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MyOrderUpdateManyMutationInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OrderItemCreateInput = {
    quantity: number
    priceOption?: PriceOptionCreateNestedOneWithoutOrderItemsInput
    order: MyOrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type OrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    priceOption?: PriceOptionUpdateOneWithoutOrderItemsNestedInput
    order?: MyOrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemCreateManyInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type OrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type JourneyPlanCreateInput = {
    date: Date | string
    time: string
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    client: ClientsCreateNestedOneWithoutJourneyPlansInput
    user?: SalesRepCreateNestedOneWithoutJourneyPlansInput
    reports?: ReportCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanUncheckedCreateInput = {
    id?: number
    date: Date | string
    time: string
    userId?: number | null
    clientId: number
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanUpdateInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientsUpdateOneRequiredWithoutJourneyPlansNestedInput
    user?: SalesRepUpdateOneWithoutJourneyPlansNestedInput
    reports?: ReportUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanCreateManyInput = {
    id?: number
    date: Date | string
    time: string
    userId?: number | null
    clientId: number
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
  }

  export type JourneyPlanUpdateManyMutationInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type JourneyPlanUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type NoticeBoardCreateInput = {
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeBoardUncheckedCreateInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeBoardUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeBoardUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeBoardCreateManyInput = {
    id?: number
    title: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NoticeBoardUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NoticeBoardUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportUpdateInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportCreateManyInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
  }

  export type ReportUpdateManyMutationInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type ReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type FeedbackReportCreateInput = {
    comment?: string | null
    createdAt?: Date | string
    report: ReportCreateNestedOneWithoutFeedbackReportInput
  }

  export type FeedbackReportUncheckedCreateInput = {
    reportId: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackReportUpdateInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutFeedbackReportNestedInput
  }

  export type FeedbackReportUncheckedUpdateInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportCreateManyInput = {
    reportId: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackReportUpdateManyMutationInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUncheckedUpdateManyInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReportCreateInput = {
    productName?: string | null
    quantity?: number | null
    comment?: string | null
    createdAt?: Date | string
    report: ReportCreateNestedOneWithoutProductReportInput
  }

  export type ProductReportUncheckedCreateInput = {
    reportId: number
    productName?: string | null
    quantity?: number | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProductReportUpdateInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutProductReportNestedInput
  }

  export type ProductReportUncheckedUpdateInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReportCreateManyInput = {
    reportId: number
    productName?: string | null
    quantity?: number | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProductReportUpdateManyMutationInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReportUncheckedUpdateManyInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisibilityReportCreateInput = {
    comment?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
    report: ReportCreateNestedOneWithoutVisibilityReportInput
  }

  export type VisibilityReportUncheckedCreateInput = {
    reportId: number
    comment?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type VisibilityReportUpdateInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: ReportUpdateOneRequiredWithoutVisibilityReportNestedInput
  }

  export type VisibilityReportUncheckedUpdateInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisibilityReportCreateManyInput = {
    reportId: number
    comment?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type VisibilityReportUpdateManyMutationInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisibilityReportUncheckedUpdateManyInput = {
    reportId?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: SalesRepCreateNestedOneWithoutLeavesInput
  }

  export type LeaveUncheckedCreateInput = {
    id?: number
    userId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: SalesRepUpdateOneRequiredWithoutLeavesNestedInput
  }

  export type LeaveUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveCreateManyInput = {
    id?: number
    userId: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUpdateManyMutationInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type CountryRelationFilter = {
    is?: CountryWhereInput
    isNot?: CountryWhereInput
  }

  export type JourneyPlanListRelationFilter = {
    every?: JourneyPlanWhereInput
    some?: JourneyPlanWhereInput
    none?: JourneyPlanWhereInput
  }

  export type ReportListRelationFilter = {
    every?: ReportWhereInput
    some?: ReportWhereInput
    none?: ReportWhereInput
  }

  export type TokenListRelationFilter = {
    every?: TokenWhereInput
    some?: TokenWhereInput
    none?: TokenWhereInput
  }

  export type LeaveListRelationFilter = {
    every?: LeaveWhereInput
    some?: LeaveWhereInput
    none?: LeaveWhereInput
  }

  export type ManagerNullableRelationFilter = {
    is?: ManagerWhereInput | null
    isNot?: ManagerWhereInput | null
  }

  export type MyOrderListRelationFilter = {
    every?: MyOrderWhereInput
    some?: MyOrderWhereInput
    none?: MyOrderWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type JourneyPlanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MyOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesRepCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photoUrl?: SortOrder
  }

  export type SalesRepAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    status?: SortOrder
  }

  export type SalesRepMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photoUrl?: SortOrder
  }

  export type SalesRepMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    password?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    role?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    photoUrl?: SortOrder
  }

  export type SalesRepSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    region_id?: SortOrder
    status?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type SalesRepRelationFilter = {
    is?: SalesRepWhereInput
    isNot?: SalesRepWhereInput
  }

  export type ManagerCheckinListRelationFilter = {
    every?: ManagerCheckinWhereInput
    some?: ManagerCheckinWhereInput
    none?: ManagerCheckinWhereInput
  }

  export type ManagerCheckinOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManagerCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
  }

  export type ManagerAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type ManagerMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
  }

  export type ManagerMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    department?: SortOrder
  }

  export type ManagerSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type TokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    salesRepId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TokenAvgOrderByAggregateInput = {
    id?: SortOrder
    salesRepId?: SortOrder
  }

  export type TokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    salesRepId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    salesRepId?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type TokenSumOrderByAggregateInput = {
    id?: SortOrder
    salesRepId?: SortOrder
  }

  export type RegionsNameCountryIdCompoundUniqueInput = {
    name: string
    countryId: number
  }

  export type RegionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    status?: SortOrder
  }

  export type RegionsAvgOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    status?: SortOrder
  }

  export type RegionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    status?: SortOrder
  }

  export type RegionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    countryId?: SortOrder
    status?: SortOrder
  }

  export type RegionsSumOrderByAggregateInput = {
    id?: SortOrder
    countryId?: SortOrder
    status?: SortOrder
  }

  export type RegionsListRelationFilter = {
    every?: RegionsWhereInput
    some?: RegionsWhereInput
    none?: RegionsWhereInput
  }

  export type ClientsListRelationFilter = {
    every?: ClientsWhereInput
    some?: ClientsWhereInput
    none?: ClientsWhereInput
  }

  export type SalesRepListRelationFilter = {
    every?: SalesRepWhereInput
    some?: SalesRepWhereInput
    none?: SalesRepWhereInput
  }

  export type RegionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalesRepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type CountryAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type CountryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type CountryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type CountrySumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type ClientsNullableRelationFilter = {
    is?: ClientsWhereInput | null
    isNot?: ClientsWhereInput | null
  }

  export type OrderItemListRelationFilter = {
    every?: OrderItemWhereInput
    some?: OrderItemWhereInput
    none?: OrderItemWhereInput
  }

  export type StoreQuantityListRelationFilter = {
    every?: StoreQuantityWhereInput
    some?: StoreQuantityWhereInput
    none?: StoreQuantityWhereInput
  }

  export type PurchaseListRelationFilter = {
    every?: PurchaseWhereInput
    some?: PurchaseWhereInput
    none?: PurchaseWhereInput
  }

  export type PurchaseHistoryListRelationFilter = {
    every?: PurchaseHistoryWhereInput
    some?: PurchaseHistoryWhereInput
    none?: PurchaseHistoryWhereInput
  }

  export type OrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StoreQuantityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    currentStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    image?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    currentStock?: SortOrder
    clientId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    currentStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    image?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    category?: SortOrder
    description?: SortOrder
    currentStock?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientId?: SortOrder
    image?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    category_id?: SortOrder
    currentStock?: SortOrder
    clientId?: SortOrder
  }

  export type PriceOptionListRelationFilter = {
    every?: PriceOptionWhereInput
    some?: PriceOptionWhereInput
    none?: PriceOptionWhereInput
  }

  export type PriceOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type CategorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CategoryRelationFilter = {
    is?: CategoryWhereInput
    isNot?: CategoryWhereInput
  }

  export type PriceOptionCountOrderByAggregateInput = {
    id?: SortOrder
    option?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
  }

  export type PriceOptionAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
  }

  export type PriceOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    option?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
  }

  export type PriceOptionMinOrderByAggregateInput = {
    id?: SortOrder
    option?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
  }

  export type PriceOptionSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    categoryId?: SortOrder
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type StoresRelationFilter = {
    is?: StoresWhereInput
    isNot?: StoresWhereInput
  }

  export type StoreQuantityCountOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
  }

  export type StoreQuantityAvgOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
  }

  export type StoreQuantityMaxOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
  }

  export type StoreQuantityMinOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
  }

  export type StoreQuantitySumOrderByAggregateInput = {
    id?: SortOrder
    quantity?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
  }

  export type StoresCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StoresAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StoresMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StoresMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type StoresSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PurchaseCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    date?: SortOrder
  }

  export type PurchaseAvgOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    date?: SortOrder
  }

  export type PurchaseMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
    date?: SortOrder
  }

  export type PurchaseSumOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    storeId?: SortOrder
    quantity?: SortOrder
    totalPrice?: SortOrder
  }

  export type PurchaseHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
  }

  export type PurchaseHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
    createdAt?: SortOrder
  }

  export type PurchaseHistorySumOrderByAggregateInput = {
    id?: SortOrder
    storeId?: SortOrder
    productId?: SortOrder
    previousQuantity?: SortOrder
    purchaseQuantity?: SortOrder
    newBalance?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    contact?: SortOrder
    tax_pin?: SortOrder
    location?: SortOrder
    status?: SortOrder
    client_type?: SortOrder
    countryId?: SortOrder
  }

  export type ClientsAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    region_id?: SortOrder
    status?: SortOrder
    client_type?: SortOrder
    countryId?: SortOrder
  }

  export type ClientsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    contact?: SortOrder
    tax_pin?: SortOrder
    location?: SortOrder
    status?: SortOrder
    client_type?: SortOrder
    countryId?: SortOrder
  }

  export type ClientsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    balance?: SortOrder
    email?: SortOrder
    region_id?: SortOrder
    region?: SortOrder
    contact?: SortOrder
    tax_pin?: SortOrder
    location?: SortOrder
    status?: SortOrder
    client_type?: SortOrder
    countryId?: SortOrder
  }

  export type ClientsSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    region_id?: SortOrder
    status?: SortOrder
    client_type?: SortOrder
    countryId?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type RidersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    id_number?: SortOrder
    company_id?: SortOrder
    company?: SortOrder
    status?: SortOrder
    password?: SortOrder
    device_id?: SortOrder
    device_name?: SortOrder
    device_status?: SortOrder
    token?: SortOrder
  }

  export type RidersAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
  }

  export type RidersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    id_number?: SortOrder
    company_id?: SortOrder
    company?: SortOrder
    status?: SortOrder
    password?: SortOrder
    device_id?: SortOrder
    device_name?: SortOrder
    device_status?: SortOrder
    token?: SortOrder
  }

  export type RidersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact?: SortOrder
    id_number?: SortOrder
    company_id?: SortOrder
    company?: SortOrder
    status?: SortOrder
    password?: SortOrder
    device_id?: SortOrder
    device_name?: SortOrder
    device_status?: SortOrder
    token?: SortOrder
  }

  export type RidersSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
  }

  export type RidersCompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type RidersCompanyAvgOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type RidersCompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type RidersCompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    status?: SortOrder
  }

  export type RidersCompanySumOrderByAggregateInput = {
    id?: SortOrder
    status?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ManagerRelationFilter = {
    is?: ManagerWhereInput
    isNot?: ManagerWhereInput
  }

  export type ClientsRelationFilter = {
    is?: ClientsWhereInput
    isNot?: ClientsWhereInput
  }

  export type ManagerCheckinCountOrderByAggregateInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
  }

  export type ManagerCheckinAvgOrderByAggregateInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type ManagerCheckinMaxOrderByAggregateInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
  }

  export type ManagerCheckinMinOrderByAggregateInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    date?: SortOrder
    checkInAt?: SortOrder
    checkOutAt?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    notes?: SortOrder
  }

  export type ManagerCheckinSumOrderByAggregateInput = {
    id?: SortOrder
    managerId?: SortOrder
    clientId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type MyOrderCountOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    comment?: SortOrder
    customerType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderDate?: SortOrder
    riderId?: SortOrder
    riderName?: SortOrder
    status?: SortOrder
    approvedTime?: SortOrder
    dispatchTime?: SortOrder
    deliveryLocation?: SortOrder
    complete_latitude?: SortOrder
    complete_longitude?: SortOrder
    complete_address?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    cancel_reason?: SortOrder
    recepient?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MyOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    riderId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
  }

  export type MyOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    comment?: SortOrder
    customerType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderDate?: SortOrder
    riderId?: SortOrder
    riderName?: SortOrder
    status?: SortOrder
    approvedTime?: SortOrder
    dispatchTime?: SortOrder
    deliveryLocation?: SortOrder
    complete_latitude?: SortOrder
    complete_longitude?: SortOrder
    complete_address?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    cancel_reason?: SortOrder
    recepient?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MyOrderMinOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    comment?: SortOrder
    customerType?: SortOrder
    customerId?: SortOrder
    customerName?: SortOrder
    orderDate?: SortOrder
    riderId?: SortOrder
    riderName?: SortOrder
    status?: SortOrder
    approvedTime?: SortOrder
    dispatchTime?: SortOrder
    deliveryLocation?: SortOrder
    complete_latitude?: SortOrder
    complete_longitude?: SortOrder
    complete_address?: SortOrder
    pickupTime?: SortOrder
    deliveryTime?: SortOrder
    cancel_reason?: SortOrder
    recepient?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MyOrderSumOrderByAggregateInput = {
    id?: SortOrder
    totalAmount?: SortOrder
    riderId?: SortOrder
    status?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type PriceOptionNullableRelationFilter = {
    is?: PriceOptionWhereInput | null
    isNot?: PriceOptionWhereInput | null
  }

  export type MyOrderRelationFilter = {
    is?: MyOrderWhereInput
    isNot?: MyOrderWhereInput
  }

  export type OrderItemOrderIdProductIdPriceOptionIdCompoundUniqueInput = {
    orderId: number
    productId: number
    priceOptionId: number
  }

  export type OrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrder
  }

  export type OrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrder
  }

  export type OrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrder
  }

  export type OrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrder
  }

  export type OrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    priceOptionId?: SortOrder
  }

  export type SalesRepNullableRelationFilter = {
    is?: SalesRepWhereInput | null
    isNot?: SalesRepWhereInput | null
  }

  export type JourneyPlanCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    checkoutLatitude?: SortOrder
    checkoutLongitude?: SortOrder
    checkoutTime?: SortOrder
  }

  export type JourneyPlanAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    checkoutLatitude?: SortOrder
    checkoutLongitude?: SortOrder
  }

  export type JourneyPlanMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    checkoutLatitude?: SortOrder
    checkoutLongitude?: SortOrder
    checkoutTime?: SortOrder
  }

  export type JourneyPlanMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    time?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    checkInTime?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    imageUrl?: SortOrder
    notes?: SortOrder
    checkoutLatitude?: SortOrder
    checkoutLongitude?: SortOrder
    checkoutTime?: SortOrder
  }

  export type JourneyPlanSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clientId?: SortOrder
    status?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    checkoutLatitude?: SortOrder
    checkoutLongitude?: SortOrder
  }

  export type NoticeBoardCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeBoardAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NoticeBoardMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeBoardMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NoticeBoardSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type FeedbackReportNullableRelationFilter = {
    is?: FeedbackReportWhereInput | null
    isNot?: FeedbackReportWhereInput | null
  }

  export type ProductReportNullableRelationFilter = {
    is?: ProductReportWhereInput | null
    isNot?: ProductReportWhereInput | null
  }

  export type JourneyPlanNullableRelationFilter = {
    is?: JourneyPlanWhereInput | null
    isNot?: JourneyPlanWhereInput | null
  }

  export type VisibilityReportNullableRelationFilter = {
    is?: VisibilityReportWhereInput | null
    isNot?: VisibilityReportWhereInput | null
  }

  export type ReportCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrder
    type?: SortOrder
  }

  export type ReportAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrder
  }

  export type ReportMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrder
    type?: SortOrder
  }

  export type ReportMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrder
    type?: SortOrder
  }

  export type ReportSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    clientId?: SortOrder
    userId?: SortOrder
    journeyPlanId?: SortOrder
  }

  export type EnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type ReportRelationFilter = {
    is?: ReportWhereInput
    isNot?: ReportWhereInput
  }

  export type FeedbackReportCountOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackReportAvgOrderByAggregateInput = {
    reportId?: SortOrder
  }

  export type FeedbackReportMaxOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackReportMinOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type FeedbackReportSumOrderByAggregateInput = {
    reportId?: SortOrder
  }

  export type ProductReportCountOrderByAggregateInput = {
    reportId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReportAvgOrderByAggregateInput = {
    reportId?: SortOrder
    quantity?: SortOrder
  }

  export type ProductReportMaxOrderByAggregateInput = {
    reportId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReportMinOrderByAggregateInput = {
    reportId?: SortOrder
    productName?: SortOrder
    quantity?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductReportSumOrderByAggregateInput = {
    reportId?: SortOrder
    quantity?: SortOrder
  }

  export type VisibilityReportCountOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VisibilityReportAvgOrderByAggregateInput = {
    reportId?: SortOrder
  }

  export type VisibilityReportMaxOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VisibilityReportMinOrderByAggregateInput = {
    reportId?: SortOrder
    comment?: SortOrder
    imageUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type VisibilityReportSumOrderByAggregateInput = {
    reportId?: SortOrder
  }

  export type LeaveCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type LeaveMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    reason?: SortOrder
    attachment?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CountryCreateNestedOneWithoutSalesRepInput = {
    create?: XOR<CountryCreateWithoutSalesRepInput, CountryUncheckedCreateWithoutSalesRepInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSalesRepInput
    connect?: CountryWhereUniqueInput
  }

  export type JourneyPlanCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput> | JourneyPlanCreateWithoutUserInput[] | JourneyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutUserInput | JourneyPlanCreateOrConnectWithoutUserInput[]
    createMany?: JourneyPlanCreateManyUserInputEnvelope
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TokenCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type LeaveCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ManagerCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type MyOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput> | MyOrderCreateWithoutUserInput[] | MyOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutUserInput | MyOrderCreateOrConnectWithoutUserInput[]
    createMany?: MyOrderCreateManyUserInputEnvelope
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type JourneyPlanUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput> | JourneyPlanCreateWithoutUserInput[] | JourneyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutUserInput | JourneyPlanCreateOrConnectWithoutUserInput[]
    createMany?: JourneyPlanCreateManyUserInputEnvelope
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type TokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
  }

  export type LeaveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
  }

  export type ManagerUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    connect?: ManagerWhereUniqueInput
  }

  export type MyOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput> | MyOrderCreateWithoutUserInput[] | MyOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutUserInput | MyOrderCreateOrConnectWithoutUserInput[]
    createMany?: MyOrderCreateManyUserInputEnvelope
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type CountryUpdateOneRequiredWithoutSalesRepNestedInput = {
    create?: XOR<CountryCreateWithoutSalesRepInput, CountryUncheckedCreateWithoutSalesRepInput>
    connectOrCreate?: CountryCreateOrConnectWithoutSalesRepInput
    upsert?: CountryUpsertWithoutSalesRepInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutSalesRepInput, CountryUpdateWithoutSalesRepInput>, CountryUncheckedUpdateWithoutSalesRepInput>
  }

  export type JourneyPlanUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput> | JourneyPlanCreateWithoutUserInput[] | JourneyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutUserInput | JourneyPlanCreateOrConnectWithoutUserInput[]
    upsert?: JourneyPlanUpsertWithWhereUniqueWithoutUserInput | JourneyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyPlanCreateManyUserInputEnvelope
    set?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    disconnect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    delete?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    update?: JourneyPlanUpdateWithWhereUniqueWithoutUserInput | JourneyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyPlanUpdateManyWithWhereWithoutUserInput | JourneyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type LeaveUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ManagerUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type MyOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput> | MyOrderCreateWithoutUserInput[] | MyOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutUserInput | MyOrderCreateOrConnectWithoutUserInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutUserInput | MyOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MyOrderCreateManyUserInputEnvelope
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutUserInput | MyOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutUserInput | MyOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type JourneyPlanUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput> | JourneyPlanCreateWithoutUserInput[] | JourneyPlanUncheckedCreateWithoutUserInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutUserInput | JourneyPlanCreateOrConnectWithoutUserInput[]
    upsert?: JourneyPlanUpsertWithWhereUniqueWithoutUserInput | JourneyPlanUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: JourneyPlanCreateManyUserInputEnvelope
    set?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    disconnect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    delete?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    update?: JourneyPlanUpdateWithWhereUniqueWithoutUserInput | JourneyPlanUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: JourneyPlanUpdateManyWithWhereWithoutUserInput | JourneyPlanUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput> | ReportCreateWithoutUserInput[] | ReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutUserInput | ReportCreateOrConnectWithoutUserInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutUserInput | ReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReportCreateManyUserInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutUserInput | ReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutUserInput | ReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type TokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput> | TokenCreateWithoutUserInput[] | TokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TokenCreateOrConnectWithoutUserInput | TokenCreateOrConnectWithoutUserInput[]
    upsert?: TokenUpsertWithWhereUniqueWithoutUserInput | TokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TokenCreateManyUserInputEnvelope
    set?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    disconnect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    delete?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    connect?: TokenWhereUniqueInput | TokenWhereUniqueInput[]
    update?: TokenUpdateWithWhereUniqueWithoutUserInput | TokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TokenUpdateManyWithWhereWithoutUserInput | TokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TokenScalarWhereInput | TokenScalarWhereInput[]
  }

  export type LeaveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput> | LeaveCreateWithoutUserInput[] | LeaveUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveCreateOrConnectWithoutUserInput | LeaveCreateOrConnectWithoutUserInput[]
    upsert?: LeaveUpsertWithWhereUniqueWithoutUserInput | LeaveUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveCreateManyUserInputEnvelope
    set?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    disconnect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    delete?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    connect?: LeaveWhereUniqueInput | LeaveWhereUniqueInput[]
    update?: LeaveUpdateWithWhereUniqueWithoutUserInput | LeaveUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveUpdateManyWithWhereWithoutUserInput | LeaveUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
  }

  export type ManagerUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutUserInput
    upsert?: ManagerUpsertWithoutUserInput
    disconnect?: ManagerWhereInput | boolean
    delete?: ManagerWhereInput | boolean
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutUserInput, ManagerUpdateWithoutUserInput>, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type MyOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput> | MyOrderCreateWithoutUserInput[] | MyOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutUserInput | MyOrderCreateOrConnectWithoutUserInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutUserInput | MyOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MyOrderCreateManyUserInputEnvelope
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutUserInput | MyOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutUserInput | MyOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type SalesRepCreateNestedOneWithoutManagerInput = {
    create?: XOR<SalesRepCreateWithoutManagerInput, SalesRepUncheckedCreateWithoutManagerInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutManagerInput
    connect?: SalesRepWhereUniqueInput
  }

  export type ManagerCheckinCreateNestedManyWithoutManagerInput = {
    create?: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput> | ManagerCheckinCreateWithoutManagerInput[] | ManagerCheckinUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutManagerInput | ManagerCheckinCreateOrConnectWithoutManagerInput[]
    createMany?: ManagerCheckinCreateManyManagerInputEnvelope
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
  }

  export type ManagerCheckinUncheckedCreateNestedManyWithoutManagerInput = {
    create?: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput> | ManagerCheckinCreateWithoutManagerInput[] | ManagerCheckinUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutManagerInput | ManagerCheckinCreateOrConnectWithoutManagerInput[]
    createMany?: ManagerCheckinCreateManyManagerInputEnvelope
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
  }

  export type SalesRepUpdateOneRequiredWithoutManagerNestedInput = {
    create?: XOR<SalesRepCreateWithoutManagerInput, SalesRepUncheckedCreateWithoutManagerInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutManagerInput
    upsert?: SalesRepUpsertWithoutManagerInput
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutManagerInput, SalesRepUpdateWithoutManagerInput>, SalesRepUncheckedUpdateWithoutManagerInput>
  }

  export type ManagerCheckinUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput> | ManagerCheckinCreateWithoutManagerInput[] | ManagerCheckinUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutManagerInput | ManagerCheckinCreateOrConnectWithoutManagerInput[]
    upsert?: ManagerCheckinUpsertWithWhereUniqueWithoutManagerInput | ManagerCheckinUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ManagerCheckinCreateManyManagerInputEnvelope
    set?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    disconnect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    delete?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    update?: ManagerCheckinUpdateWithWhereUniqueWithoutManagerInput | ManagerCheckinUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ManagerCheckinUpdateManyWithWhereWithoutManagerInput | ManagerCheckinUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
  }

  export type ManagerCheckinUncheckedUpdateManyWithoutManagerNestedInput = {
    create?: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput> | ManagerCheckinCreateWithoutManagerInput[] | ManagerCheckinUncheckedCreateWithoutManagerInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutManagerInput | ManagerCheckinCreateOrConnectWithoutManagerInput[]
    upsert?: ManagerCheckinUpsertWithWhereUniqueWithoutManagerInput | ManagerCheckinUpsertWithWhereUniqueWithoutManagerInput[]
    createMany?: ManagerCheckinCreateManyManagerInputEnvelope
    set?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    disconnect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    delete?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    update?: ManagerCheckinUpdateWithWhereUniqueWithoutManagerInput | ManagerCheckinUpdateWithWhereUniqueWithoutManagerInput[]
    updateMany?: ManagerCheckinUpdateManyWithWhereWithoutManagerInput | ManagerCheckinUpdateManyWithWhereWithoutManagerInput[]
    deleteMany?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
  }

  export type SalesRepCreateNestedOneWithoutTokensInput = {
    create?: XOR<SalesRepCreateWithoutTokensInput, SalesRepUncheckedCreateWithoutTokensInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutTokensInput
    connect?: SalesRepWhereUniqueInput
  }

  export type SalesRepUpdateOneRequiredWithoutTokensNestedInput = {
    create?: XOR<SalesRepCreateWithoutTokensInput, SalesRepUncheckedCreateWithoutTokensInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutTokensInput
    upsert?: SalesRepUpsertWithoutTokensInput
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutTokensInput, SalesRepUpdateWithoutTokensInput>, SalesRepUncheckedUpdateWithoutTokensInput>
  }

  export type CountryCreateNestedOneWithoutRegionsInput = {
    create?: XOR<CountryCreateWithoutRegionsInput, CountryUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutRegionsInput
    connect?: CountryWhereUniqueInput
  }

  export type CountryUpdateOneRequiredWithoutRegionsNestedInput = {
    create?: XOR<CountryCreateWithoutRegionsInput, CountryUncheckedCreateWithoutRegionsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutRegionsInput
    upsert?: CountryUpsertWithoutRegionsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutRegionsInput, CountryUpdateWithoutRegionsInput>, CountryUncheckedUpdateWithoutRegionsInput>
  }

  export type RegionsCreateNestedManyWithoutCountryInput = {
    create?: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput> | RegionsCreateWithoutCountryInput[] | RegionsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: RegionsCreateOrConnectWithoutCountryInput | RegionsCreateOrConnectWithoutCountryInput[]
    createMany?: RegionsCreateManyCountryInputEnvelope
    connect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
  }

  export type ClientsCreateNestedManyWithoutCountryInput = {
    create?: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput> | ClientsCreateWithoutCountryInput[] | ClientsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientsCreateOrConnectWithoutCountryInput | ClientsCreateOrConnectWithoutCountryInput[]
    createMany?: ClientsCreateManyCountryInputEnvelope
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
  }

  export type SalesRepCreateNestedManyWithoutCountryInput = {
    create?: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput> | SalesRepCreateWithoutCountryInput[] | SalesRepUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SalesRepCreateOrConnectWithoutCountryInput | SalesRepCreateOrConnectWithoutCountryInput[]
    createMany?: SalesRepCreateManyCountryInputEnvelope
    connect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
  }

  export type RegionsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput> | RegionsCreateWithoutCountryInput[] | RegionsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: RegionsCreateOrConnectWithoutCountryInput | RegionsCreateOrConnectWithoutCountryInput[]
    createMany?: RegionsCreateManyCountryInputEnvelope
    connect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
  }

  export type ClientsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput> | ClientsCreateWithoutCountryInput[] | ClientsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientsCreateOrConnectWithoutCountryInput | ClientsCreateOrConnectWithoutCountryInput[]
    createMany?: ClientsCreateManyCountryInputEnvelope
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
  }

  export type SalesRepUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput> | SalesRepCreateWithoutCountryInput[] | SalesRepUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SalesRepCreateOrConnectWithoutCountryInput | SalesRepCreateOrConnectWithoutCountryInput[]
    createMany?: SalesRepCreateManyCountryInputEnvelope
    connect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
  }

  export type RegionsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput> | RegionsCreateWithoutCountryInput[] | RegionsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: RegionsCreateOrConnectWithoutCountryInput | RegionsCreateOrConnectWithoutCountryInput[]
    upsert?: RegionsUpsertWithWhereUniqueWithoutCountryInput | RegionsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: RegionsCreateManyCountryInputEnvelope
    set?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    disconnect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    delete?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    connect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    update?: RegionsUpdateWithWhereUniqueWithoutCountryInput | RegionsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: RegionsUpdateManyWithWhereWithoutCountryInput | RegionsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: RegionsScalarWhereInput | RegionsScalarWhereInput[]
  }

  export type ClientsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput> | ClientsCreateWithoutCountryInput[] | ClientsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientsCreateOrConnectWithoutCountryInput | ClientsCreateOrConnectWithoutCountryInput[]
    upsert?: ClientsUpsertWithWhereUniqueWithoutCountryInput | ClientsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: ClientsCreateManyCountryInputEnvelope
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    update?: ClientsUpdateWithWhereUniqueWithoutCountryInput | ClientsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: ClientsUpdateManyWithWhereWithoutCountryInput | ClientsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[]
  }

  export type SalesRepUpdateManyWithoutCountryNestedInput = {
    create?: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput> | SalesRepCreateWithoutCountryInput[] | SalesRepUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SalesRepCreateOrConnectWithoutCountryInput | SalesRepCreateOrConnectWithoutCountryInput[]
    upsert?: SalesRepUpsertWithWhereUniqueWithoutCountryInput | SalesRepUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: SalesRepCreateManyCountryInputEnvelope
    set?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    disconnect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    delete?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    connect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    update?: SalesRepUpdateWithWhereUniqueWithoutCountryInput | SalesRepUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: SalesRepUpdateManyWithWhereWithoutCountryInput | SalesRepUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: SalesRepScalarWhereInput | SalesRepScalarWhereInput[]
  }

  export type RegionsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput> | RegionsCreateWithoutCountryInput[] | RegionsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: RegionsCreateOrConnectWithoutCountryInput | RegionsCreateOrConnectWithoutCountryInput[]
    upsert?: RegionsUpsertWithWhereUniqueWithoutCountryInput | RegionsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: RegionsCreateManyCountryInputEnvelope
    set?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    disconnect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    delete?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    connect?: RegionsWhereUniqueInput | RegionsWhereUniqueInput[]
    update?: RegionsUpdateWithWhereUniqueWithoutCountryInput | RegionsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: RegionsUpdateManyWithWhereWithoutCountryInput | RegionsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: RegionsScalarWhereInput | RegionsScalarWhereInput[]
  }

  export type ClientsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput> | ClientsCreateWithoutCountryInput[] | ClientsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: ClientsCreateOrConnectWithoutCountryInput | ClientsCreateOrConnectWithoutCountryInput[]
    upsert?: ClientsUpsertWithWhereUniqueWithoutCountryInput | ClientsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: ClientsCreateManyCountryInputEnvelope
    set?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    disconnect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    delete?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    connect?: ClientsWhereUniqueInput | ClientsWhereUniqueInput[]
    update?: ClientsUpdateWithWhereUniqueWithoutCountryInput | ClientsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: ClientsUpdateManyWithWhereWithoutCountryInput | ClientsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: ClientsScalarWhereInput | ClientsScalarWhereInput[]
  }

  export type SalesRepUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput> | SalesRepCreateWithoutCountryInput[] | SalesRepUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: SalesRepCreateOrConnectWithoutCountryInput | SalesRepCreateOrConnectWithoutCountryInput[]
    upsert?: SalesRepUpsertWithWhereUniqueWithoutCountryInput | SalesRepUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: SalesRepCreateManyCountryInputEnvelope
    set?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    disconnect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    delete?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    connect?: SalesRepWhereUniqueInput | SalesRepWhereUniqueInput[]
    update?: SalesRepUpdateWithWhereUniqueWithoutCountryInput | SalesRepUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: SalesRepUpdateManyWithWhereWithoutCountryInput | SalesRepUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: SalesRepScalarWhereInput | SalesRepScalarWhereInput[]
  }

  export type ClientsCreateNestedOneWithoutProductsInput = {
    create?: XOR<ClientsCreateWithoutProductsInput, ClientsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutProductsInput
    connect?: ClientsWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StoreQuantityCreateNestedManyWithoutProductInput = {
    create?: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput> | StoreQuantityCreateWithoutProductInput[] | StoreQuantityUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutProductInput | StoreQuantityCreateOrConnectWithoutProductInput[]
    createMany?: StoreQuantityCreateManyProductInputEnvelope
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseHistoryCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput> | PurchaseHistoryCreateWithoutProductInput[] | PurchaseHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutProductInput | PurchaseHistoryCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseHistoryCreateManyProductInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type StoreQuantityUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput> | StoreQuantityCreateWithoutProductInput[] | StoreQuantityUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutProductInput | StoreQuantityCreateOrConnectWithoutProductInput[]
    createMany?: StoreQuantityCreateManyProductInputEnvelope
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput> | PurchaseHistoryCreateWithoutProductInput[] | PurchaseHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutProductInput | PurchaseHistoryCreateOrConnectWithoutProductInput[]
    createMany?: PurchaseHistoryCreateManyProductInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type ClientsUpdateOneWithoutProductsNestedInput = {
    create?: XOR<ClientsCreateWithoutProductsInput, ClientsUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutProductsInput
    upsert?: ClientsUpsertWithoutProductsInput
    disconnect?: ClientsWhereInput | boolean
    delete?: ClientsWhereInput | boolean
    connect?: ClientsWhereUniqueInput
    update?: XOR<XOR<ClientsUpdateToOneWithWhereWithoutProductsInput, ClientsUpdateWithoutProductsInput>, ClientsUncheckedUpdateWithoutProductsInput>
  }

  export type OrderItemUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StoreQuantityUpdateManyWithoutProductNestedInput = {
    create?: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput> | StoreQuantityCreateWithoutProductInput[] | StoreQuantityUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutProductInput | StoreQuantityCreateOrConnectWithoutProductInput[]
    upsert?: StoreQuantityUpsertWithWhereUniqueWithoutProductInput | StoreQuantityUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StoreQuantityCreateManyProductInputEnvelope
    set?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    disconnect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    delete?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    update?: StoreQuantityUpdateWithWhereUniqueWithoutProductInput | StoreQuantityUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StoreQuantityUpdateManyWithWhereWithoutProductInput | StoreQuantityUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseHistoryUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput> | PurchaseHistoryCreateWithoutProductInput[] | PurchaseHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutProductInput | PurchaseHistoryCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutProductInput | PurchaseHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseHistoryCreateManyProductInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutProductInput | PurchaseHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutProductInput | PurchaseHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput> | OrderItemCreateWithoutProductInput[] | OrderItemUncheckedCreateWithoutProductInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutProductInput | OrderItemCreateOrConnectWithoutProductInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutProductInput | OrderItemUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: OrderItemCreateManyProductInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutProductInput | OrderItemUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutProductInput | OrderItemUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type StoreQuantityUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput> | StoreQuantityCreateWithoutProductInput[] | StoreQuantityUncheckedCreateWithoutProductInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutProductInput | StoreQuantityCreateOrConnectWithoutProductInput[]
    upsert?: StoreQuantityUpsertWithWhereUniqueWithoutProductInput | StoreQuantityUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: StoreQuantityCreateManyProductInputEnvelope
    set?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    disconnect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    delete?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    update?: StoreQuantityUpdateWithWhereUniqueWithoutProductInput | StoreQuantityUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: StoreQuantityUpdateManyWithWhereWithoutProductInput | StoreQuantityUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput> | PurchaseCreateWithoutProductInput[] | PurchaseUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutProductInput | PurchaseCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutProductInput | PurchaseUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseCreateManyProductInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutProductInput | PurchaseUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutProductInput | PurchaseUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput> | PurchaseHistoryCreateWithoutProductInput[] | PurchaseHistoryUncheckedCreateWithoutProductInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutProductInput | PurchaseHistoryCreateOrConnectWithoutProductInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutProductInput | PurchaseHistoryUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: PurchaseHistoryCreateManyProductInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutProductInput | PurchaseHistoryUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutProductInput | PurchaseHistoryUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type PriceOptionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput> | PriceOptionCreateWithoutCategoryInput[] | PriceOptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PriceOptionCreateOrConnectWithoutCategoryInput | PriceOptionCreateOrConnectWithoutCategoryInput[]
    createMany?: PriceOptionCreateManyCategoryInputEnvelope
    connect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
  }

  export type PriceOptionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput> | PriceOptionCreateWithoutCategoryInput[] | PriceOptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PriceOptionCreateOrConnectWithoutCategoryInput | PriceOptionCreateOrConnectWithoutCategoryInput[]
    createMany?: PriceOptionCreateManyCategoryInputEnvelope
    connect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
  }

  export type PriceOptionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput> | PriceOptionCreateWithoutCategoryInput[] | PriceOptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PriceOptionCreateOrConnectWithoutCategoryInput | PriceOptionCreateOrConnectWithoutCategoryInput[]
    upsert?: PriceOptionUpsertWithWhereUniqueWithoutCategoryInput | PriceOptionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PriceOptionCreateManyCategoryInputEnvelope
    set?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    disconnect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    delete?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    connect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    update?: PriceOptionUpdateWithWhereUniqueWithoutCategoryInput | PriceOptionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PriceOptionUpdateManyWithWhereWithoutCategoryInput | PriceOptionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PriceOptionScalarWhereInput | PriceOptionScalarWhereInput[]
  }

  export type PriceOptionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput> | PriceOptionCreateWithoutCategoryInput[] | PriceOptionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: PriceOptionCreateOrConnectWithoutCategoryInput | PriceOptionCreateOrConnectWithoutCategoryInput[]
    upsert?: PriceOptionUpsertWithWhereUniqueWithoutCategoryInput | PriceOptionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: PriceOptionCreateManyCategoryInputEnvelope
    set?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    disconnect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    delete?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    connect?: PriceOptionWhereUniqueInput | PriceOptionWhereUniqueInput[]
    update?: PriceOptionUpdateWithWhereUniqueWithoutCategoryInput | PriceOptionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: PriceOptionUpdateManyWithWhereWithoutCategoryInput | PriceOptionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: PriceOptionScalarWhereInput | PriceOptionScalarWhereInput[]
  }

  export type CategoryCreateNestedOneWithoutPriceOptionsInput = {
    create?: XOR<CategoryCreateWithoutPriceOptionsInput, CategoryUncheckedCreateWithoutPriceOptionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPriceOptionsInput
    connect?: CategoryWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutPriceOptionInput = {
    create?: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput> | OrderItemCreateWithoutPriceOptionInput[] | OrderItemUncheckedCreateWithoutPriceOptionInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPriceOptionInput | OrderItemCreateOrConnectWithoutPriceOptionInput[]
    createMany?: OrderItemCreateManyPriceOptionInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutPriceOptionInput = {
    create?: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput> | OrderItemCreateWithoutPriceOptionInput[] | OrderItemUncheckedCreateWithoutPriceOptionInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPriceOptionInput | OrderItemCreateOrConnectWithoutPriceOptionInput[]
    createMany?: OrderItemCreateManyPriceOptionInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type CategoryUpdateOneRequiredWithoutPriceOptionsNestedInput = {
    create?: XOR<CategoryCreateWithoutPriceOptionsInput, CategoryUncheckedCreateWithoutPriceOptionsInput>
    connectOrCreate?: CategoryCreateOrConnectWithoutPriceOptionsInput
    upsert?: CategoryUpsertWithoutPriceOptionsInput
    connect?: CategoryWhereUniqueInput
    update?: XOR<XOR<CategoryUpdateToOneWithWhereWithoutPriceOptionsInput, CategoryUpdateWithoutPriceOptionsInput>, CategoryUncheckedUpdateWithoutPriceOptionsInput>
  }

  export type OrderItemUpdateManyWithoutPriceOptionNestedInput = {
    create?: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput> | OrderItemCreateWithoutPriceOptionInput[] | OrderItemUncheckedCreateWithoutPriceOptionInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPriceOptionInput | OrderItemCreateOrConnectWithoutPriceOptionInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutPriceOptionInput | OrderItemUpsertWithWhereUniqueWithoutPriceOptionInput[]
    createMany?: OrderItemCreateManyPriceOptionInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutPriceOptionInput | OrderItemUpdateWithWhereUniqueWithoutPriceOptionInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutPriceOptionInput | OrderItemUpdateManyWithWhereWithoutPriceOptionInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutPriceOptionNestedInput = {
    create?: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput> | OrderItemCreateWithoutPriceOptionInput[] | OrderItemUncheckedCreateWithoutPriceOptionInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutPriceOptionInput | OrderItemCreateOrConnectWithoutPriceOptionInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutPriceOptionInput | OrderItemUpsertWithWhereUniqueWithoutPriceOptionInput[]
    createMany?: OrderItemCreateManyPriceOptionInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutPriceOptionInput | OrderItemUpdateWithWhereUniqueWithoutPriceOptionInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutPriceOptionInput | OrderItemUpdateManyWithWhereWithoutPriceOptionInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutStoreQuantitiesInput = {
    create?: XOR<ProductCreateWithoutStoreQuantitiesInput, ProductUncheckedCreateWithoutStoreQuantitiesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStoreQuantitiesInput
    connect?: ProductWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutStoreQuantitiesInput = {
    create?: XOR<StoresCreateWithoutStoreQuantitiesInput, StoresUncheckedCreateWithoutStoreQuantitiesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutStoreQuantitiesInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutStoreQuantitiesNestedInput = {
    create?: XOR<ProductCreateWithoutStoreQuantitiesInput, ProductUncheckedCreateWithoutStoreQuantitiesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutStoreQuantitiesInput
    upsert?: ProductUpsertWithoutStoreQuantitiesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutStoreQuantitiesInput, ProductUpdateWithoutStoreQuantitiesInput>, ProductUncheckedUpdateWithoutStoreQuantitiesInput>
  }

  export type StoresUpdateOneRequiredWithoutStoreQuantitiesNestedInput = {
    create?: XOR<StoresCreateWithoutStoreQuantitiesInput, StoresUncheckedCreateWithoutStoreQuantitiesInput>
    connectOrCreate?: StoresCreateOrConnectWithoutStoreQuantitiesInput
    upsert?: StoresUpsertWithoutStoreQuantitiesInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutStoreQuantitiesInput, StoresUpdateWithoutStoreQuantitiesInput>, StoresUncheckedUpdateWithoutStoreQuantitiesInput>
  }

  export type StoreQuantityCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput> | StoreQuantityCreateWithoutStoreInput[] | StoreQuantityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutStoreInput | StoreQuantityCreateOrConnectWithoutStoreInput[]
    createMany?: StoreQuantityCreateManyStoreInputEnvelope
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
  }

  export type PurchaseCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseHistoryCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput> | PurchaseHistoryCreateWithoutStoreInput[] | PurchaseHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutStoreInput | PurchaseHistoryCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseHistoryCreateManyStoreInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type StoreQuantityUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput> | StoreQuantityCreateWithoutStoreInput[] | StoreQuantityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutStoreInput | StoreQuantityCreateOrConnectWithoutStoreInput[]
    createMany?: StoreQuantityCreateManyStoreInputEnvelope
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
  }

  export type PurchaseUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
  }

  export type PurchaseHistoryUncheckedCreateNestedManyWithoutStoreInput = {
    create?: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput> | PurchaseHistoryCreateWithoutStoreInput[] | PurchaseHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutStoreInput | PurchaseHistoryCreateOrConnectWithoutStoreInput[]
    createMany?: PurchaseHistoryCreateManyStoreInputEnvelope
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
  }

  export type StoreQuantityUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput> | StoreQuantityCreateWithoutStoreInput[] | StoreQuantityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutStoreInput | StoreQuantityCreateOrConnectWithoutStoreInput[]
    upsert?: StoreQuantityUpsertWithWhereUniqueWithoutStoreInput | StoreQuantityUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreQuantityCreateManyStoreInputEnvelope
    set?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    disconnect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    delete?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    update?: StoreQuantityUpdateWithWhereUniqueWithoutStoreInput | StoreQuantityUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreQuantityUpdateManyWithWhereWithoutStoreInput | StoreQuantityUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
  }

  export type PurchaseUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseHistoryUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput> | PurchaseHistoryCreateWithoutStoreInput[] | PurchaseHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutStoreInput | PurchaseHistoryCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutStoreInput | PurchaseHistoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseHistoryCreateManyStoreInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutStoreInput | PurchaseHistoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutStoreInput | PurchaseHistoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type StoreQuantityUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput> | StoreQuantityCreateWithoutStoreInput[] | StoreQuantityUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: StoreQuantityCreateOrConnectWithoutStoreInput | StoreQuantityCreateOrConnectWithoutStoreInput[]
    upsert?: StoreQuantityUpsertWithWhereUniqueWithoutStoreInput | StoreQuantityUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: StoreQuantityCreateManyStoreInputEnvelope
    set?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    disconnect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    delete?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    connect?: StoreQuantityWhereUniqueInput | StoreQuantityWhereUniqueInput[]
    update?: StoreQuantityUpdateWithWhereUniqueWithoutStoreInput | StoreQuantityUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: StoreQuantityUpdateManyWithWhereWithoutStoreInput | StoreQuantityUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput> | PurchaseCreateWithoutStoreInput[] | PurchaseUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseCreateOrConnectWithoutStoreInput | PurchaseCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseUpsertWithWhereUniqueWithoutStoreInput | PurchaseUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseCreateManyStoreInputEnvelope
    set?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    disconnect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    delete?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    connect?: PurchaseWhereUniqueInput | PurchaseWhereUniqueInput[]
    update?: PurchaseUpdateWithWhereUniqueWithoutStoreInput | PurchaseUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseUpdateManyWithWhereWithoutStoreInput | PurchaseUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutStoreNestedInput = {
    create?: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput> | PurchaseHistoryCreateWithoutStoreInput[] | PurchaseHistoryUncheckedCreateWithoutStoreInput[]
    connectOrCreate?: PurchaseHistoryCreateOrConnectWithoutStoreInput | PurchaseHistoryCreateOrConnectWithoutStoreInput[]
    upsert?: PurchaseHistoryUpsertWithWhereUniqueWithoutStoreInput | PurchaseHistoryUpsertWithWhereUniqueWithoutStoreInput[]
    createMany?: PurchaseHistoryCreateManyStoreInputEnvelope
    set?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    disconnect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    delete?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    connect?: PurchaseHistoryWhereUniqueInput | PurchaseHistoryWhereUniqueInput[]
    update?: PurchaseHistoryUpdateWithWhereUniqueWithoutStoreInput | PurchaseHistoryUpdateWithWhereUniqueWithoutStoreInput[]
    updateMany?: PurchaseHistoryUpdateManyWithWhereWithoutStoreInput | PurchaseHistoryUpdateManyWithWhereWithoutStoreInput[]
    deleteMany?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput
    connect?: ProductWhereUniqueInput
  }

  export type StoresCreateNestedOneWithoutPurchaseInput = {
    create?: XOR<StoresCreateWithoutPurchaseInput, StoresUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPurchaseInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseInput
    upsert?: ProductUpsertWithoutPurchaseInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseInput, ProductUpdateWithoutPurchaseInput>, ProductUncheckedUpdateWithoutPurchaseInput>
  }

  export type StoresUpdateOneRequiredWithoutPurchaseNestedInput = {
    create?: XOR<StoresCreateWithoutPurchaseInput, StoresUncheckedCreateWithoutPurchaseInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPurchaseInput
    upsert?: StoresUpsertWithoutPurchaseInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutPurchaseInput, StoresUpdateWithoutPurchaseInput>, StoresUncheckedUpdateWithoutPurchaseInput>
  }

  export type StoresCreateNestedOneWithoutPurchaseHistoryInput = {
    create?: XOR<StoresCreateWithoutPurchaseHistoryInput, StoresUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPurchaseHistoryInput
    connect?: StoresWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutPurchaseHistoryInput = {
    create?: XOR<ProductCreateWithoutPurchaseHistoryInput, ProductUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseHistoryInput
    connect?: ProductWhereUniqueInput
  }

  export type StoresUpdateOneRequiredWithoutPurchaseHistoryNestedInput = {
    create?: XOR<StoresCreateWithoutPurchaseHistoryInput, StoresUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: StoresCreateOrConnectWithoutPurchaseHistoryInput
    upsert?: StoresUpsertWithoutPurchaseHistoryInput
    connect?: StoresWhereUniqueInput
    update?: XOR<XOR<StoresUpdateToOneWithWhereWithoutPurchaseHistoryInput, StoresUpdateWithoutPurchaseHistoryInput>, StoresUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type ProductUpdateOneRequiredWithoutPurchaseHistoryNestedInput = {
    create?: XOR<ProductCreateWithoutPurchaseHistoryInput, ProductUncheckedCreateWithoutPurchaseHistoryInput>
    connectOrCreate?: ProductCreateOrConnectWithoutPurchaseHistoryInput
    upsert?: ProductUpsertWithoutPurchaseHistoryInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutPurchaseHistoryInput, ProductUpdateWithoutPurchaseHistoryInput>, ProductUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type CountryCreateNestedOneWithoutClientsInput = {
    create?: XOR<CountryCreateWithoutClientsInput, CountryUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutClientsInput
    connect?: CountryWhereUniqueInput
  }

  export type JourneyPlanCreateNestedManyWithoutClientInput = {
    create?: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput> | JourneyPlanCreateWithoutClientInput[] | JourneyPlanUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutClientInput | JourneyPlanCreateOrConnectWithoutClientInput[]
    createMany?: JourneyPlanCreateManyClientInputEnvelope
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
  }

  export type MyOrderCreateNestedManyWithoutClientInput = {
    create?: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput> | MyOrderCreateWithoutClientInput[] | MyOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutClientInput | MyOrderCreateOrConnectWithoutClientInput[]
    createMany?: MyOrderCreateManyClientInputEnvelope
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type ProductCreateNestedManyWithoutClientInput = {
    create?: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput> | ProductCreateWithoutClientInput[] | ProductUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClientInput | ProductCreateOrConnectWithoutClientInput[]
    createMany?: ProductCreateManyClientInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutClientInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ManagerCheckinCreateNestedManyWithoutClientInput = {
    create?: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput> | ManagerCheckinCreateWithoutClientInput[] | ManagerCheckinUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutClientInput | ManagerCheckinCreateOrConnectWithoutClientInput[]
    createMany?: ManagerCheckinCreateManyClientInputEnvelope
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
  }

  export type JourneyPlanUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput> | JourneyPlanCreateWithoutClientInput[] | JourneyPlanUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutClientInput | JourneyPlanCreateOrConnectWithoutClientInput[]
    createMany?: JourneyPlanCreateManyClientInputEnvelope
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
  }

  export type MyOrderUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput> | MyOrderCreateWithoutClientInput[] | MyOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutClientInput | MyOrderCreateOrConnectWithoutClientInput[]
    createMany?: MyOrderCreateManyClientInputEnvelope
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput> | ProductCreateWithoutClientInput[] | ProductUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClientInput | ProductCreateOrConnectWithoutClientInput[]
    createMany?: ProductCreateManyClientInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ManagerCheckinUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput> | ManagerCheckinCreateWithoutClientInput[] | ManagerCheckinUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutClientInput | ManagerCheckinCreateOrConnectWithoutClientInput[]
    createMany?: ManagerCheckinCreateManyClientInputEnvelope
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountryUpdateOneRequiredWithoutClientsNestedInput = {
    create?: XOR<CountryCreateWithoutClientsInput, CountryUncheckedCreateWithoutClientsInput>
    connectOrCreate?: CountryCreateOrConnectWithoutClientsInput
    upsert?: CountryUpsertWithoutClientsInput
    connect?: CountryWhereUniqueInput
    update?: XOR<XOR<CountryUpdateToOneWithWhereWithoutClientsInput, CountryUpdateWithoutClientsInput>, CountryUncheckedUpdateWithoutClientsInput>
  }

  export type JourneyPlanUpdateManyWithoutClientNestedInput = {
    create?: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput> | JourneyPlanCreateWithoutClientInput[] | JourneyPlanUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutClientInput | JourneyPlanCreateOrConnectWithoutClientInput[]
    upsert?: JourneyPlanUpsertWithWhereUniqueWithoutClientInput | JourneyPlanUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JourneyPlanCreateManyClientInputEnvelope
    set?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    disconnect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    delete?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    update?: JourneyPlanUpdateWithWhereUniqueWithoutClientInput | JourneyPlanUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JourneyPlanUpdateManyWithWhereWithoutClientInput | JourneyPlanUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
  }

  export type MyOrderUpdateManyWithoutClientNestedInput = {
    create?: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput> | MyOrderCreateWithoutClientInput[] | MyOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutClientInput | MyOrderCreateOrConnectWithoutClientInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutClientInput | MyOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MyOrderCreateManyClientInputEnvelope
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutClientInput | MyOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutClientInput | MyOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type ProductUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput> | ProductCreateWithoutClientInput[] | ProductUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClientInput | ProductCreateOrConnectWithoutClientInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutClientInput | ProductUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProductCreateManyClientInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutClientInput | ProductUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutClientInput | ProductUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutClientInput | ReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutClientInput | ReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutClientInput | ReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ManagerCheckinUpdateManyWithoutClientNestedInput = {
    create?: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput> | ManagerCheckinCreateWithoutClientInput[] | ManagerCheckinUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutClientInput | ManagerCheckinCreateOrConnectWithoutClientInput[]
    upsert?: ManagerCheckinUpsertWithWhereUniqueWithoutClientInput | ManagerCheckinUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ManagerCheckinCreateManyClientInputEnvelope
    set?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    disconnect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    delete?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    update?: ManagerCheckinUpdateWithWhereUniqueWithoutClientInput | ManagerCheckinUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ManagerCheckinUpdateManyWithWhereWithoutClientInput | ManagerCheckinUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
  }

  export type JourneyPlanUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput> | JourneyPlanCreateWithoutClientInput[] | JourneyPlanUncheckedCreateWithoutClientInput[]
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutClientInput | JourneyPlanCreateOrConnectWithoutClientInput[]
    upsert?: JourneyPlanUpsertWithWhereUniqueWithoutClientInput | JourneyPlanUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: JourneyPlanCreateManyClientInputEnvelope
    set?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    disconnect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    delete?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    connect?: JourneyPlanWhereUniqueInput | JourneyPlanWhereUniqueInput[]
    update?: JourneyPlanUpdateWithWhereUniqueWithoutClientInput | JourneyPlanUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: JourneyPlanUpdateManyWithWhereWithoutClientInput | JourneyPlanUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
  }

  export type MyOrderUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput> | MyOrderCreateWithoutClientInput[] | MyOrderUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutClientInput | MyOrderCreateOrConnectWithoutClientInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutClientInput | MyOrderUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MyOrderCreateManyClientInputEnvelope
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutClientInput | MyOrderUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutClientInput | MyOrderUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput> | ProductCreateWithoutClientInput[] | ProductUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutClientInput | ProductCreateOrConnectWithoutClientInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutClientInput | ProductUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProductCreateManyClientInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutClientInput | ProductUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutClientInput | ProductUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput> | ReportCreateWithoutClientInput[] | ReportUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutClientInput | ReportCreateOrConnectWithoutClientInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutClientInput | ReportUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ReportCreateManyClientInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutClientInput | ReportUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutClientInput | ReportUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput> | ManagerCheckinCreateWithoutClientInput[] | ManagerCheckinUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ManagerCheckinCreateOrConnectWithoutClientInput | ManagerCheckinCreateOrConnectWithoutClientInput[]
    upsert?: ManagerCheckinUpsertWithWhereUniqueWithoutClientInput | ManagerCheckinUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ManagerCheckinCreateManyClientInputEnvelope
    set?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    disconnect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    delete?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    connect?: ManagerCheckinWhereUniqueInput | ManagerCheckinWhereUniqueInput[]
    update?: ManagerCheckinUpdateWithWhereUniqueWithoutClientInput | ManagerCheckinUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ManagerCheckinUpdateManyWithWhereWithoutClientInput | ManagerCheckinUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
  }

  export type ManagerCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<ManagerCreateWithoutCheckinsInput, ManagerUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCheckinsInput
    connect?: ManagerWhereUniqueInput
  }

  export type ClientsCreateNestedOneWithoutCheckinsInput = {
    create?: XOR<ClientsCreateWithoutCheckinsInput, ClientsUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutCheckinsInput
    connect?: ClientsWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ManagerUpdateOneRequiredWithoutCheckinsNestedInput = {
    create?: XOR<ManagerCreateWithoutCheckinsInput, ManagerUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: ManagerCreateOrConnectWithoutCheckinsInput
    upsert?: ManagerUpsertWithoutCheckinsInput
    connect?: ManagerWhereUniqueInput
    update?: XOR<XOR<ManagerUpdateToOneWithWhereWithoutCheckinsInput, ManagerUpdateWithoutCheckinsInput>, ManagerUncheckedUpdateWithoutCheckinsInput>
  }

  export type ClientsUpdateOneRequiredWithoutCheckinsNestedInput = {
    create?: XOR<ClientsCreateWithoutCheckinsInput, ClientsUncheckedCreateWithoutCheckinsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutCheckinsInput
    upsert?: ClientsUpsertWithoutCheckinsInput
    connect?: ClientsWhereUniqueInput
    update?: XOR<XOR<ClientsUpdateToOneWithWhereWithoutCheckinsInput, ClientsUpdateWithoutCheckinsInput>, ClientsUncheckedUpdateWithoutCheckinsInput>
  }

  export type ClientsCreateNestedOneWithoutMyOrderInput = {
    create?: XOR<ClientsCreateWithoutMyOrderInput, ClientsUncheckedCreateWithoutMyOrderInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutMyOrderInput
    connect?: ClientsWhereUniqueInput
  }

  export type SalesRepCreateNestedOneWithoutMyOrderInput = {
    create?: XOR<SalesRepCreateWithoutMyOrderInput, SalesRepUncheckedCreateWithoutMyOrderInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutMyOrderInput
    connect?: SalesRepWhereUniqueInput
  }

  export type OrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ReportCreateNestedManyWithoutMyOrderInput = {
    create?: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput> | ReportCreateWithoutMyOrderInput[] | ReportUncheckedCreateWithoutMyOrderInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMyOrderInput | ReportCreateOrConnectWithoutMyOrderInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type OrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutMyOrderInput = {
    create?: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput> | ReportCreateWithoutMyOrderInput[] | ReportUncheckedCreateWithoutMyOrderInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMyOrderInput | ReportCreateOrConnectWithoutMyOrderInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientsUpdateOneRequiredWithoutMyOrderNestedInput = {
    create?: XOR<ClientsCreateWithoutMyOrderInput, ClientsUncheckedCreateWithoutMyOrderInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutMyOrderInput
    upsert?: ClientsUpsertWithoutMyOrderInput
    connect?: ClientsWhereUniqueInput
    update?: XOR<XOR<ClientsUpdateToOneWithWhereWithoutMyOrderInput, ClientsUpdateWithoutMyOrderInput>, ClientsUncheckedUpdateWithoutMyOrderInput>
  }

  export type SalesRepUpdateOneRequiredWithoutMyOrderNestedInput = {
    create?: XOR<SalesRepCreateWithoutMyOrderInput, SalesRepUncheckedCreateWithoutMyOrderInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutMyOrderInput
    upsert?: SalesRepUpsertWithoutMyOrderInput
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutMyOrderInput, SalesRepUpdateWithoutMyOrderInput>, SalesRepUncheckedUpdateWithoutMyOrderInput>
  }

  export type OrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ReportUpdateManyWithoutMyOrderNestedInput = {
    create?: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput> | ReportCreateWithoutMyOrderInput[] | ReportUncheckedCreateWithoutMyOrderInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMyOrderInput | ReportCreateOrConnectWithoutMyOrderInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMyOrderInput | ReportUpsertWithWhereUniqueWithoutMyOrderInput[]
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMyOrderInput | ReportUpdateWithWhereUniqueWithoutMyOrderInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMyOrderInput | ReportUpdateManyWithWhereWithoutMyOrderInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput> | OrderItemCreateWithoutOrderInput[] | OrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: OrderItemCreateOrConnectWithoutOrderInput | OrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: OrderItemUpsertWithWhereUniqueWithoutOrderInput | OrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: OrderItemCreateManyOrderInputEnvelope
    set?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    disconnect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    delete?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    connect?: OrderItemWhereUniqueInput | OrderItemWhereUniqueInput[]
    update?: OrderItemUpdateWithWhereUniqueWithoutOrderInput | OrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: OrderItemUpdateManyWithWhereWithoutOrderInput | OrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutMyOrderNestedInput = {
    create?: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput> | ReportCreateWithoutMyOrderInput[] | ReportUncheckedCreateWithoutMyOrderInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutMyOrderInput | ReportCreateOrConnectWithoutMyOrderInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutMyOrderInput | ReportUpsertWithWhereUniqueWithoutMyOrderInput[]
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutMyOrderInput | ReportUpdateWithWhereUniqueWithoutMyOrderInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutMyOrderInput | ReportUpdateManyWithWhereWithoutMyOrderInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type PriceOptionCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<PriceOptionCreateWithoutOrderItemsInput, PriceOptionUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: PriceOptionCreateOrConnectWithoutOrderItemsInput
    connect?: PriceOptionWhereUniqueInput
  }

  export type MyOrderCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MyOrderCreateWithoutOrderItemsInput, MyOrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MyOrderCreateOrConnectWithoutOrderItemsInput
    connect?: MyOrderWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
  }

  export type PriceOptionUpdateOneWithoutOrderItemsNestedInput = {
    create?: XOR<PriceOptionCreateWithoutOrderItemsInput, PriceOptionUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: PriceOptionCreateOrConnectWithoutOrderItemsInput
    upsert?: PriceOptionUpsertWithoutOrderItemsInput
    disconnect?: PriceOptionWhereInput | boolean
    delete?: PriceOptionWhereInput | boolean
    connect?: PriceOptionWhereUniqueInput
    update?: XOR<XOR<PriceOptionUpdateToOneWithWhereWithoutOrderItemsInput, PriceOptionUpdateWithoutOrderItemsInput>, PriceOptionUncheckedUpdateWithoutOrderItemsInput>
  }

  export type MyOrderUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MyOrderCreateWithoutOrderItemsInput, MyOrderUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MyOrderCreateOrConnectWithoutOrderItemsInput
    upsert?: MyOrderUpsertWithoutOrderItemsInput
    connect?: MyOrderWhereUniqueInput
    update?: XOR<XOR<MyOrderUpdateToOneWithWhereWithoutOrderItemsInput, MyOrderUpdateWithoutOrderItemsInput>, MyOrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOrderItemsInput
    upsert?: ProductUpsertWithoutOrderItemsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOrderItemsInput, ProductUpdateWithoutOrderItemsInput>, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ClientsCreateNestedOneWithoutJourneyPlansInput = {
    create?: XOR<ClientsCreateWithoutJourneyPlansInput, ClientsUncheckedCreateWithoutJourneyPlansInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutJourneyPlansInput
    connect?: ClientsWhereUniqueInput
  }

  export type SalesRepCreateNestedOneWithoutJourneyPlansInput = {
    create?: XOR<SalesRepCreateWithoutJourneyPlansInput, SalesRepUncheckedCreateWithoutJourneyPlansInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutJourneyPlansInput
    connect?: SalesRepWhereUniqueInput
  }

  export type ReportCreateNestedManyWithoutJourneyPlanInput = {
    create?: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput> | ReportCreateWithoutJourneyPlanInput[] | ReportUncheckedCreateWithoutJourneyPlanInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutJourneyPlanInput | ReportCreateOrConnectWithoutJourneyPlanInput[]
    createMany?: ReportCreateManyJourneyPlanInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ReportUncheckedCreateNestedManyWithoutJourneyPlanInput = {
    create?: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput> | ReportCreateWithoutJourneyPlanInput[] | ReportUncheckedCreateWithoutJourneyPlanInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutJourneyPlanInput | ReportCreateOrConnectWithoutJourneyPlanInput[]
    createMany?: ReportCreateManyJourneyPlanInputEnvelope
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
  }

  export type ClientsUpdateOneRequiredWithoutJourneyPlansNestedInput = {
    create?: XOR<ClientsCreateWithoutJourneyPlansInput, ClientsUncheckedCreateWithoutJourneyPlansInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutJourneyPlansInput
    upsert?: ClientsUpsertWithoutJourneyPlansInput
    connect?: ClientsWhereUniqueInput
    update?: XOR<XOR<ClientsUpdateToOneWithWhereWithoutJourneyPlansInput, ClientsUpdateWithoutJourneyPlansInput>, ClientsUncheckedUpdateWithoutJourneyPlansInput>
  }

  export type SalesRepUpdateOneWithoutJourneyPlansNestedInput = {
    create?: XOR<SalesRepCreateWithoutJourneyPlansInput, SalesRepUncheckedCreateWithoutJourneyPlansInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutJourneyPlansInput
    upsert?: SalesRepUpsertWithoutJourneyPlansInput
    disconnect?: SalesRepWhereInput | boolean
    delete?: SalesRepWhereInput | boolean
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutJourneyPlansInput, SalesRepUpdateWithoutJourneyPlansInput>, SalesRepUncheckedUpdateWithoutJourneyPlansInput>
  }

  export type ReportUpdateManyWithoutJourneyPlanNestedInput = {
    create?: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput> | ReportCreateWithoutJourneyPlanInput[] | ReportUncheckedCreateWithoutJourneyPlanInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutJourneyPlanInput | ReportCreateOrConnectWithoutJourneyPlanInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutJourneyPlanInput | ReportUpsertWithWhereUniqueWithoutJourneyPlanInput[]
    createMany?: ReportCreateManyJourneyPlanInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutJourneyPlanInput | ReportUpdateWithWhereUniqueWithoutJourneyPlanInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutJourneyPlanInput | ReportUpdateManyWithWhereWithoutJourneyPlanInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type ReportUncheckedUpdateManyWithoutJourneyPlanNestedInput = {
    create?: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput> | ReportCreateWithoutJourneyPlanInput[] | ReportUncheckedCreateWithoutJourneyPlanInput[]
    connectOrCreate?: ReportCreateOrConnectWithoutJourneyPlanInput | ReportCreateOrConnectWithoutJourneyPlanInput[]
    upsert?: ReportUpsertWithWhereUniqueWithoutJourneyPlanInput | ReportUpsertWithWhereUniqueWithoutJourneyPlanInput[]
    createMany?: ReportCreateManyJourneyPlanInputEnvelope
    set?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    disconnect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    delete?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    connect?: ReportWhereUniqueInput | ReportWhereUniqueInput[]
    update?: ReportUpdateWithWhereUniqueWithoutJourneyPlanInput | ReportUpdateWithWhereUniqueWithoutJourneyPlanInput[]
    updateMany?: ReportUpdateManyWithWhereWithoutJourneyPlanInput | ReportUpdateManyWithWhereWithoutJourneyPlanInput[]
    deleteMany?: ReportScalarWhereInput | ReportScalarWhereInput[]
  }

  export type FeedbackReportCreateNestedOneWithoutReportInput = {
    create?: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutReportInput
    connect?: FeedbackReportWhereUniqueInput
  }

  export type ProductReportCreateNestedOneWithoutReportInput = {
    create?: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: ProductReportCreateOrConnectWithoutReportInput
    connect?: ProductReportWhereUniqueInput
  }

  export type JourneyPlanCreateNestedOneWithoutReportsInput = {
    create?: XOR<JourneyPlanCreateWithoutReportsInput, JourneyPlanUncheckedCreateWithoutReportsInput>
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutReportsInput
    connect?: JourneyPlanWhereUniqueInput
  }

  export type MyOrderCreateNestedManyWithoutReportsInput = {
    create?: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput> | MyOrderCreateWithoutReportsInput[] | MyOrderUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutReportsInput | MyOrderCreateOrConnectWithoutReportsInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type ClientsCreateNestedOneWithoutReportsInput = {
    create?: XOR<ClientsCreateWithoutReportsInput, ClientsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutReportsInput
    connect?: ClientsWhereUniqueInput
  }

  export type SalesRepCreateNestedOneWithoutReportsInput = {
    create?: XOR<SalesRepCreateWithoutReportsInput, SalesRepUncheckedCreateWithoutReportsInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutReportsInput
    connect?: SalesRepWhereUniqueInput
  }

  export type VisibilityReportCreateNestedOneWithoutReportInput = {
    create?: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: VisibilityReportCreateOrConnectWithoutReportInput
    connect?: VisibilityReportWhereUniqueInput
  }

  export type FeedbackReportUncheckedCreateNestedOneWithoutReportInput = {
    create?: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutReportInput
    connect?: FeedbackReportWhereUniqueInput
  }

  export type ProductReportUncheckedCreateNestedOneWithoutReportInput = {
    create?: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: ProductReportCreateOrConnectWithoutReportInput
    connect?: ProductReportWhereUniqueInput
  }

  export type MyOrderUncheckedCreateNestedManyWithoutReportsInput = {
    create?: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput> | MyOrderCreateWithoutReportsInput[] | MyOrderUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutReportsInput | MyOrderCreateOrConnectWithoutReportsInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
  }

  export type VisibilityReportUncheckedCreateNestedOneWithoutReportInput = {
    create?: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: VisibilityReportCreateOrConnectWithoutReportInput
    connect?: VisibilityReportWhereUniqueInput
  }

  export type EnumReportTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReportType
  }

  export type FeedbackReportUpdateOneWithoutReportNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutReportInput
    upsert?: FeedbackReportUpsertWithoutReportInput
    disconnect?: FeedbackReportWhereInput | boolean
    delete?: FeedbackReportWhereInput | boolean
    connect?: FeedbackReportWhereUniqueInput
    update?: XOR<XOR<FeedbackReportUpdateToOneWithWhereWithoutReportInput, FeedbackReportUpdateWithoutReportInput>, FeedbackReportUncheckedUpdateWithoutReportInput>
  }

  export type ProductReportUpdateOneWithoutReportNestedInput = {
    create?: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: ProductReportCreateOrConnectWithoutReportInput
    upsert?: ProductReportUpsertWithoutReportInput
    disconnect?: ProductReportWhereInput | boolean
    delete?: ProductReportWhereInput | boolean
    connect?: ProductReportWhereUniqueInput
    update?: XOR<XOR<ProductReportUpdateToOneWithWhereWithoutReportInput, ProductReportUpdateWithoutReportInput>, ProductReportUncheckedUpdateWithoutReportInput>
  }

  export type JourneyPlanUpdateOneWithoutReportsNestedInput = {
    create?: XOR<JourneyPlanCreateWithoutReportsInput, JourneyPlanUncheckedCreateWithoutReportsInput>
    connectOrCreate?: JourneyPlanCreateOrConnectWithoutReportsInput
    upsert?: JourneyPlanUpsertWithoutReportsInput
    disconnect?: JourneyPlanWhereInput | boolean
    delete?: JourneyPlanWhereInput | boolean
    connect?: JourneyPlanWhereUniqueInput
    update?: XOR<XOR<JourneyPlanUpdateToOneWithWhereWithoutReportsInput, JourneyPlanUpdateWithoutReportsInput>, JourneyPlanUncheckedUpdateWithoutReportsInput>
  }

  export type MyOrderUpdateManyWithoutReportsNestedInput = {
    create?: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput> | MyOrderCreateWithoutReportsInput[] | MyOrderUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutReportsInput | MyOrderCreateOrConnectWithoutReportsInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutReportsInput | MyOrderUpsertWithWhereUniqueWithoutReportsInput[]
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutReportsInput | MyOrderUpdateWithWhereUniqueWithoutReportsInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutReportsInput | MyOrderUpdateManyWithWhereWithoutReportsInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type ClientsUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ClientsCreateWithoutReportsInput, ClientsUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ClientsCreateOrConnectWithoutReportsInput
    upsert?: ClientsUpsertWithoutReportsInput
    connect?: ClientsWhereUniqueInput
    update?: XOR<XOR<ClientsUpdateToOneWithWhereWithoutReportsInput, ClientsUpdateWithoutReportsInput>, ClientsUncheckedUpdateWithoutReportsInput>
  }

  export type SalesRepUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<SalesRepCreateWithoutReportsInput, SalesRepUncheckedCreateWithoutReportsInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutReportsInput
    upsert?: SalesRepUpsertWithoutReportsInput
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutReportsInput, SalesRepUpdateWithoutReportsInput>, SalesRepUncheckedUpdateWithoutReportsInput>
  }

  export type VisibilityReportUpdateOneWithoutReportNestedInput = {
    create?: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: VisibilityReportCreateOrConnectWithoutReportInput
    upsert?: VisibilityReportUpsertWithoutReportInput
    disconnect?: VisibilityReportWhereInput | boolean
    delete?: VisibilityReportWhereInput | boolean
    connect?: VisibilityReportWhereUniqueInput
    update?: XOR<XOR<VisibilityReportUpdateToOneWithWhereWithoutReportInput, VisibilityReportUpdateWithoutReportInput>, VisibilityReportUncheckedUpdateWithoutReportInput>
  }

  export type FeedbackReportUncheckedUpdateOneWithoutReportNestedInput = {
    create?: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: FeedbackReportCreateOrConnectWithoutReportInput
    upsert?: FeedbackReportUpsertWithoutReportInput
    disconnect?: FeedbackReportWhereInput | boolean
    delete?: FeedbackReportWhereInput | boolean
    connect?: FeedbackReportWhereUniqueInput
    update?: XOR<XOR<FeedbackReportUpdateToOneWithWhereWithoutReportInput, FeedbackReportUpdateWithoutReportInput>, FeedbackReportUncheckedUpdateWithoutReportInput>
  }

  export type ProductReportUncheckedUpdateOneWithoutReportNestedInput = {
    create?: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: ProductReportCreateOrConnectWithoutReportInput
    upsert?: ProductReportUpsertWithoutReportInput
    disconnect?: ProductReportWhereInput | boolean
    delete?: ProductReportWhereInput | boolean
    connect?: ProductReportWhereUniqueInput
    update?: XOR<XOR<ProductReportUpdateToOneWithWhereWithoutReportInput, ProductReportUpdateWithoutReportInput>, ProductReportUncheckedUpdateWithoutReportInput>
  }

  export type MyOrderUncheckedUpdateManyWithoutReportsNestedInput = {
    create?: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput> | MyOrderCreateWithoutReportsInput[] | MyOrderUncheckedCreateWithoutReportsInput[]
    connectOrCreate?: MyOrderCreateOrConnectWithoutReportsInput | MyOrderCreateOrConnectWithoutReportsInput[]
    upsert?: MyOrderUpsertWithWhereUniqueWithoutReportsInput | MyOrderUpsertWithWhereUniqueWithoutReportsInput[]
    set?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    disconnect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    delete?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    connect?: MyOrderWhereUniqueInput | MyOrderWhereUniqueInput[]
    update?: MyOrderUpdateWithWhereUniqueWithoutReportsInput | MyOrderUpdateWithWhereUniqueWithoutReportsInput[]
    updateMany?: MyOrderUpdateManyWithWhereWithoutReportsInput | MyOrderUpdateManyWithWhereWithoutReportsInput[]
    deleteMany?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
  }

  export type VisibilityReportUncheckedUpdateOneWithoutReportNestedInput = {
    create?: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
    connectOrCreate?: VisibilityReportCreateOrConnectWithoutReportInput
    upsert?: VisibilityReportUpsertWithoutReportInput
    disconnect?: VisibilityReportWhereInput | boolean
    delete?: VisibilityReportWhereInput | boolean
    connect?: VisibilityReportWhereUniqueInput
    update?: XOR<XOR<VisibilityReportUpdateToOneWithWhereWithoutReportInput, VisibilityReportUpdateWithoutReportInput>, VisibilityReportUncheckedUpdateWithoutReportInput>
  }

  export type ReportCreateNestedOneWithoutFeedbackReportInput = {
    create?: XOR<ReportCreateWithoutFeedbackReportInput, ReportUncheckedCreateWithoutFeedbackReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutFeedbackReportInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportUpdateOneRequiredWithoutFeedbackReportNestedInput = {
    create?: XOR<ReportCreateWithoutFeedbackReportInput, ReportUncheckedCreateWithoutFeedbackReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutFeedbackReportInput
    upsert?: ReportUpsertWithoutFeedbackReportInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutFeedbackReportInput, ReportUpdateWithoutFeedbackReportInput>, ReportUncheckedUpdateWithoutFeedbackReportInput>
  }

  export type ReportCreateNestedOneWithoutProductReportInput = {
    create?: XOR<ReportCreateWithoutProductReportInput, ReportUncheckedCreateWithoutProductReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutProductReportInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportUpdateOneRequiredWithoutProductReportNestedInput = {
    create?: XOR<ReportCreateWithoutProductReportInput, ReportUncheckedCreateWithoutProductReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutProductReportInput
    upsert?: ReportUpsertWithoutProductReportInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutProductReportInput, ReportUpdateWithoutProductReportInput>, ReportUncheckedUpdateWithoutProductReportInput>
  }

  export type ReportCreateNestedOneWithoutVisibilityReportInput = {
    create?: XOR<ReportCreateWithoutVisibilityReportInput, ReportUncheckedCreateWithoutVisibilityReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutVisibilityReportInput
    connect?: ReportWhereUniqueInput
  }

  export type ReportUpdateOneRequiredWithoutVisibilityReportNestedInput = {
    create?: XOR<ReportCreateWithoutVisibilityReportInput, ReportUncheckedCreateWithoutVisibilityReportInput>
    connectOrCreate?: ReportCreateOrConnectWithoutVisibilityReportInput
    upsert?: ReportUpsertWithoutVisibilityReportInput
    connect?: ReportWhereUniqueInput
    update?: XOR<XOR<ReportUpdateToOneWithWhereWithoutVisibilityReportInput, ReportUpdateWithoutVisibilityReportInput>, ReportUncheckedUpdateWithoutVisibilityReportInput>
  }

  export type SalesRepCreateNestedOneWithoutLeavesInput = {
    create?: XOR<SalesRepCreateWithoutLeavesInput, SalesRepUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutLeavesInput
    connect?: SalesRepWhereUniqueInput
  }

  export type SalesRepUpdateOneRequiredWithoutLeavesNestedInput = {
    create?: XOR<SalesRepCreateWithoutLeavesInput, SalesRepUncheckedCreateWithoutLeavesInput>
    connectOrCreate?: SalesRepCreateOrConnectWithoutLeavesInput
    upsert?: SalesRepUpsertWithoutLeavesInput
    connect?: SalesRepWhereUniqueInput
    update?: XOR<XOR<SalesRepUpdateToOneWithWhereWithoutLeavesInput, SalesRepUpdateWithoutLeavesInput>, SalesRepUncheckedUpdateWithoutLeavesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReportTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeFilter<$PrismaModel> | $Enums.ReportType
  }

  export type NestedEnumReportTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportType | EnumReportTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReportType[]
    notIn?: $Enums.ReportType[]
    not?: NestedEnumReportTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReportType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportTypeFilter<$PrismaModel>
    _max?: NestedEnumReportTypeFilter<$PrismaModel>
  }

  export type CountryCreateWithoutSalesRepInput = {
    name: string
    status?: number | null
    regions?: RegionsCreateNestedManyWithoutCountryInput
    clients?: ClientsCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutSalesRepInput = {
    id?: number
    name: string
    status?: number | null
    regions?: RegionsUncheckedCreateNestedManyWithoutCountryInput
    clients?: ClientsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutSalesRepInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutSalesRepInput, CountryUncheckedCreateWithoutSalesRepInput>
  }

  export type JourneyPlanCreateWithoutUserInput = {
    date: Date | string
    time: string
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    client: ClientsCreateNestedOneWithoutJourneyPlansInput
    reports?: ReportCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanUncheckedCreateWithoutUserInput = {
    id?: number
    date: Date | string
    time: string
    clientId: number
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanCreateOrConnectWithoutUserInput = {
    where: JourneyPlanWhereUniqueInput
    create: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput>
  }

  export type JourneyPlanCreateManyUserInputEnvelope = {
    data: JourneyPlanCreateManyUserInput | JourneyPlanCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutUserInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutUserInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutUserInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportCreateManyUserInputEnvelope = {
    data: ReportCreateManyUserInput | ReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TokenCreateWithoutUserInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenUncheckedCreateWithoutUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type TokenCreateOrConnectWithoutUserInput = {
    where: TokenWhereUniqueInput
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenCreateManyUserInputEnvelope = {
    data: TokenCreateManyUserInput | TokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaveCreateWithoutUserInput = {
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveUncheckedCreateWithoutUserInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveCreateOrConnectWithoutUserInput = {
    where: LeaveWhereUniqueInput
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveCreateManyUserInputEnvelope = {
    data: LeaveCreateManyUserInput | LeaveCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ManagerCreateWithoutUserInput = {
    department?: string | null
    checkins?: ManagerCheckinCreateNestedManyWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutUserInput = {
    id?: number
    department?: string | null
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutManagerInput
  }

  export type ManagerCreateOrConnectWithoutUserInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
  }

  export type MyOrderCreateWithoutUserInput = {
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientsCreateNestedOneWithoutMyOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    reports?: ReportCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderUncheckedCreateWithoutUserInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    reports?: ReportUncheckedCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderCreateOrConnectWithoutUserInput = {
    where: MyOrderWhereUniqueInput
    create: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput>
  }

  export type MyOrderCreateManyUserInputEnvelope = {
    data: MyOrderCreateManyUserInput | MyOrderCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutSalesRepInput = {
    update: XOR<CountryUpdateWithoutSalesRepInput, CountryUncheckedUpdateWithoutSalesRepInput>
    create: XOR<CountryCreateWithoutSalesRepInput, CountryUncheckedCreateWithoutSalesRepInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutSalesRepInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutSalesRepInput, CountryUncheckedUpdateWithoutSalesRepInput>
  }

  export type CountryUpdateWithoutSalesRepInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUpdateManyWithoutCountryNestedInput
    clients?: ClientsUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutSalesRepInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUncheckedUpdateManyWithoutCountryNestedInput
    clients?: ClientsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type JourneyPlanUpsertWithWhereUniqueWithoutUserInput = {
    where: JourneyPlanWhereUniqueInput
    update: XOR<JourneyPlanUpdateWithoutUserInput, JourneyPlanUncheckedUpdateWithoutUserInput>
    create: XOR<JourneyPlanCreateWithoutUserInput, JourneyPlanUncheckedCreateWithoutUserInput>
  }

  export type JourneyPlanUpdateWithWhereUniqueWithoutUserInput = {
    where: JourneyPlanWhereUniqueInput
    data: XOR<JourneyPlanUpdateWithoutUserInput, JourneyPlanUncheckedUpdateWithoutUserInput>
  }

  export type JourneyPlanUpdateManyWithWhereWithoutUserInput = {
    where: JourneyPlanScalarWhereInput
    data: XOR<JourneyPlanUpdateManyMutationInput, JourneyPlanUncheckedUpdateManyWithoutUserInput>
  }

  export type JourneyPlanScalarWhereInput = {
    AND?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
    OR?: JourneyPlanScalarWhereInput[]
    NOT?: JourneyPlanScalarWhereInput | JourneyPlanScalarWhereInput[]
    id?: IntFilter<"JourneyPlan"> | number
    date?: DateTimeFilter<"JourneyPlan"> | Date | string
    time?: StringFilter<"JourneyPlan"> | string
    userId?: IntNullableFilter<"JourneyPlan"> | number | null
    clientId?: IntFilter<"JourneyPlan"> | number
    status?: IntFilter<"JourneyPlan"> | number
    checkInTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
    latitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    longitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    imageUrl?: StringNullableFilter<"JourneyPlan"> | string | null
    notes?: StringNullableFilter<"JourneyPlan"> | string | null
    checkoutLatitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutLongitude?: FloatNullableFilter<"JourneyPlan"> | number | null
    checkoutTime?: DateTimeNullableFilter<"JourneyPlan"> | Date | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReportCreateWithoutUserInput, ReportUncheckedCreateWithoutUserInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutUserInput, ReportUncheckedUpdateWithoutUserInput>
  }

  export type ReportUpdateManyWithWhereWithoutUserInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReportScalarWhereInput = {
    AND?: ReportScalarWhereInput | ReportScalarWhereInput[]
    OR?: ReportScalarWhereInput[]
    NOT?: ReportScalarWhereInput | ReportScalarWhereInput[]
    id?: IntFilter<"Report"> | number
    orderId?: IntNullableFilter<"Report"> | number | null
    clientId?: IntFilter<"Report"> | number
    createdAt?: DateTimeFilter<"Report"> | Date | string
    userId?: IntFilter<"Report"> | number
    journeyPlanId?: IntNullableFilter<"Report"> | number | null
    type?: EnumReportTypeFilter<"Report"> | $Enums.ReportType
  }

  export type TokenUpsertWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    update: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
    create: XOR<TokenCreateWithoutUserInput, TokenUncheckedCreateWithoutUserInput>
  }

  export type TokenUpdateWithWhereUniqueWithoutUserInput = {
    where: TokenWhereUniqueInput
    data: XOR<TokenUpdateWithoutUserInput, TokenUncheckedUpdateWithoutUserInput>
  }

  export type TokenUpdateManyWithWhereWithoutUserInput = {
    where: TokenScalarWhereInput
    data: XOR<TokenUpdateManyMutationInput, TokenUncheckedUpdateManyWithoutUserInput>
  }

  export type TokenScalarWhereInput = {
    AND?: TokenScalarWhereInput | TokenScalarWhereInput[]
    OR?: TokenScalarWhereInput[]
    NOT?: TokenScalarWhereInput | TokenScalarWhereInput[]
    id?: IntFilter<"Token"> | number
    token?: StringFilter<"Token"> | string
    salesRepId?: IntFilter<"Token"> | number
    createdAt?: DateTimeFilter<"Token"> | Date | string
    expiresAt?: DateTimeFilter<"Token"> | Date | string
  }

  export type LeaveUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    update: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveCreateWithoutUserInput, LeaveUncheckedCreateWithoutUserInput>
  }

  export type LeaveUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveWhereUniqueInput
    data: XOR<LeaveUpdateWithoutUserInput, LeaveUncheckedUpdateWithoutUserInput>
  }

  export type LeaveUpdateManyWithWhereWithoutUserInput = {
    where: LeaveScalarWhereInput
    data: XOR<LeaveUpdateManyMutationInput, LeaveUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveScalarWhereInput = {
    AND?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    OR?: LeaveScalarWhereInput[]
    NOT?: LeaveScalarWhereInput | LeaveScalarWhereInput[]
    id?: IntFilter<"Leave"> | number
    userId?: IntFilter<"Leave"> | number
    leaveType?: StringFilter<"Leave"> | string
    startDate?: DateTimeFilter<"Leave"> | Date | string
    endDate?: DateTimeFilter<"Leave"> | Date | string
    reason?: StringFilter<"Leave"> | string
    attachment?: StringNullableFilter<"Leave"> | string | null
    status?: StringFilter<"Leave"> | string
    createdAt?: DateTimeFilter<"Leave"> | Date | string
    updatedAt?: DateTimeFilter<"Leave"> | Date | string
  }

  export type ManagerUpsertWithoutUserInput = {
    update: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
    create: XOR<ManagerCreateWithoutUserInput, ManagerUncheckedCreateWithoutUserInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutUserInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutUserInput, ManagerUncheckedUpdateWithoutUserInput>
  }

  export type ManagerUpdateWithoutUserInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    checkins?: ManagerCheckinUpdateManyWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutManagerNestedInput
  }

  export type MyOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: MyOrderWhereUniqueInput
    update: XOR<MyOrderUpdateWithoutUserInput, MyOrderUncheckedUpdateWithoutUserInput>
    create: XOR<MyOrderCreateWithoutUserInput, MyOrderUncheckedCreateWithoutUserInput>
  }

  export type MyOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: MyOrderWhereUniqueInput
    data: XOR<MyOrderUpdateWithoutUserInput, MyOrderUncheckedUpdateWithoutUserInput>
  }

  export type MyOrderUpdateManyWithWhereWithoutUserInput = {
    where: MyOrderScalarWhereInput
    data: XOR<MyOrderUpdateManyMutationInput, MyOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type MyOrderScalarWhereInput = {
    AND?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
    OR?: MyOrderScalarWhereInput[]
    NOT?: MyOrderScalarWhereInput | MyOrderScalarWhereInput[]
    id?: IntFilter<"MyOrder"> | number
    totalAmount?: FloatFilter<"MyOrder"> | number
    comment?: StringFilter<"MyOrder"> | string
    customerType?: StringFilter<"MyOrder"> | string
    customerId?: StringFilter<"MyOrder"> | string
    customerName?: StringFilter<"MyOrder"> | string
    orderDate?: DateTimeFilter<"MyOrder"> | Date | string
    riderId?: IntNullableFilter<"MyOrder"> | number | null
    riderName?: StringNullableFilter<"MyOrder"> | string | null
    status?: IntFilter<"MyOrder"> | number
    approvedTime?: StringNullableFilter<"MyOrder"> | string | null
    dispatchTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryLocation?: StringNullableFilter<"MyOrder"> | string | null
    complete_latitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_longitude?: StringNullableFilter<"MyOrder"> | string | null
    complete_address?: StringNullableFilter<"MyOrder"> | string | null
    pickupTime?: StringNullableFilter<"MyOrder"> | string | null
    deliveryTime?: StringNullableFilter<"MyOrder"> | string | null
    cancel_reason?: StringNullableFilter<"MyOrder"> | string | null
    recepient?: StringNullableFilter<"MyOrder"> | string | null
    userId?: IntFilter<"MyOrder"> | number
    clientId?: IntFilter<"MyOrder"> | number
    createdAt?: DateTimeFilter<"MyOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MyOrder"> | Date | string
  }

  export type SalesRepCreateWithoutManagerInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutManagerInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutManagerInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutManagerInput, SalesRepUncheckedCreateWithoutManagerInput>
  }

  export type ManagerCheckinCreateWithoutManagerInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
    client: ClientsCreateNestedOneWithoutCheckinsInput
  }

  export type ManagerCheckinUncheckedCreateWithoutManagerInput = {
    id?: number
    clientId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type ManagerCheckinCreateOrConnectWithoutManagerInput = {
    where: ManagerCheckinWhereUniqueInput
    create: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput>
  }

  export type ManagerCheckinCreateManyManagerInputEnvelope = {
    data: ManagerCheckinCreateManyManagerInput | ManagerCheckinCreateManyManagerInput[]
    skipDuplicates?: boolean
  }

  export type SalesRepUpsertWithoutManagerInput = {
    update: XOR<SalesRepUpdateWithoutManagerInput, SalesRepUncheckedUpdateWithoutManagerInput>
    create: XOR<SalesRepCreateWithoutManagerInput, SalesRepUncheckedCreateWithoutManagerInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutManagerInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutManagerInput, SalesRepUncheckedUpdateWithoutManagerInput>
  }

  export type SalesRepUpdateWithoutManagerInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ManagerCheckinUpsertWithWhereUniqueWithoutManagerInput = {
    where: ManagerCheckinWhereUniqueInput
    update: XOR<ManagerCheckinUpdateWithoutManagerInput, ManagerCheckinUncheckedUpdateWithoutManagerInput>
    create: XOR<ManagerCheckinCreateWithoutManagerInput, ManagerCheckinUncheckedCreateWithoutManagerInput>
  }

  export type ManagerCheckinUpdateWithWhereUniqueWithoutManagerInput = {
    where: ManagerCheckinWhereUniqueInput
    data: XOR<ManagerCheckinUpdateWithoutManagerInput, ManagerCheckinUncheckedUpdateWithoutManagerInput>
  }

  export type ManagerCheckinUpdateManyWithWhereWithoutManagerInput = {
    where: ManagerCheckinScalarWhereInput
    data: XOR<ManagerCheckinUpdateManyMutationInput, ManagerCheckinUncheckedUpdateManyWithoutManagerInput>
  }

  export type ManagerCheckinScalarWhereInput = {
    AND?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
    OR?: ManagerCheckinScalarWhereInput[]
    NOT?: ManagerCheckinScalarWhereInput | ManagerCheckinScalarWhereInput[]
    id?: IntFilter<"ManagerCheckin"> | number
    managerId?: IntFilter<"ManagerCheckin"> | number
    clientId?: IntFilter<"ManagerCheckin"> | number
    date?: DateTimeFilter<"ManagerCheckin"> | Date | string
    checkInAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    checkOutAt?: DateTimeNullableFilter<"ManagerCheckin"> | Date | string | null
    latitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    longitude?: FloatNullableFilter<"ManagerCheckin"> | number | null
    notes?: StringNullableFilter<"ManagerCheckin"> | string | null
  }

  export type SalesRepCreateWithoutTokensInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutTokensInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutTokensInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutTokensInput, SalesRepUncheckedCreateWithoutTokensInput>
  }

  export type SalesRepUpsertWithoutTokensInput = {
    update: XOR<SalesRepUpdateWithoutTokensInput, SalesRepUncheckedUpdateWithoutTokensInput>
    create: XOR<SalesRepCreateWithoutTokensInput, SalesRepUncheckedCreateWithoutTokensInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutTokensInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutTokensInput, SalesRepUncheckedUpdateWithoutTokensInput>
  }

  export type SalesRepUpdateWithoutTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CountryCreateWithoutRegionsInput = {
    name: string
    status?: number | null
    clients?: ClientsCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutRegionsInput = {
    id?: number
    name: string
    status?: number | null
    clients?: ClientsUncheckedCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutRegionsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutRegionsInput, CountryUncheckedCreateWithoutRegionsInput>
  }

  export type CountryUpsertWithoutRegionsInput = {
    update: XOR<CountryUpdateWithoutRegionsInput, CountryUncheckedUpdateWithoutRegionsInput>
    create: XOR<CountryCreateWithoutRegionsInput, CountryUncheckedCreateWithoutRegionsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutRegionsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutRegionsInput, CountryUncheckedUpdateWithoutRegionsInput>
  }

  export type CountryUpdateWithoutRegionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientsUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutRegionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    clients?: ClientsUncheckedUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type RegionsCreateWithoutCountryInput = {
    name: string
    status?: number | null
  }

  export type RegionsUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    status?: number | null
  }

  export type RegionsCreateOrConnectWithoutCountryInput = {
    where: RegionsWhereUniqueInput
    create: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput>
  }

  export type RegionsCreateManyCountryInputEnvelope = {
    data: RegionsCreateManyCountryInput | RegionsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type ClientsCreateWithoutCountryInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutCountryInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput>
  }

  export type ClientsCreateManyCountryInputEnvelope = {
    data: ClientsCreateManyCountryInput | ClientsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type SalesRepCreateWithoutCountryInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutCountryInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutCountryInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput>
  }

  export type SalesRepCreateManyCountryInputEnvelope = {
    data: SalesRepCreateManyCountryInput | SalesRepCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type RegionsUpsertWithWhereUniqueWithoutCountryInput = {
    where: RegionsWhereUniqueInput
    update: XOR<RegionsUpdateWithoutCountryInput, RegionsUncheckedUpdateWithoutCountryInput>
    create: XOR<RegionsCreateWithoutCountryInput, RegionsUncheckedCreateWithoutCountryInput>
  }

  export type RegionsUpdateWithWhereUniqueWithoutCountryInput = {
    where: RegionsWhereUniqueInput
    data: XOR<RegionsUpdateWithoutCountryInput, RegionsUncheckedUpdateWithoutCountryInput>
  }

  export type RegionsUpdateManyWithWhereWithoutCountryInput = {
    where: RegionsScalarWhereInput
    data: XOR<RegionsUpdateManyMutationInput, RegionsUncheckedUpdateManyWithoutCountryInput>
  }

  export type RegionsScalarWhereInput = {
    AND?: RegionsScalarWhereInput | RegionsScalarWhereInput[]
    OR?: RegionsScalarWhereInput[]
    NOT?: RegionsScalarWhereInput | RegionsScalarWhereInput[]
    id?: IntFilter<"Regions"> | number
    name?: StringFilter<"Regions"> | string
    countryId?: IntFilter<"Regions"> | number
    status?: IntNullableFilter<"Regions"> | number | null
  }

  export type ClientsUpsertWithWhereUniqueWithoutCountryInput = {
    where: ClientsWhereUniqueInput
    update: XOR<ClientsUpdateWithoutCountryInput, ClientsUncheckedUpdateWithoutCountryInput>
    create: XOR<ClientsCreateWithoutCountryInput, ClientsUncheckedCreateWithoutCountryInput>
  }

  export type ClientsUpdateWithWhereUniqueWithoutCountryInput = {
    where: ClientsWhereUniqueInput
    data: XOR<ClientsUpdateWithoutCountryInput, ClientsUncheckedUpdateWithoutCountryInput>
  }

  export type ClientsUpdateManyWithWhereWithoutCountryInput = {
    where: ClientsScalarWhereInput
    data: XOR<ClientsUpdateManyMutationInput, ClientsUncheckedUpdateManyWithoutCountryInput>
  }

  export type ClientsScalarWhereInput = {
    AND?: ClientsScalarWhereInput | ClientsScalarWhereInput[]
    OR?: ClientsScalarWhereInput[]
    NOT?: ClientsScalarWhereInput | ClientsScalarWhereInput[]
    id?: IntFilter<"Clients"> | number
    name?: StringFilter<"Clients"> | string
    address?: StringNullableFilter<"Clients"> | string | null
    latitude?: FloatNullableFilter<"Clients"> | number | null
    longitude?: FloatNullableFilter<"Clients"> | number | null
    balance?: StringNullableFilter<"Clients"> | string | null
    email?: StringNullableFilter<"Clients"> | string | null
    region_id?: IntFilter<"Clients"> | number
    region?: StringFilter<"Clients"> | string
    contact?: StringFilter<"Clients"> | string
    tax_pin?: StringFilter<"Clients"> | string
    location?: StringFilter<"Clients"> | string
    status?: IntFilter<"Clients"> | number
    client_type?: IntNullableFilter<"Clients"> | number | null
    countryId?: IntFilter<"Clients"> | number
  }

  export type SalesRepUpsertWithWhereUniqueWithoutCountryInput = {
    where: SalesRepWhereUniqueInput
    update: XOR<SalesRepUpdateWithoutCountryInput, SalesRepUncheckedUpdateWithoutCountryInput>
    create: XOR<SalesRepCreateWithoutCountryInput, SalesRepUncheckedCreateWithoutCountryInput>
  }

  export type SalesRepUpdateWithWhereUniqueWithoutCountryInput = {
    where: SalesRepWhereUniqueInput
    data: XOR<SalesRepUpdateWithoutCountryInput, SalesRepUncheckedUpdateWithoutCountryInput>
  }

  export type SalesRepUpdateManyWithWhereWithoutCountryInput = {
    where: SalesRepScalarWhereInput
    data: XOR<SalesRepUpdateManyMutationInput, SalesRepUncheckedUpdateManyWithoutCountryInput>
  }

  export type SalesRepScalarWhereInput = {
    AND?: SalesRepScalarWhereInput | SalesRepScalarWhereInput[]
    OR?: SalesRepScalarWhereInput[]
    NOT?: SalesRepScalarWhereInput | SalesRepScalarWhereInput[]
    id?: IntFilter<"SalesRep"> | number
    name?: StringFilter<"SalesRep"> | string
    email?: StringFilter<"SalesRep"> | string
    phoneNumber?: StringFilter<"SalesRep"> | string
    password?: StringFilter<"SalesRep"> | string
    countryId?: IntFilter<"SalesRep"> | number
    region_id?: IntFilter<"SalesRep"> | number
    region?: StringFilter<"SalesRep"> | string
    role?: StringNullableFilter<"SalesRep"> | string | null
    status?: IntNullableFilter<"SalesRep"> | number | null
    createdAt?: DateTimeFilter<"SalesRep"> | Date | string
    updatedAt?: DateTimeFilter<"SalesRep"> | Date | string
    photoUrl?: StringNullableFilter<"SalesRep"> | string | null
  }

  export type ClientsCreateWithoutProductsInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutProductsInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutProductsInput, ClientsUncheckedCreateWithoutProductsInput>
  }

  export type OrderItemCreateWithoutProductInput = {
    quantity: number
    priceOption?: PriceOptionCreateNestedOneWithoutOrderItemsInput
    order: MyOrderCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutProductInput = {
    id?: number
    orderId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type OrderItemCreateOrConnectWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemCreateManyProductInputEnvelope = {
    data: OrderItemCreateManyProductInput | OrderItemCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type StoreQuantityCreateWithoutProductInput = {
    quantity: number
    store: StoresCreateNestedOneWithoutStoreQuantitiesInput
  }

  export type StoreQuantityUncheckedCreateWithoutProductInput = {
    id?: number
    quantity: number
    storeId: number
  }

  export type StoreQuantityCreateOrConnectWithoutProductInput = {
    where: StoreQuantityWhereUniqueInput
    create: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput>
  }

  export type StoreQuantityCreateManyProductInputEnvelope = {
    data: StoreQuantityCreateManyProductInput | StoreQuantityCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutProductInput = {
    quantity: number
    totalPrice: number
    date?: Date | string
    store: StoresCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutProductInput = {
    id?: number
    storeId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseCreateManyProductInputEnvelope = {
    data: PurchaseCreateManyProductInput | PurchaseCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseHistoryCreateWithoutProductInput = {
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
    store: StoresCreateNestedOneWithoutPurchaseHistoryInput
  }

  export type PurchaseHistoryUncheckedCreateWithoutProductInput = {
    id?: number
    storeId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryCreateOrConnectWithoutProductInput = {
    where: PurchaseHistoryWhereUniqueInput
    create: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput>
  }

  export type PurchaseHistoryCreateManyProductInputEnvelope = {
    data: PurchaseHistoryCreateManyProductInput | PurchaseHistoryCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ClientsUpsertWithoutProductsInput = {
    update: XOR<ClientsUpdateWithoutProductsInput, ClientsUncheckedUpdateWithoutProductsInput>
    create: XOR<ClientsCreateWithoutProductsInput, ClientsUncheckedCreateWithoutProductsInput>
    where?: ClientsWhereInput
  }

  export type ClientsUpdateToOneWithWhereWithoutProductsInput = {
    where?: ClientsWhereInput
    data: XOR<ClientsUpdateWithoutProductsInput, ClientsUncheckedUpdateWithoutProductsInput>
  }

  export type ClientsUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
    create: XOR<OrderItemCreateWithoutProductInput, OrderItemUncheckedCreateWithoutProductInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutProductInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutProductInput, OrderItemUncheckedUpdateWithoutProductInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutProductInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutProductInput>
  }

  export type OrderItemScalarWhereInput = {
    AND?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    OR?: OrderItemScalarWhereInput[]
    NOT?: OrderItemScalarWhereInput | OrderItemScalarWhereInput[]
    id?: IntFilter<"OrderItem"> | number
    orderId?: IntFilter<"OrderItem"> | number
    productId?: IntFilter<"OrderItem"> | number
    quantity?: IntFilter<"OrderItem"> | number
    priceOptionId?: IntNullableFilter<"OrderItem"> | number | null
  }

  export type StoreQuantityUpsertWithWhereUniqueWithoutProductInput = {
    where: StoreQuantityWhereUniqueInput
    update: XOR<StoreQuantityUpdateWithoutProductInput, StoreQuantityUncheckedUpdateWithoutProductInput>
    create: XOR<StoreQuantityCreateWithoutProductInput, StoreQuantityUncheckedCreateWithoutProductInput>
  }

  export type StoreQuantityUpdateWithWhereUniqueWithoutProductInput = {
    where: StoreQuantityWhereUniqueInput
    data: XOR<StoreQuantityUpdateWithoutProductInput, StoreQuantityUncheckedUpdateWithoutProductInput>
  }

  export type StoreQuantityUpdateManyWithWhereWithoutProductInput = {
    where: StoreQuantityScalarWhereInput
    data: XOR<StoreQuantityUpdateManyMutationInput, StoreQuantityUncheckedUpdateManyWithoutProductInput>
  }

  export type StoreQuantityScalarWhereInput = {
    AND?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
    OR?: StoreQuantityScalarWhereInput[]
    NOT?: StoreQuantityScalarWhereInput | StoreQuantityScalarWhereInput[]
    id?: IntFilter<"StoreQuantity"> | number
    quantity?: IntFilter<"StoreQuantity"> | number
    storeId?: IntFilter<"StoreQuantity"> | number
    productId?: IntFilter<"StoreQuantity"> | number
  }

  export type PurchaseUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseCreateWithoutProductInput, PurchaseUncheckedCreateWithoutProductInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutProductInput, PurchaseUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseScalarWhereInput = {
    AND?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    OR?: PurchaseScalarWhereInput[]
    NOT?: PurchaseScalarWhereInput | PurchaseScalarWhereInput[]
    id?: IntFilter<"Purchase"> | number
    productId?: IntFilter<"Purchase"> | number
    storeId?: IntFilter<"Purchase"> | number
    quantity?: IntFilter<"Purchase"> | number
    totalPrice?: IntFilter<"Purchase"> | number
    date?: DateTimeFilter<"Purchase"> | Date | string
  }

  export type PurchaseHistoryUpsertWithWhereUniqueWithoutProductInput = {
    where: PurchaseHistoryWhereUniqueInput
    update: XOR<PurchaseHistoryUpdateWithoutProductInput, PurchaseHistoryUncheckedUpdateWithoutProductInput>
    create: XOR<PurchaseHistoryCreateWithoutProductInput, PurchaseHistoryUncheckedCreateWithoutProductInput>
  }

  export type PurchaseHistoryUpdateWithWhereUniqueWithoutProductInput = {
    where: PurchaseHistoryWhereUniqueInput
    data: XOR<PurchaseHistoryUpdateWithoutProductInput, PurchaseHistoryUncheckedUpdateWithoutProductInput>
  }

  export type PurchaseHistoryUpdateManyWithWhereWithoutProductInput = {
    where: PurchaseHistoryScalarWhereInput
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyWithoutProductInput>
  }

  export type PurchaseHistoryScalarWhereInput = {
    AND?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    OR?: PurchaseHistoryScalarWhereInput[]
    NOT?: PurchaseHistoryScalarWhereInput | PurchaseHistoryScalarWhereInput[]
    id?: IntFilter<"PurchaseHistory"> | number
    storeId?: IntFilter<"PurchaseHistory"> | number
    productId?: IntFilter<"PurchaseHistory"> | number
    previousQuantity?: IntFilter<"PurchaseHistory"> | number
    purchaseQuantity?: IntFilter<"PurchaseHistory"> | number
    newBalance?: IntFilter<"PurchaseHistory"> | number
    createdAt?: DateTimeFilter<"PurchaseHistory"> | Date | string
  }

  export type PriceOptionCreateWithoutCategoryInput = {
    option: string
    value: number
    orderItems?: OrderItemCreateNestedManyWithoutPriceOptionInput
  }

  export type PriceOptionUncheckedCreateWithoutCategoryInput = {
    id?: number
    option: string
    value: number
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutPriceOptionInput
  }

  export type PriceOptionCreateOrConnectWithoutCategoryInput = {
    where: PriceOptionWhereUniqueInput
    create: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput>
  }

  export type PriceOptionCreateManyCategoryInputEnvelope = {
    data: PriceOptionCreateManyCategoryInput | PriceOptionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type PriceOptionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: PriceOptionWhereUniqueInput
    update: XOR<PriceOptionUpdateWithoutCategoryInput, PriceOptionUncheckedUpdateWithoutCategoryInput>
    create: XOR<PriceOptionCreateWithoutCategoryInput, PriceOptionUncheckedCreateWithoutCategoryInput>
  }

  export type PriceOptionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: PriceOptionWhereUniqueInput
    data: XOR<PriceOptionUpdateWithoutCategoryInput, PriceOptionUncheckedUpdateWithoutCategoryInput>
  }

  export type PriceOptionUpdateManyWithWhereWithoutCategoryInput = {
    where: PriceOptionScalarWhereInput
    data: XOR<PriceOptionUpdateManyMutationInput, PriceOptionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type PriceOptionScalarWhereInput = {
    AND?: PriceOptionScalarWhereInput | PriceOptionScalarWhereInput[]
    OR?: PriceOptionScalarWhereInput[]
    NOT?: PriceOptionScalarWhereInput | PriceOptionScalarWhereInput[]
    id?: IntFilter<"PriceOption"> | number
    option?: StringFilter<"PriceOption"> | string
    value?: IntFilter<"PriceOption"> | number
    categoryId?: IntFilter<"PriceOption"> | number
  }

  export type CategoryCreateWithoutPriceOptionsInput = {
    name: string
  }

  export type CategoryUncheckedCreateWithoutPriceOptionsInput = {
    id?: number
    name: string
  }

  export type CategoryCreateOrConnectWithoutPriceOptionsInput = {
    where: CategoryWhereUniqueInput
    create: XOR<CategoryCreateWithoutPriceOptionsInput, CategoryUncheckedCreateWithoutPriceOptionsInput>
  }

  export type OrderItemCreateWithoutPriceOptionInput = {
    quantity: number
    order: MyOrderCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutPriceOptionInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
  }

  export type OrderItemCreateOrConnectWithoutPriceOptionInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput>
  }

  export type OrderItemCreateManyPriceOptionInputEnvelope = {
    data: OrderItemCreateManyPriceOptionInput | OrderItemCreateManyPriceOptionInput[]
    skipDuplicates?: boolean
  }

  export type CategoryUpsertWithoutPriceOptionsInput = {
    update: XOR<CategoryUpdateWithoutPriceOptionsInput, CategoryUncheckedUpdateWithoutPriceOptionsInput>
    create: XOR<CategoryCreateWithoutPriceOptionsInput, CategoryUncheckedCreateWithoutPriceOptionsInput>
    where?: CategoryWhereInput
  }

  export type CategoryUpdateToOneWithWhereWithoutPriceOptionsInput = {
    where?: CategoryWhereInput
    data: XOR<CategoryUpdateWithoutPriceOptionsInput, CategoryUncheckedUpdateWithoutPriceOptionsInput>
  }

  export type CategoryUpdateWithoutPriceOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type CategoryUncheckedUpdateWithoutPriceOptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type OrderItemUpsertWithWhereUniqueWithoutPriceOptionInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutPriceOptionInput, OrderItemUncheckedUpdateWithoutPriceOptionInput>
    create: XOR<OrderItemCreateWithoutPriceOptionInput, OrderItemUncheckedCreateWithoutPriceOptionInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutPriceOptionInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutPriceOptionInput, OrderItemUncheckedUpdateWithoutPriceOptionInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutPriceOptionInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutPriceOptionInput>
  }

  export type ProductCreateWithoutStoreQuantitiesInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    client?: ClientsCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutStoreQuantitiesInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutStoreQuantitiesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutStoreQuantitiesInput, ProductUncheckedCreateWithoutStoreQuantitiesInput>
  }

  export type StoresCreateWithoutStoreQuantitiesInput = {
    name: string
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutStoreQuantitiesInput = {
    id?: number
    name: string
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutStoreQuantitiesInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutStoreQuantitiesInput, StoresUncheckedCreateWithoutStoreQuantitiesInput>
  }

  export type ProductUpsertWithoutStoreQuantitiesInput = {
    update: XOR<ProductUpdateWithoutStoreQuantitiesInput, ProductUncheckedUpdateWithoutStoreQuantitiesInput>
    create: XOR<ProductCreateWithoutStoreQuantitiesInput, ProductUncheckedCreateWithoutStoreQuantitiesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutStoreQuantitiesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutStoreQuantitiesInput, ProductUncheckedUpdateWithoutStoreQuantitiesInput>
  }

  export type ProductUpdateWithoutStoreQuantitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutStoreQuantitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoresUpsertWithoutStoreQuantitiesInput = {
    update: XOR<StoresUpdateWithoutStoreQuantitiesInput, StoresUncheckedUpdateWithoutStoreQuantitiesInput>
    create: XOR<StoresCreateWithoutStoreQuantitiesInput, StoresUncheckedCreateWithoutStoreQuantitiesInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutStoreQuantitiesInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutStoreQuantitiesInput, StoresUncheckedUpdateWithoutStoreQuantitiesInput>
  }

  export type StoresUpdateWithoutStoreQuantitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutStoreQuantitiesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoreQuantityCreateWithoutStoreInput = {
    quantity: number
    product: ProductCreateNestedOneWithoutStoreQuantitiesInput
  }

  export type StoreQuantityUncheckedCreateWithoutStoreInput = {
    id?: number
    quantity: number
    productId: number
  }

  export type StoreQuantityCreateOrConnectWithoutStoreInput = {
    where: StoreQuantityWhereUniqueInput
    create: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput>
  }

  export type StoreQuantityCreateManyStoreInputEnvelope = {
    data: StoreQuantityCreateManyStoreInput | StoreQuantityCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseCreateWithoutStoreInput = {
    quantity: number
    totalPrice: number
    date?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseInput
  }

  export type PurchaseUncheckedCreateWithoutStoreInput = {
    id?: number
    productId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseCreateOrConnectWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseCreateManyStoreInputEnvelope = {
    data: PurchaseCreateManyStoreInput | PurchaseCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseHistoryCreateWithoutStoreInput = {
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutPurchaseHistoryInput
  }

  export type PurchaseHistoryUncheckedCreateWithoutStoreInput = {
    id?: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type PurchaseHistoryCreateOrConnectWithoutStoreInput = {
    where: PurchaseHistoryWhereUniqueInput
    create: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseHistoryCreateManyStoreInputEnvelope = {
    data: PurchaseHistoryCreateManyStoreInput | PurchaseHistoryCreateManyStoreInput[]
    skipDuplicates?: boolean
  }

  export type StoreQuantityUpsertWithWhereUniqueWithoutStoreInput = {
    where: StoreQuantityWhereUniqueInput
    update: XOR<StoreQuantityUpdateWithoutStoreInput, StoreQuantityUncheckedUpdateWithoutStoreInput>
    create: XOR<StoreQuantityCreateWithoutStoreInput, StoreQuantityUncheckedCreateWithoutStoreInput>
  }

  export type StoreQuantityUpdateWithWhereUniqueWithoutStoreInput = {
    where: StoreQuantityWhereUniqueInput
    data: XOR<StoreQuantityUpdateWithoutStoreInput, StoreQuantityUncheckedUpdateWithoutStoreInput>
  }

  export type StoreQuantityUpdateManyWithWhereWithoutStoreInput = {
    where: StoreQuantityScalarWhereInput
    data: XOR<StoreQuantityUpdateManyMutationInput, StoreQuantityUncheckedUpdateManyWithoutStoreInput>
  }

  export type PurchaseUpsertWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    update: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
    create: XOR<PurchaseCreateWithoutStoreInput, PurchaseUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseUpdateWithWhereUniqueWithoutStoreInput = {
    where: PurchaseWhereUniqueInput
    data: XOR<PurchaseUpdateWithoutStoreInput, PurchaseUncheckedUpdateWithoutStoreInput>
  }

  export type PurchaseUpdateManyWithWhereWithoutStoreInput = {
    where: PurchaseScalarWhereInput
    data: XOR<PurchaseUpdateManyMutationInput, PurchaseUncheckedUpdateManyWithoutStoreInput>
  }

  export type PurchaseHistoryUpsertWithWhereUniqueWithoutStoreInput = {
    where: PurchaseHistoryWhereUniqueInput
    update: XOR<PurchaseHistoryUpdateWithoutStoreInput, PurchaseHistoryUncheckedUpdateWithoutStoreInput>
    create: XOR<PurchaseHistoryCreateWithoutStoreInput, PurchaseHistoryUncheckedCreateWithoutStoreInput>
  }

  export type PurchaseHistoryUpdateWithWhereUniqueWithoutStoreInput = {
    where: PurchaseHistoryWhereUniqueInput
    data: XOR<PurchaseHistoryUpdateWithoutStoreInput, PurchaseHistoryUncheckedUpdateWithoutStoreInput>
  }

  export type PurchaseHistoryUpdateManyWithWhereWithoutStoreInput = {
    where: PurchaseHistoryScalarWhereInput
    data: XOR<PurchaseHistoryUpdateManyMutationInput, PurchaseHistoryUncheckedUpdateManyWithoutStoreInput>
  }

  export type ProductCreateWithoutPurchaseInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    client?: ClientsCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
  }

  export type StoresCreateWithoutPurchaseInput = {
    name: string
    storeQuantities?: StoreQuantityCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutPurchaseInput = {
    id?: number
    name: string
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutStoreInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutPurchaseInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutPurchaseInput, StoresUncheckedCreateWithoutPurchaseInput>
  }

  export type ProductUpsertWithoutPurchaseInput = {
    update: XOR<ProductUpdateWithoutPurchaseInput, ProductUncheckedUpdateWithoutPurchaseInput>
    create: XOR<ProductCreateWithoutPurchaseInput, ProductUncheckedCreateWithoutPurchaseInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseInput, ProductUncheckedUpdateWithoutPurchaseInput>
  }

  export type ProductUpdateWithoutPurchaseInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type StoresUpsertWithoutPurchaseInput = {
    update: XOR<StoresUpdateWithoutPurchaseInput, StoresUncheckedUpdateWithoutPurchaseInput>
    create: XOR<StoresCreateWithoutPurchaseInput, StoresUncheckedCreateWithoutPurchaseInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutPurchaseInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutPurchaseInput, StoresUncheckedUpdateWithoutPurchaseInput>
  }

  export type StoresUpdateWithoutPurchaseInput = {
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutPurchaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutStoreNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type StoresCreateWithoutPurchaseHistoryInput = {
    name: string
    storeQuantities?: StoreQuantityCreateNestedManyWithoutStoreInput
    purchase?: PurchaseCreateNestedManyWithoutStoreInput
  }

  export type StoresUncheckedCreateWithoutPurchaseHistoryInput = {
    id?: number
    name: string
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutStoreInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutStoreInput
  }

  export type StoresCreateOrConnectWithoutPurchaseHistoryInput = {
    where: StoresWhereUniqueInput
    create: XOR<StoresCreateWithoutPurchaseHistoryInput, StoresUncheckedCreateWithoutPurchaseHistoryInput>
  }

  export type ProductCreateWithoutPurchaseHistoryInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    client?: ClientsCreateNestedOneWithoutProductsInput
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutPurchaseHistoryInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutProductInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutPurchaseHistoryInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutPurchaseHistoryInput, ProductUncheckedCreateWithoutPurchaseHistoryInput>
  }

  export type StoresUpsertWithoutPurchaseHistoryInput = {
    update: XOR<StoresUpdateWithoutPurchaseHistoryInput, StoresUncheckedUpdateWithoutPurchaseHistoryInput>
    create: XOR<StoresCreateWithoutPurchaseHistoryInput, StoresUncheckedCreateWithoutPurchaseHistoryInput>
    where?: StoresWhereInput
  }

  export type StoresUpdateToOneWithWhereWithoutPurchaseHistoryInput = {
    where?: StoresWhereInput
    data: XOR<StoresUpdateWithoutPurchaseHistoryInput, StoresUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type StoresUpdateWithoutPurchaseHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUpdateManyWithoutStoreNestedInput
  }

  export type StoresUncheckedUpdateWithoutPurchaseHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutStoreNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutStoreNestedInput
  }

  export type ProductUpsertWithoutPurchaseHistoryInput = {
    update: XOR<ProductUpdateWithoutPurchaseHistoryInput, ProductUncheckedUpdateWithoutPurchaseHistoryInput>
    create: XOR<ProductCreateWithoutPurchaseHistoryInput, ProductUncheckedCreateWithoutPurchaseHistoryInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutPurchaseHistoryInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutPurchaseHistoryInput, ProductUncheckedUpdateWithoutPurchaseHistoryInput>
  }

  export type ProductUpdateWithoutPurchaseHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneWithoutProductsNestedInput
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutPurchaseHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
  }

  export type CountryCreateWithoutClientsInput = {
    name: string
    status?: number | null
    regions?: RegionsCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepCreateNestedManyWithoutCountryInput
  }

  export type CountryUncheckedCreateWithoutClientsInput = {
    id?: number
    name: string
    status?: number | null
    regions?: RegionsUncheckedCreateNestedManyWithoutCountryInput
    salesRep?: SalesRepUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountryCreateOrConnectWithoutClientsInput = {
    where: CountryWhereUniqueInput
    create: XOR<CountryCreateWithoutClientsInput, CountryUncheckedCreateWithoutClientsInput>
  }

  export type JourneyPlanCreateWithoutClientInput = {
    date: Date | string
    time: string
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    user?: SalesRepCreateNestedOneWithoutJourneyPlansInput
    reports?: ReportCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanUncheckedCreateWithoutClientInput = {
    id?: number
    date: Date | string
    time: string
    userId?: number | null
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    reports?: ReportUncheckedCreateNestedManyWithoutJourneyPlanInput
  }

  export type JourneyPlanCreateOrConnectWithoutClientInput = {
    where: JourneyPlanWhereUniqueInput
    create: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput>
  }

  export type JourneyPlanCreateManyClientInputEnvelope = {
    data: JourneyPlanCreateManyClientInput | JourneyPlanCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type MyOrderCreateWithoutClientInput = {
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: SalesRepCreateNestedOneWithoutMyOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
    reports?: ReportCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderUncheckedCreateWithoutClientInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
    reports?: ReportUncheckedCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderCreateOrConnectWithoutClientInput = {
    where: MyOrderWhereUniqueInput
    create: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput>
  }

  export type MyOrderCreateManyClientInputEnvelope = {
    data: MyOrderCreateManyClientInput | MyOrderCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProductCreateWithoutClientInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    orderItems?: OrderItemCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutClientInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutProductInput
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutProductInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutClientInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput>
  }

  export type ProductCreateManyClientInputEnvelope = {
    data: ProductCreateManyClientInput | ProductCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutClientInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutClientInput = {
    id?: number
    orderId?: number | null
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutClientInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput>
  }

  export type ReportCreateManyClientInputEnvelope = {
    data: ReportCreateManyClientInput | ReportCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ManagerCheckinCreateWithoutClientInput = {
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
    manager: ManagerCreateNestedOneWithoutCheckinsInput
  }

  export type ManagerCheckinUncheckedCreateWithoutClientInput = {
    id?: number
    managerId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type ManagerCheckinCreateOrConnectWithoutClientInput = {
    where: ManagerCheckinWhereUniqueInput
    create: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput>
  }

  export type ManagerCheckinCreateManyClientInputEnvelope = {
    data: ManagerCheckinCreateManyClientInput | ManagerCheckinCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type CountryUpsertWithoutClientsInput = {
    update: XOR<CountryUpdateWithoutClientsInput, CountryUncheckedUpdateWithoutClientsInput>
    create: XOR<CountryCreateWithoutClientsInput, CountryUncheckedCreateWithoutClientsInput>
    where?: CountryWhereInput
  }

  export type CountryUpdateToOneWithWhereWithoutClientsInput = {
    where?: CountryWhereInput
    data: XOR<CountryUpdateWithoutClientsInput, CountryUncheckedUpdateWithoutClientsInput>
  }

  export type CountryUpdateWithoutClientsInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUpdateManyWithoutCountryNestedInput
  }

  export type CountryUncheckedUpdateWithoutClientsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
    regions?: RegionsUncheckedUpdateManyWithoutCountryNestedInput
    salesRep?: SalesRepUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type JourneyPlanUpsertWithWhereUniqueWithoutClientInput = {
    where: JourneyPlanWhereUniqueInput
    update: XOR<JourneyPlanUpdateWithoutClientInput, JourneyPlanUncheckedUpdateWithoutClientInput>
    create: XOR<JourneyPlanCreateWithoutClientInput, JourneyPlanUncheckedCreateWithoutClientInput>
  }

  export type JourneyPlanUpdateWithWhereUniqueWithoutClientInput = {
    where: JourneyPlanWhereUniqueInput
    data: XOR<JourneyPlanUpdateWithoutClientInput, JourneyPlanUncheckedUpdateWithoutClientInput>
  }

  export type JourneyPlanUpdateManyWithWhereWithoutClientInput = {
    where: JourneyPlanScalarWhereInput
    data: XOR<JourneyPlanUpdateManyMutationInput, JourneyPlanUncheckedUpdateManyWithoutClientInput>
  }

  export type MyOrderUpsertWithWhereUniqueWithoutClientInput = {
    where: MyOrderWhereUniqueInput
    update: XOR<MyOrderUpdateWithoutClientInput, MyOrderUncheckedUpdateWithoutClientInput>
    create: XOR<MyOrderCreateWithoutClientInput, MyOrderUncheckedCreateWithoutClientInput>
  }

  export type MyOrderUpdateWithWhereUniqueWithoutClientInput = {
    where: MyOrderWhereUniqueInput
    data: XOR<MyOrderUpdateWithoutClientInput, MyOrderUncheckedUpdateWithoutClientInput>
  }

  export type MyOrderUpdateManyWithWhereWithoutClientInput = {
    where: MyOrderScalarWhereInput
    data: XOR<MyOrderUpdateManyMutationInput, MyOrderUncheckedUpdateManyWithoutClientInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutClientInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutClientInput, ProductUncheckedUpdateWithoutClientInput>
    create: XOR<ProductCreateWithoutClientInput, ProductUncheckedCreateWithoutClientInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutClientInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutClientInput, ProductUncheckedUpdateWithoutClientInput>
  }

  export type ProductUpdateManyWithWhereWithoutClientInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutClientInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: IntFilter<"Product"> | number
    name?: StringFilter<"Product"> | string
    category_id?: IntFilter<"Product"> | number
    category?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    currentStock?: IntNullableFilter<"Product"> | number | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    clientId?: IntNullableFilter<"Product"> | number | null
    image?: StringNullableFilter<"Product"> | string | null
  }

  export type ReportUpsertWithWhereUniqueWithoutClientInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutClientInput, ReportUncheckedUpdateWithoutClientInput>
    create: XOR<ReportCreateWithoutClientInput, ReportUncheckedCreateWithoutClientInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutClientInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutClientInput, ReportUncheckedUpdateWithoutClientInput>
  }

  export type ReportUpdateManyWithWhereWithoutClientInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutClientInput>
  }

  export type ManagerCheckinUpsertWithWhereUniqueWithoutClientInput = {
    where: ManagerCheckinWhereUniqueInput
    update: XOR<ManagerCheckinUpdateWithoutClientInput, ManagerCheckinUncheckedUpdateWithoutClientInput>
    create: XOR<ManagerCheckinCreateWithoutClientInput, ManagerCheckinUncheckedCreateWithoutClientInput>
  }

  export type ManagerCheckinUpdateWithWhereUniqueWithoutClientInput = {
    where: ManagerCheckinWhereUniqueInput
    data: XOR<ManagerCheckinUpdateWithoutClientInput, ManagerCheckinUncheckedUpdateWithoutClientInput>
  }

  export type ManagerCheckinUpdateManyWithWhereWithoutClientInput = {
    where: ManagerCheckinScalarWhereInput
    data: XOR<ManagerCheckinUpdateManyMutationInput, ManagerCheckinUncheckedUpdateManyWithoutClientInput>
  }

  export type ManagerCreateWithoutCheckinsInput = {
    department?: string | null
    user: SalesRepCreateNestedOneWithoutManagerInput
  }

  export type ManagerUncheckedCreateWithoutCheckinsInput = {
    id?: number
    userId: number
    department?: string | null
  }

  export type ManagerCreateOrConnectWithoutCheckinsInput = {
    where: ManagerWhereUniqueInput
    create: XOR<ManagerCreateWithoutCheckinsInput, ManagerUncheckedCreateWithoutCheckinsInput>
  }

  export type ClientsCreateWithoutCheckinsInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutCheckinsInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutCheckinsInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutCheckinsInput, ClientsUncheckedCreateWithoutCheckinsInput>
  }

  export type ManagerUpsertWithoutCheckinsInput = {
    update: XOR<ManagerUpdateWithoutCheckinsInput, ManagerUncheckedUpdateWithoutCheckinsInput>
    create: XOR<ManagerCreateWithoutCheckinsInput, ManagerUncheckedCreateWithoutCheckinsInput>
    where?: ManagerWhereInput
  }

  export type ManagerUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: ManagerWhereInput
    data: XOR<ManagerUpdateWithoutCheckinsInput, ManagerUncheckedUpdateWithoutCheckinsInput>
  }

  export type ManagerUpdateWithoutCheckinsInput = {
    department?: NullableStringFieldUpdateOperationsInput | string | null
    user?: SalesRepUpdateOneRequiredWithoutManagerNestedInput
  }

  export type ManagerUncheckedUpdateWithoutCheckinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    department?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ClientsUpsertWithoutCheckinsInput = {
    update: XOR<ClientsUpdateWithoutCheckinsInput, ClientsUncheckedUpdateWithoutCheckinsInput>
    create: XOR<ClientsCreateWithoutCheckinsInput, ClientsUncheckedCreateWithoutCheckinsInput>
    where?: ClientsWhereInput
  }

  export type ClientsUpdateToOneWithWhereWithoutCheckinsInput = {
    where?: ClientsWhereInput
    data: XOR<ClientsUpdateWithoutCheckinsInput, ClientsUncheckedUpdateWithoutCheckinsInput>
  }

  export type ClientsUpdateWithoutCheckinsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutCheckinsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientsCreateWithoutMyOrderInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutMyOrderInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutMyOrderInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutMyOrderInput, ClientsUncheckedCreateWithoutMyOrderInput>
  }

  export type SalesRepCreateWithoutMyOrderInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutMyOrderInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutMyOrderInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutMyOrderInput, SalesRepUncheckedCreateWithoutMyOrderInput>
  }

  export type OrderItemCreateWithoutOrderInput = {
    quantity: number
    priceOption?: PriceOptionCreateNestedOneWithoutOrderItemsInput
    product: ProductCreateNestedOneWithoutOrderItemsInput
  }

  export type OrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    productId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type OrderItemCreateOrConnectWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemCreateManyOrderInputEnvelope = {
    data: OrderItemCreateManyOrderInput | OrderItemCreateManyOrderInput[]
    skipDuplicates?: boolean
  }

  export type ReportCreateWithoutMyOrderInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutMyOrderInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutMyOrderInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput>
  }

  export type ClientsUpsertWithoutMyOrderInput = {
    update: XOR<ClientsUpdateWithoutMyOrderInput, ClientsUncheckedUpdateWithoutMyOrderInput>
    create: XOR<ClientsCreateWithoutMyOrderInput, ClientsUncheckedCreateWithoutMyOrderInput>
    where?: ClientsWhereInput
  }

  export type ClientsUpdateToOneWithWhereWithoutMyOrderInput = {
    where?: ClientsWhereInput
    data: XOR<ClientsUpdateWithoutMyOrderInput, ClientsUncheckedUpdateWithoutMyOrderInput>
  }

  export type ClientsUpdateWithoutMyOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutMyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type SalesRepUpsertWithoutMyOrderInput = {
    update: XOR<SalesRepUpdateWithoutMyOrderInput, SalesRepUncheckedUpdateWithoutMyOrderInput>
    create: XOR<SalesRepCreateWithoutMyOrderInput, SalesRepUncheckedCreateWithoutMyOrderInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutMyOrderInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutMyOrderInput, SalesRepUncheckedUpdateWithoutMyOrderInput>
  }

  export type SalesRepUpdateWithoutMyOrderInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutMyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
  }

  export type OrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    update: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<OrderItemCreateWithoutOrderInput, OrderItemUncheckedCreateWithoutOrderInput>
  }

  export type OrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: OrderItemWhereUniqueInput
    data: XOR<OrderItemUpdateWithoutOrderInput, OrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type OrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: OrderItemScalarWhereInput
    data: XOR<OrderItemUpdateManyMutationInput, OrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type ReportUpsertWithWhereUniqueWithoutMyOrderInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutMyOrderInput, ReportUncheckedUpdateWithoutMyOrderInput>
    create: XOR<ReportCreateWithoutMyOrderInput, ReportUncheckedCreateWithoutMyOrderInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutMyOrderInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutMyOrderInput, ReportUncheckedUpdateWithoutMyOrderInput>
  }

  export type ReportUpdateManyWithWhereWithoutMyOrderInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutMyOrderInput>
  }

  export type PriceOptionCreateWithoutOrderItemsInput = {
    option: string
    value: number
    category: CategoryCreateNestedOneWithoutPriceOptionsInput
  }

  export type PriceOptionUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    option: string
    value: number
    categoryId: number
  }

  export type PriceOptionCreateOrConnectWithoutOrderItemsInput = {
    where: PriceOptionWhereUniqueInput
    create: XOR<PriceOptionCreateWithoutOrderItemsInput, PriceOptionUncheckedCreateWithoutOrderItemsInput>
  }

  export type MyOrderCreateWithoutOrderItemsInput = {
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientsCreateNestedOneWithoutMyOrderInput
    user: SalesRepCreateNestedOneWithoutMyOrderInput
    reports?: ReportCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    reports?: ReportUncheckedCreateNestedManyWithoutMyOrderInput
  }

  export type MyOrderCreateOrConnectWithoutOrderItemsInput = {
    where: MyOrderWhereUniqueInput
    create: XOR<MyOrderCreateWithoutOrderItemsInput, MyOrderUncheckedCreateWithoutOrderItemsInput>
  }

  export type ProductCreateWithoutOrderItemsInput = {
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
    client?: ClientsCreateNestedOneWithoutProductsInput
    storeQuantities?: StoreQuantityCreateNestedManyWithoutProductInput
    purchase?: PurchaseCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientId?: number | null
    image?: string | null
    storeQuantities?: StoreQuantityUncheckedCreateNestedManyWithoutProductInput
    purchase?: PurchaseUncheckedCreateNestedManyWithoutProductInput
    purchaseHistory?: PurchaseHistoryUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOrderItemsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
  }

  export type PriceOptionUpsertWithoutOrderItemsInput = {
    update: XOR<PriceOptionUpdateWithoutOrderItemsInput, PriceOptionUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<PriceOptionCreateWithoutOrderItemsInput, PriceOptionUncheckedCreateWithoutOrderItemsInput>
    where?: PriceOptionWhereInput
  }

  export type PriceOptionUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: PriceOptionWhereInput
    data: XOR<PriceOptionUpdateWithoutOrderItemsInput, PriceOptionUncheckedUpdateWithoutOrderItemsInput>
  }

  export type PriceOptionUpdateWithoutOrderItemsInput = {
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    category?: CategoryUpdateOneRequiredWithoutPriceOptionsNestedInput
  }

  export type PriceOptionUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    categoryId?: IntFieldUpdateOperationsInput | number
  }

  export type MyOrderUpsertWithoutOrderItemsInput = {
    update: XOR<MyOrderUpdateWithoutOrderItemsInput, MyOrderUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MyOrderCreateWithoutOrderItemsInput, MyOrderUncheckedCreateWithoutOrderItemsInput>
    where?: MyOrderWhereInput
  }

  export type MyOrderUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: MyOrderWhereInput
    data: XOR<MyOrderUpdateWithoutOrderItemsInput, MyOrderUncheckedUpdateWithoutOrderItemsInput>
  }

  export type MyOrderUpdateWithoutOrderItemsInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientsUpdateOneRequiredWithoutMyOrderNestedInput
    user?: SalesRepUpdateOneRequiredWithoutMyOrderNestedInput
    reports?: ReportUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reports?: ReportUncheckedUpdateManyWithoutMyOrderNestedInput
  }

  export type ProductUpsertWithoutOrderItemsInput = {
    update: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<ProductCreateWithoutOrderItemsInput, ProductUncheckedCreateWithoutOrderItemsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOrderItemsInput, ProductUncheckedUpdateWithoutOrderItemsInput>
  }

  export type ProductUpdateWithoutOrderItemsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneWithoutProductsNestedInput
    storeQuantities?: StoreQuantityUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientId?: NullableIntFieldUpdateOperationsInput | number | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ClientsCreateWithoutJourneyPlansInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    reports?: ReportCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutJourneyPlansInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    reports?: ReportUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutJourneyPlansInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutJourneyPlansInput, ClientsUncheckedCreateWithoutJourneyPlansInput>
  }

  export type SalesRepCreateWithoutJourneyPlansInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutJourneyPlansInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutJourneyPlansInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutJourneyPlansInput, SalesRepUncheckedCreateWithoutJourneyPlansInput>
  }

  export type ReportCreateWithoutJourneyPlanInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutJourneyPlanInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutJourneyPlanInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput>
  }

  export type ReportCreateManyJourneyPlanInputEnvelope = {
    data: ReportCreateManyJourneyPlanInput | ReportCreateManyJourneyPlanInput[]
    skipDuplicates?: boolean
  }

  export type ClientsUpsertWithoutJourneyPlansInput = {
    update: XOR<ClientsUpdateWithoutJourneyPlansInput, ClientsUncheckedUpdateWithoutJourneyPlansInput>
    create: XOR<ClientsCreateWithoutJourneyPlansInput, ClientsUncheckedCreateWithoutJourneyPlansInput>
    where?: ClientsWhereInput
  }

  export type ClientsUpdateToOneWithWhereWithoutJourneyPlansInput = {
    where?: ClientsWhereInput
    data: XOR<ClientsUpdateWithoutJourneyPlansInput, ClientsUncheckedUpdateWithoutJourneyPlansInput>
  }

  export type ClientsUpdateWithoutJourneyPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutJourneyPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type SalesRepUpsertWithoutJourneyPlansInput = {
    update: XOR<SalesRepUpdateWithoutJourneyPlansInput, SalesRepUncheckedUpdateWithoutJourneyPlansInput>
    create: XOR<SalesRepCreateWithoutJourneyPlansInput, SalesRepUncheckedCreateWithoutJourneyPlansInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutJourneyPlansInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutJourneyPlansInput, SalesRepUncheckedUpdateWithoutJourneyPlansInput>
  }

  export type SalesRepUpdateWithoutJourneyPlansInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutJourneyPlansInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ReportUpsertWithWhereUniqueWithoutJourneyPlanInput = {
    where: ReportWhereUniqueInput
    update: XOR<ReportUpdateWithoutJourneyPlanInput, ReportUncheckedUpdateWithoutJourneyPlanInput>
    create: XOR<ReportCreateWithoutJourneyPlanInput, ReportUncheckedCreateWithoutJourneyPlanInput>
  }

  export type ReportUpdateWithWhereUniqueWithoutJourneyPlanInput = {
    where: ReportWhereUniqueInput
    data: XOR<ReportUpdateWithoutJourneyPlanInput, ReportUncheckedUpdateWithoutJourneyPlanInput>
  }

  export type ReportUpdateManyWithWhereWithoutJourneyPlanInput = {
    where: ReportScalarWhereInput
    data: XOR<ReportUpdateManyMutationInput, ReportUncheckedUpdateManyWithoutJourneyPlanInput>
  }

  export type FeedbackReportCreateWithoutReportInput = {
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackReportUncheckedCreateWithoutReportInput = {
    comment?: string | null
    createdAt?: Date | string
  }

  export type FeedbackReportCreateOrConnectWithoutReportInput = {
    where: FeedbackReportWhereUniqueInput
    create: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
  }

  export type ProductReportCreateWithoutReportInput = {
    productName?: string | null
    quantity?: number | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProductReportUncheckedCreateWithoutReportInput = {
    productName?: string | null
    quantity?: number | null
    comment?: string | null
    createdAt?: Date | string
  }

  export type ProductReportCreateOrConnectWithoutReportInput = {
    where: ProductReportWhereUniqueInput
    create: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
  }

  export type JourneyPlanCreateWithoutReportsInput = {
    date: Date | string
    time: string
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
    client: ClientsCreateNestedOneWithoutJourneyPlansInput
    user?: SalesRepCreateNestedOneWithoutJourneyPlansInput
  }

  export type JourneyPlanUncheckedCreateWithoutReportsInput = {
    id?: number
    date: Date | string
    time: string
    userId?: number | null
    clientId: number
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
  }

  export type JourneyPlanCreateOrConnectWithoutReportsInput = {
    where: JourneyPlanWhereUniqueInput
    create: XOR<JourneyPlanCreateWithoutReportsInput, JourneyPlanUncheckedCreateWithoutReportsInput>
  }

  export type MyOrderCreateWithoutReportsInput = {
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    client: ClientsCreateNestedOneWithoutMyOrderInput
    user: SalesRepCreateNestedOneWithoutMyOrderInput
    orderItems?: OrderItemCreateNestedManyWithoutOrderInput
  }

  export type MyOrderUncheckedCreateWithoutReportsInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    orderItems?: OrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type MyOrderCreateOrConnectWithoutReportsInput = {
    where: MyOrderWhereUniqueInput
    create: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput>
  }

  export type ClientsCreateWithoutReportsInput = {
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    country: CountryCreateNestedOneWithoutClientsInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderCreateNestedManyWithoutClientInput
    products?: ProductCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinCreateNestedManyWithoutClientInput
  }

  export type ClientsUncheckedCreateWithoutReportsInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
    countryId: number
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutClientInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutClientInput
    products?: ProductUncheckedCreateNestedManyWithoutClientInput
    checkins?: ManagerCheckinUncheckedCreateNestedManyWithoutClientInput
  }

  export type ClientsCreateOrConnectWithoutReportsInput = {
    where: ClientsWhereUniqueInput
    create: XOR<ClientsCreateWithoutReportsInput, ClientsUncheckedCreateWithoutReportsInput>
  }

  export type SalesRepCreateWithoutReportsInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    leaves?: LeaveCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutReportsInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    leaves?: LeaveUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutReportsInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutReportsInput, SalesRepUncheckedCreateWithoutReportsInput>
  }

  export type VisibilityReportCreateWithoutReportInput = {
    comment?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type VisibilityReportUncheckedCreateWithoutReportInput = {
    comment?: string | null
    imageUrl?: string | null
    createdAt?: Date | string
  }

  export type VisibilityReportCreateOrConnectWithoutReportInput = {
    where: VisibilityReportWhereUniqueInput
    create: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
  }

  export type FeedbackReportUpsertWithoutReportInput = {
    update: XOR<FeedbackReportUpdateWithoutReportInput, FeedbackReportUncheckedUpdateWithoutReportInput>
    create: XOR<FeedbackReportCreateWithoutReportInput, FeedbackReportUncheckedCreateWithoutReportInput>
    where?: FeedbackReportWhereInput
  }

  export type FeedbackReportUpdateToOneWithWhereWithoutReportInput = {
    where?: FeedbackReportWhereInput
    data: XOR<FeedbackReportUpdateWithoutReportInput, FeedbackReportUncheckedUpdateWithoutReportInput>
  }

  export type FeedbackReportUpdateWithoutReportInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FeedbackReportUncheckedUpdateWithoutReportInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReportUpsertWithoutReportInput = {
    update: XOR<ProductReportUpdateWithoutReportInput, ProductReportUncheckedUpdateWithoutReportInput>
    create: XOR<ProductReportCreateWithoutReportInput, ProductReportUncheckedCreateWithoutReportInput>
    where?: ProductReportWhereInput
  }

  export type ProductReportUpdateToOneWithWhereWithoutReportInput = {
    where?: ProductReportWhereInput
    data: XOR<ProductReportUpdateWithoutReportInput, ProductReportUncheckedUpdateWithoutReportInput>
  }

  export type ProductReportUpdateWithoutReportInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductReportUncheckedUpdateWithoutReportInput = {
    productName?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableIntFieldUpdateOperationsInput | number | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyPlanUpsertWithoutReportsInput = {
    update: XOR<JourneyPlanUpdateWithoutReportsInput, JourneyPlanUncheckedUpdateWithoutReportsInput>
    create: XOR<JourneyPlanCreateWithoutReportsInput, JourneyPlanUncheckedCreateWithoutReportsInput>
    where?: JourneyPlanWhereInput
  }

  export type JourneyPlanUpdateToOneWithWhereWithoutReportsInput = {
    where?: JourneyPlanWhereInput
    data: XOR<JourneyPlanUpdateWithoutReportsInput, JourneyPlanUncheckedUpdateWithoutReportsInput>
  }

  export type JourneyPlanUpdateWithoutReportsInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientsUpdateOneRequiredWithoutJourneyPlansNestedInput
    user?: SalesRepUpdateOneWithoutJourneyPlansNestedInput
  }

  export type JourneyPlanUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MyOrderUpsertWithWhereUniqueWithoutReportsInput = {
    where: MyOrderWhereUniqueInput
    update: XOR<MyOrderUpdateWithoutReportsInput, MyOrderUncheckedUpdateWithoutReportsInput>
    create: XOR<MyOrderCreateWithoutReportsInput, MyOrderUncheckedCreateWithoutReportsInput>
  }

  export type MyOrderUpdateWithWhereUniqueWithoutReportsInput = {
    where: MyOrderWhereUniqueInput
    data: XOR<MyOrderUpdateWithoutReportsInput, MyOrderUncheckedUpdateWithoutReportsInput>
  }

  export type MyOrderUpdateManyWithWhereWithoutReportsInput = {
    where: MyOrderScalarWhereInput
    data: XOR<MyOrderUpdateManyMutationInput, MyOrderUncheckedUpdateManyWithoutReportsInput>
  }

  export type ClientsUpsertWithoutReportsInput = {
    update: XOR<ClientsUpdateWithoutReportsInput, ClientsUncheckedUpdateWithoutReportsInput>
    create: XOR<ClientsCreateWithoutReportsInput, ClientsUncheckedCreateWithoutReportsInput>
    where?: ClientsWhereInput
  }

  export type ClientsUpdateToOneWithWhereWithoutReportsInput = {
    where?: ClientsWhereInput
    data: XOR<ClientsUpdateWithoutReportsInput, ClientsUncheckedUpdateWithoutReportsInput>
  }

  export type ClientsUpdateWithoutReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    country?: CountryUpdateOneRequiredWithoutClientsNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    countryId?: IntFieldUpdateOperationsInput | number
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type SalesRepUpsertWithoutReportsInput = {
    update: XOR<SalesRepUpdateWithoutReportsInput, SalesRepUncheckedUpdateWithoutReportsInput>
    create: XOR<SalesRepCreateWithoutReportsInput, SalesRepUncheckedCreateWithoutReportsInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutReportsInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutReportsInput, SalesRepUncheckedUpdateWithoutReportsInput>
  }

  export type SalesRepUpdateWithoutReportsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type VisibilityReportUpsertWithoutReportInput = {
    update: XOR<VisibilityReportUpdateWithoutReportInput, VisibilityReportUncheckedUpdateWithoutReportInput>
    create: XOR<VisibilityReportCreateWithoutReportInput, VisibilityReportUncheckedCreateWithoutReportInput>
    where?: VisibilityReportWhereInput
  }

  export type VisibilityReportUpdateToOneWithWhereWithoutReportInput = {
    where?: VisibilityReportWhereInput
    data: XOR<VisibilityReportUpdateWithoutReportInput, VisibilityReportUncheckedUpdateWithoutReportInput>
  }

  export type VisibilityReportUpdateWithoutReportInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VisibilityReportUncheckedUpdateWithoutReportInput = {
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReportCreateWithoutFeedbackReportInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutFeedbackReportInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutFeedbackReportInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutFeedbackReportInput, ReportUncheckedCreateWithoutFeedbackReportInput>
  }

  export type ReportUpsertWithoutFeedbackReportInput = {
    update: XOR<ReportUpdateWithoutFeedbackReportInput, ReportUncheckedUpdateWithoutFeedbackReportInput>
    create: XOR<ReportCreateWithoutFeedbackReportInput, ReportUncheckedCreateWithoutFeedbackReportInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutFeedbackReportInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutFeedbackReportInput, ReportUncheckedUpdateWithoutFeedbackReportInput>
  }

  export type ReportUpdateWithoutFeedbackReportInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutFeedbackReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportCreateWithoutProductReportInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
    visibilityReport?: VisibilityReportCreateNestedOneWithoutReportInput
  }

  export type ReportUncheckedCreateWithoutProductReportInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
    visibilityReport?: VisibilityReportUncheckedCreateNestedOneWithoutReportInput
  }

  export type ReportCreateOrConnectWithoutProductReportInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutProductReportInput, ReportUncheckedCreateWithoutProductReportInput>
  }

  export type ReportUpsertWithoutProductReportInput = {
    update: XOR<ReportUpdateWithoutProductReportInput, ReportUncheckedUpdateWithoutProductReportInput>
    create: XOR<ReportCreateWithoutProductReportInput, ReportUncheckedCreateWithoutProductReportInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutProductReportInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutProductReportInput, ReportUncheckedUpdateWithoutProductReportInput>
  }

  export type ReportUpdateWithoutProductReportInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutProductReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportCreateWithoutVisibilityReportInput = {
    orderId?: number | null
    createdAt?: Date | string
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportCreateNestedOneWithoutReportInput
    productReport?: ProductReportCreateNestedOneWithoutReportInput
    journeyPlan?: JourneyPlanCreateNestedOneWithoutReportsInput
    MyOrder?: MyOrderCreateNestedManyWithoutReportsInput
    client: ClientsCreateNestedOneWithoutReportsInput
    user: SalesRepCreateNestedOneWithoutReportsInput
  }

  export type ReportUncheckedCreateWithoutVisibilityReportInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedCreateNestedOneWithoutReportInput
    productReport?: ProductReportUncheckedCreateNestedOneWithoutReportInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutReportsInput
  }

  export type ReportCreateOrConnectWithoutVisibilityReportInput = {
    where: ReportWhereUniqueInput
    create: XOR<ReportCreateWithoutVisibilityReportInput, ReportUncheckedCreateWithoutVisibilityReportInput>
  }

  export type ReportUpsertWithoutVisibilityReportInput = {
    update: XOR<ReportUpdateWithoutVisibilityReportInput, ReportUncheckedUpdateWithoutVisibilityReportInput>
    create: XOR<ReportCreateWithoutVisibilityReportInput, ReportUncheckedCreateWithoutVisibilityReportInput>
    where?: ReportWhereInput
  }

  export type ReportUpdateToOneWithWhereWithoutVisibilityReportInput = {
    where?: ReportWhereInput
    data: XOR<ReportUpdateWithoutVisibilityReportInput, ReportUncheckedUpdateWithoutVisibilityReportInput>
  }

  export type ReportUpdateWithoutVisibilityReportInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReportUncheckedUpdateWithoutVisibilityReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
  }

  export type SalesRepCreateWithoutLeavesInput = {
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    country: CountryCreateNestedOneWithoutSalesRepInput
    journeyPlans?: JourneyPlanCreateNestedManyWithoutUserInput
    reports?: ReportCreateNestedManyWithoutUserInput
    tokens?: TokenCreateNestedManyWithoutUserInput
    Manager?: ManagerCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderCreateNestedManyWithoutUserInput
  }

  export type SalesRepUncheckedCreateWithoutLeavesInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    countryId: number
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
    journeyPlans?: JourneyPlanUncheckedCreateNestedManyWithoutUserInput
    reports?: ReportUncheckedCreateNestedManyWithoutUserInput
    tokens?: TokenUncheckedCreateNestedManyWithoutUserInput
    Manager?: ManagerUncheckedCreateNestedOneWithoutUserInput
    MyOrder?: MyOrderUncheckedCreateNestedManyWithoutUserInput
  }

  export type SalesRepCreateOrConnectWithoutLeavesInput = {
    where: SalesRepWhereUniqueInput
    create: XOR<SalesRepCreateWithoutLeavesInput, SalesRepUncheckedCreateWithoutLeavesInput>
  }

  export type SalesRepUpsertWithoutLeavesInput = {
    update: XOR<SalesRepUpdateWithoutLeavesInput, SalesRepUncheckedUpdateWithoutLeavesInput>
    create: XOR<SalesRepCreateWithoutLeavesInput, SalesRepUncheckedCreateWithoutLeavesInput>
    where?: SalesRepWhereInput
  }

  export type SalesRepUpdateToOneWithWhereWithoutLeavesInput = {
    where?: SalesRepWhereInput
    data: XOR<SalesRepUpdateWithoutLeavesInput, SalesRepUncheckedUpdateWithoutLeavesInput>
  }

  export type SalesRepUpdateWithoutLeavesInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    country?: CountryUpdateOneRequiredWithoutSalesRepNestedInput
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutLeavesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    countryId?: IntFieldUpdateOperationsInput | number
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type JourneyPlanCreateManyUserInput = {
    id?: number
    date: Date | string
    time: string
    clientId: number
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
  }

  export type ReportCreateManyUserInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    journeyPlanId?: number | null
    type: $Enums.ReportType
  }

  export type TokenCreateManyUserInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type LeaveCreateManyUserInput = {
    id?: number
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    reason: string
    attachment?: string | null
    status?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MyOrderCreateManyUserInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    clientId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type JourneyPlanUpdateWithoutUserInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    client?: ClientsUpdateOneRequiredWithoutJourneyPlansNestedInput
    reports?: ReportUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    clientId?: IntFieldUpdateOperationsInput | number
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportUpdateWithoutUserInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type TokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUpdateWithoutUserInput = {
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    attachment?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MyOrderUpdateWithoutUserInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientsUpdateOneRequiredWithoutMyOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    reports?: ReportUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ManagerCheckinCreateManyManagerInput = {
    id?: number
    clientId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type ManagerCheckinUpdateWithoutManagerInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    client?: ClientsUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type ManagerCheckinUncheckedUpdateWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCheckinUncheckedUpdateManyWithoutManagerInput = {
    id?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RegionsCreateManyCountryInput = {
    id?: number
    name: string
    status?: number | null
  }

  export type ClientsCreateManyCountryInput = {
    id?: number
    name: string
    address?: string | null
    latitude?: number | null
    longitude?: number | null
    balance?: string | null
    email?: string | null
    region_id: number
    region: string
    contact: string
    tax_pin: string
    location: string
    status?: number
    client_type?: number | null
  }

  export type SalesRepCreateManyCountryInput = {
    id?: number
    name: string
    email: string
    phoneNumber: string
    password: string
    region_id: number
    region: string
    role?: string | null
    status?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    photoUrl?: string | null
  }

  export type RegionsUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RegionsUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type RegionsUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    status?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ClientsUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    journeyPlans?: JourneyPlanUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUpdateManyWithoutClientNestedInput
    products?: ProductUpdateManyWithoutClientNestedInput
    reports?: ReportUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutClientNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutClientNestedInput
    products?: ProductUncheckedUpdateManyWithoutClientNestedInput
    reports?: ReportUncheckedUpdateManyWithoutClientNestedInput
    checkins?: ManagerCheckinUncheckedUpdateManyWithoutClientNestedInput
  }

  export type ClientsUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    balance?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    contact?: StringFieldUpdateOperationsInput | string
    tax_pin?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    client_type?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SalesRepUpdateWithoutCountryInput = {
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUpdateManyWithoutUserNestedInput
    reports?: ReportUpdateManyWithoutUserNestedInput
    tokens?: TokenUpdateManyWithoutUserNestedInput
    leaves?: LeaveUpdateManyWithoutUserNestedInput
    Manager?: ManagerUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    journeyPlans?: JourneyPlanUncheckedUpdateManyWithoutUserNestedInput
    reports?: ReportUncheckedUpdateManyWithoutUserNestedInput
    tokens?: TokenUncheckedUpdateManyWithoutUserNestedInput
    leaves?: LeaveUncheckedUpdateManyWithoutUserNestedInput
    Manager?: ManagerUncheckedUpdateOneWithoutUserNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutUserNestedInput
  }

  export type SalesRepUncheckedUpdateManyWithoutCountryInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    region_id?: IntFieldUpdateOperationsInput | number
    region?: StringFieldUpdateOperationsInput | string
    role?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    photoUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyProductInput = {
    id?: number
    orderId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type StoreQuantityCreateManyProductInput = {
    id?: number
    quantity: number
    storeId: number
  }

  export type PurchaseCreateManyProductInput = {
    id?: number
    storeId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseHistoryCreateManyProductInput = {
    id?: number
    storeId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type OrderItemUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    priceOption?: PriceOptionUpdateOneWithoutOrderItemsNestedInput
    order?: MyOrderUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type StoreQuantityUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    store?: StoresUpdateOneRequiredWithoutStoreQuantitiesNestedInput
  }

  export type StoreQuantityUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseUpdateWithoutProductInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUpdateWithoutProductInput = {
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    store?: StoresUpdateOneRequiredWithoutPurchaseHistoryNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    storeId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PriceOptionCreateManyCategoryInput = {
    id?: number
    option: string
    value: number
  }

  export type PriceOptionUpdateWithoutCategoryInput = {
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemUpdateManyWithoutPriceOptionNestedInput
  }

  export type PriceOptionUncheckedUpdateWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
    orderItems?: OrderItemUncheckedUpdateManyWithoutPriceOptionNestedInput
  }

  export type PriceOptionUncheckedUpdateManyWithoutCategoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    option?: StringFieldUpdateOperationsInput | string
    value?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemCreateManyPriceOptionInput = {
    id?: number
    orderId: number
    productId: number
    quantity: number
  }

  export type OrderItemUpdateWithoutPriceOptionInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    order?: MyOrderUpdateOneRequiredWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutPriceOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type OrderItemUncheckedUpdateManyWithoutPriceOptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityCreateManyStoreInput = {
    id?: number
    quantity: number
    productId: number
  }

  export type PurchaseCreateManyStoreInput = {
    id?: number
    productId: number
    quantity: number
    totalPrice: number
    date?: Date | string
  }

  export type PurchaseHistoryCreateManyStoreInput = {
    id?: number
    productId: number
    previousQuantity: number
    purchaseQuantity: number
    newBalance: number
    createdAt?: Date | string
  }

  export type StoreQuantityUpdateWithoutStoreInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutStoreQuantitiesNestedInput
  }

  export type StoreQuantityUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type StoreQuantityUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
  }

  export type PurchaseUpdateWithoutStoreInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseNestedInput
  }

  export type PurchaseUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    totalPrice?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUpdateWithoutStoreInput = {
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutPurchaseHistoryNestedInput
  }

  export type PurchaseHistoryUncheckedUpdateWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseHistoryUncheckedUpdateManyWithoutStoreInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    previousQuantity?: IntFieldUpdateOperationsInput | number
    purchaseQuantity?: IntFieldUpdateOperationsInput | number
    newBalance?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type JourneyPlanCreateManyClientInput = {
    id?: number
    date: Date | string
    time: string
    userId?: number | null
    status?: number
    checkInTime?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    imageUrl?: string | null
    notes?: string | null
    checkoutLatitude?: number | null
    checkoutLongitude?: number | null
    checkoutTime?: Date | string | null
  }

  export type MyOrderCreateManyClientInput = {
    id?: number
    totalAmount: number
    comment: string
    customerType: string
    customerId: string
    customerName: string
    orderDate?: Date | string
    riderId?: number | null
    riderName?: string | null
    status?: number
    approvedTime?: string | null
    dispatchTime?: string | null
    deliveryLocation?: string | null
    complete_latitude?: string | null
    complete_longitude?: string | null
    complete_address?: string | null
    pickupTime?: string | null
    deliveryTime?: string | null
    cancel_reason?: string | null
    recepient?: string | null
    userId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateManyClientInput = {
    id?: number
    name: string
    category_id: number
    category: string
    description?: string | null
    currentStock?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: string | null
  }

  export type ReportCreateManyClientInput = {
    id?: number
    orderId?: number | null
    createdAt?: Date | string
    userId: number
    journeyPlanId?: number | null
    type: $Enums.ReportType
  }

  export type ManagerCheckinCreateManyClientInput = {
    id?: number
    managerId: number
    date: Date | string
    checkInAt?: Date | string | null
    checkOutAt?: Date | string | null
    latitude?: number | null
    longitude?: number | null
    notes?: string | null
  }

  export type JourneyPlanUpdateWithoutClientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: SalesRepUpdateOneWithoutJourneyPlansNestedInput
    reports?: ReportUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reports?: ReportUncheckedUpdateManyWithoutJourneyPlanNestedInput
  }

  export type JourneyPlanUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    userId?: NullableIntFieldUpdateOperationsInput | number | null
    status?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    checkoutLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    checkoutTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MyOrderUpdateWithoutClientInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: SalesRepUpdateOneRequiredWithoutMyOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
    reports?: ReportUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
    reports?: ReportUncheckedUpdateManyWithoutMyOrderNestedInput
  }

  export type MyOrderUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUpdateWithoutClientInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    orderItems?: OrderItemUncheckedUpdateManyWithoutProductNestedInput
    storeQuantities?: StoreQuantityUncheckedUpdateManyWithoutProductNestedInput
    purchase?: PurchaseUncheckedUpdateManyWithoutProductNestedInput
    purchaseHistory?: PurchaseHistoryUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    category_id?: IntFieldUpdateOperationsInput | number
    category?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    currentStock?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportUpdateWithoutClientInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type ManagerCheckinUpdateWithoutClientInput = {
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    manager?: ManagerUpdateOneRequiredWithoutCheckinsNestedInput
  }

  export type ManagerCheckinUncheckedUpdateWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    managerId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ManagerCheckinUncheckedUpdateManyWithoutClientInput = {
    id?: IntFieldUpdateOperationsInput | number
    managerId?: IntFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    checkInAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    checkOutAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OrderItemCreateManyOrderInput = {
    id?: number
    productId: number
    quantity: number
    priceOptionId?: number | null
  }

  export type OrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    priceOption?: PriceOptionUpdateOneWithoutOrderItemsNestedInput
    product?: ProductUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type OrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    productId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    priceOptionId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ReportUpdateWithoutMyOrderInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    journeyPlan?: JourneyPlanUpdateOneWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutMyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutMyOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    journeyPlanId?: NullableIntFieldUpdateOperationsInput | number | null
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type ReportCreateManyJourneyPlanInput = {
    id?: number
    orderId?: number | null
    clientId: number
    createdAt?: Date | string
    userId: number
    type: $Enums.ReportType
  }

  export type ReportUpdateWithoutJourneyPlanInput = {
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUpdateManyWithoutReportsNestedInput
    client?: ClientsUpdateOneRequiredWithoutReportsNestedInput
    user?: SalesRepUpdateOneRequiredWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateWithoutJourneyPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
    feedbackReport?: FeedbackReportUncheckedUpdateOneWithoutReportNestedInput
    productReport?: ProductReportUncheckedUpdateOneWithoutReportNestedInput
    MyOrder?: MyOrderUncheckedUpdateManyWithoutReportsNestedInput
    visibilityReport?: VisibilityReportUncheckedUpdateOneWithoutReportNestedInput
  }

  export type ReportUncheckedUpdateManyWithoutJourneyPlanInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: NullableIntFieldUpdateOperationsInput | number | null
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: EnumReportTypeFieldUpdateOperationsInput | $Enums.ReportType
  }

  export type MyOrderUpdateWithoutReportsInput = {
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: ClientsUpdateOneRequiredWithoutMyOrderNestedInput
    user?: SalesRepUpdateOneRequiredWithoutMyOrderNestedInput
    orderItems?: OrderItemUpdateManyWithoutOrderNestedInput
  }

  export type MyOrderUncheckedUpdateWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: OrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MyOrderUncheckedUpdateManyWithoutReportsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalAmount?: FloatFieldUpdateOperationsInput | number
    comment?: StringFieldUpdateOperationsInput | string
    customerType?: StringFieldUpdateOperationsInput | string
    customerId?: StringFieldUpdateOperationsInput | string
    customerName?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    riderId?: NullableIntFieldUpdateOperationsInput | number | null
    riderName?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    approvedTime?: NullableStringFieldUpdateOperationsInput | string | null
    dispatchTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryLocation?: NullableStringFieldUpdateOperationsInput | string | null
    complete_latitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_longitude?: NullableStringFieldUpdateOperationsInput | string | null
    complete_address?: NullableStringFieldUpdateOperationsInput | string | null
    pickupTime?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancel_reason?: NullableStringFieldUpdateOperationsInput | string | null
    recepient?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    clientId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use SalesRepCountOutputTypeDefaultArgs instead
     */
    export type SalesRepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesRepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerCountOutputTypeDefaultArgs instead
     */
    export type ManagerCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryCountOutputTypeDefaultArgs instead
     */
    export type CountryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductCountOutputTypeDefaultArgs instead
     */
    export type ProductCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryCountOutputTypeDefaultArgs instead
     */
    export type CategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceOptionCountOutputTypeDefaultArgs instead
     */
    export type PriceOptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceOptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoresCountOutputTypeDefaultArgs instead
     */
    export type StoresCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoresCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientsCountOutputTypeDefaultArgs instead
     */
    export type ClientsCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientsCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MyOrderCountOutputTypeDefaultArgs instead
     */
    export type MyOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MyOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JourneyPlanCountOutputTypeDefaultArgs instead
     */
    export type JourneyPlanCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JourneyPlanCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportCountOutputTypeDefaultArgs instead
     */
    export type ReportCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SalesRepDefaultArgs instead
     */
    export type SalesRepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SalesRepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerDefaultArgs instead
     */
    export type ManagerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenDefaultArgs instead
     */
    export type TokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegionsDefaultArgs instead
     */
    export type RegionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegionsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountryDefaultArgs instead
     */
    export type CountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductDefaultArgs instead
     */
    export type ProductArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CategoryDefaultArgs instead
     */
    export type CategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PriceOptionDefaultArgs instead
     */
    export type PriceOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PriceOptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoreQuantityDefaultArgs instead
     */
    export type StoreQuantityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoreQuantityDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StoresDefaultArgs instead
     */
    export type StoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StoresDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseDefaultArgs instead
     */
    export type PurchaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PurchaseHistoryDefaultArgs instead
     */
    export type PurchaseHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PurchaseHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClientsDefaultArgs instead
     */
    export type ClientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClientsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RidersDefaultArgs instead
     */
    export type RidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RidersDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RidersCompanyDefaultArgs instead
     */
    export type RidersCompanyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RidersCompanyDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ManagerCheckinDefaultArgs instead
     */
    export type ManagerCheckinArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ManagerCheckinDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MyOrderDefaultArgs instead
     */
    export type MyOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MyOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OrderItemDefaultArgs instead
     */
    export type OrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use JourneyPlanDefaultArgs instead
     */
    export type JourneyPlanArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = JourneyPlanDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NoticeBoardDefaultArgs instead
     */
    export type NoticeBoardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NoticeBoardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReportDefaultArgs instead
     */
    export type ReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FeedbackReportDefaultArgs instead
     */
    export type FeedbackReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FeedbackReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProductReportDefaultArgs instead
     */
    export type ProductReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProductReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VisibilityReportDefaultArgs instead
     */
    export type VisibilityReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VisibilityReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveDefaultArgs instead
     */
    export type LeaveArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}